Prompt,ChatGPTScore
"# Working set

src/frontend/getBaseUrl.js:
```
export const getBaseUrl = () => {
    const queryString = window.location.search;
    const urlParams = new URLSearchParams(queryString);
    const baseUrl = urlParams.get('baseUrl');

    return baseUrl || 'http://localhost:10101';
};

```

src/frontend/service/createWebSocket.js:
```
export const createWebSocket = () => {
  const ws = new WebSocket('ws://localhost:3000');
  return ws;
};

```


# Task

Implement the following feature!

- Create a plan!
- Create new files when needed!
- Every js file should only export a single function!
- Use ES6 imports!

Requirements:

Use getBaseUrl instead of hardcoding the URL.
Derive the correct ws protocol from the base url!



# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, prefer heredoc-ing full files without substitution.
Assume OSX.
npm and jq are installed.
Do NOT write any text outside the script (the plan goes into it)!


EXAMPLE START

```sh
#!/bin/sh
# Goal: [Task description, max 7 words]
# Plan:
# 1. [...]

[Commands solving the task]
```

EXAMPLE END

",74
"You are AI Junior, you code like Donald Knuth.
# Working set

./src/backend/startServer.js:
```
import express from 'express';
import cors from 'cors';
import { createServer } from 'http';
import { WebSocketServer } from 'ws';
import { setupRoutes } from './setupRoutes.js';
import { notifyOnFileChange } from './notifyOnFileChange.js';
import { getServerPort } from './serverConfig.js';
import hostConfig from '../config/hostConfig.js';

export function startServer() {
  const app = express();

  app.use(cors());
  app.use(express.json());

  const server = createServer(app);
  const wss = new WebSocketServer({ server });

  notifyOnFileChange(wss);

  setupRoutes(app);

  const { enabled, ip } = hostConfig();

  const port = getServerPort();
  server.listen(port, ip || (enabled ? '0.0.0.0' : undefined), () => {
    console.log('Server is running on port', port);
  });
}

```

./src/backend/setupRoutes.js:
```
import { setupGitRoutes } from './routes/setupGitRoutes.js';
import { setupPromptRoutes } from './routes/setupPromptRoutes.js';
import { executeHandler } from './handlers/executeHandler.js';
import { configHandler } from './handlers/configHandler.js';
import { setupFilesRoutes } from './routes/setupFilesRoutes.js';  // Added this line

export function setupRoutes(app) {
  setupPromptRoutes(app);
  setupGitRoutes(app);
  setupFilesRoutes(app);  // Added this line
  app.post('/execute', executeHandler);
  app.get('/config', configHandler);
}

```


# Task

Implement the following feature!

- Create a plan!
- Create new files when needed!

Requirements:

- Create backend/terminal/ directory
- Write a backend server to be used with xterm.js.
- Design the communication protocol.
- Start the server automatically during app init.


## Project Specifics

- Every js file should *only export a single function or signal, as default*! eg.: in createGitRepo.js: export default function createGitRepo ( ....
- Use *ES6 imports*!
- Prefer *async/await* over promises!
- The frontend uses *Solidjs* and Tailwind, edit .jsx files accordingly!

# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, avoid using sed in favor of heredoc-ing full files.

OS: OSX

Installed tools: npm, jq


Before your solution, write a concise readme about the working set, your task, and most importantly its challanges, if any.


EXAMPLE START
```sh
#!/bin/sh
set -e
goal=[Task description, max 9 words]
echo ""Plan:""
echo ""1. [...]""
cat > x.js << 'EOF'
[...]
'EOF'
echo ""\033[32mDone: $goal\033[0m\n""
```
EXAMPLE END

Before starting, check if you need more files or info to solve the task.

If the task is not clear:

EXAMPLE START
I need more information to solve the task. [Description of the missing info]
EXAMPLE END

Do not edit files not provided in the working set!
If you need more files:

EXAMPLE START
`filepath1` is needed to solve the task but is not in the working set.
EXAMPLE END


",90
"You are AI Junior, you code like Donald Knuth.
# Working set

./src/frontend/service/useWebsocket.js:
```
import { createEffect } from 'solid-js';
import { createWebSocket } from './createWebSocket.js';

export const useWebsocket = (onMessage) => {
  let socket = createWebSocket();

  socket.onopen = () => console.log('WebSocket is connected');
  socket.onmessage = onMessage;
  socket.onerror = (error) => console.log('WebSocket error:', error);

  createEffect(() => {
    if (!socket || socket.readyState === WebSocket.CLOSED) {
      socket = createWebSocket();
      socket.onmessage = onMessage;
    }
  });

  return () => {
    if (socket && socket.readyState === WebSocket.OPEN) {
      socket.close();
    }
  };
};

```

./src/frontend/service/createWebSocket.js:
```
import { getBaseUrl } from '../getBaseUrl.js';

export const createWebSocket = () => {
  const baseUrl = getBaseUrl();
  const wsUrl = baseUrl.replace(/^http/, 'ws');
  const ws = new WebSocket(wsUrl);
  return ws;
};

```

./src/backend/startServer.js:
```
import express from 'express';
import cors from 'cors';
import { createServer } from 'http';
import { WebSocketServer } from 'ws';
import { setupRoutes } from './setupRoutes.js';
import { notifyOnFileChange } from './notifyOnFileChange.js';
import { getServerPort } from './serverConfig.js';
import hostConfig from '../config/hostConfig.js';

export function startServer() {
  const app = express();

  app.use(cors());
  app.use(express.json());

  const server = createServer(app);
  const wss = new WebSocketServer({ server });

  notifyOnFileChange(wss);

  setupRoutes(app);

  const { enabled, ip } = hostConfig();

  const port = getServerPort();
  server.listen(port, ip || (enabled ? '0.0.0.0' : undefined), () => {
    console.log('Server is running on port', port);
  });
}

```


# Task

Answer the following question!

We need a terminal on the frontend. We already have a websocket server, we should use it.
What are the best tools on either side? We prefer not to install anything, but don't yet want to write much code. Write your answer to docs/design/terminal_dependency_selection.md

# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, avoid using sed in favor of heredoc-ing full files.

OS: OSX

Installed tools: npm, jq


Before your solution, write a concise readme about the working set, your task, and most importantly its challanges, if any.


EXAMPLE START
```sh
#!/bin/sh
set -e
goal=[Task description, max 9 words]
echo ""Plan:""
echo ""1. [...]""
cat > x.js << 'EOF'
[...]
'EOF'
echo ""\033[32mDone: $goal\033[0m\n""
```
EXAMPLE END

Before starting, check if you need more files or info to solve the task.

If the task is not clear:

EXAMPLE START
I need more information to solve the task. [Description of the missing info]
EXAMPLE END

Do not edit files not provided in the working set!
If you need more files:

EXAMPLE START
`filepath1` is needed to solve the task but is not in the working set.
EXAMPLE END


",96
"You are AI Junior, you code like Donald Knuth.
# Working set

./src/backend/fileutils/getIgnoreList.js:
```
function getIgnoreList() {
  const DEFAULT_IGNORE = ['.git', 'node_modules', './prompt'];

  const cliArgs = process.argv.slice(2);
  const cliIgnore = cliArgs
    .filter(arg => arg.startsWith('--ignore='))
    .map(arg => arg.replace('--ignore=', '').split(','))
    .flat();

  const envIgnore = process.env.JUNIOR_IGNORE ? process.env.JUNIOR_IGNORE.split(',') : [];

  const totalIgnore = [...DEFAULT_IGNORE, ...cliIgnore, ...envIgnore];

  const nameIgnore = totalIgnore.filter(item => !item.startsWith('./'));
  const pathIgnore = totalIgnore.filter(item => item.startsWith('./')).map(item => item.slice(2));

  return { nameIgnore, pathIgnore };
}

export default getIgnoreList;


```


# Task

Implement the following feature!

- Create a plan!
- Create new files when needed!

Requirements:

Add ""dist"", ""build"", ""tmp"", ""temp"" and at least 5 but up to 100 reasonable entries to the ignore list!


## Project Specifics

- Every js file should *only export a single function or signal, as default*! eg.: in createGitRepo.js: export default function createGitRepo ( ....
- Use *ES6 imports*!
- Prefer *async/await* over promises!
- The frontend uses *Solidjs* and Tailwind, edit .jsx files accordingly!

# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, avoid using sed in favor of heredoc-ing full files.

OS: OSX

Installed tools: npm, jq


Before your solution, write a concise readme about the working set, your task, and most importantly its challanges, if any.


EXAMPLE START
```sh
#!/bin/sh
set -e
goal=[Task description, max 9 words]
echo ""Plan:""
echo ""1. [...]""
cat > x.js << 'EOF'
[...]
'EOF'
echo ""\033[32mDone: $goal\033[0m\n""
```
EXAMPLE END

Before starting, check if you need more files or info to solve the task.

If the task is not clear:

EXAMPLE START
I need more information to solve the task. [Description of the missing info]
EXAMPLE END

Do not edit files not provided in the working set!
If you need more files:

EXAMPLE START
`filepath1` is needed to solve the task but is not in the working set.
EXAMPLE END


",85
"You're the 'Contributor', an AI system aiding authors.

You are working on the source of a program, too large for your memory, so only part of it, the ""Working Set"" is provided here.

You will see a partial directory structure. Ask for the contents of subdirs marked with /... if needed.

Some files are printed in the working set.

Other files are only listed in their dir, so you know they exists. Do not edit files without knowing their current content, ask for their contents instead!

# Working set

```
./
?????€??€ .git/...
?????€??€ .gitignore
?????€??€ README.md
?????€??€ babel.config.js
?????€??€ change.sh
?????€??€ doc/...
?????€??€ node_modules/...
?????€??€ package-lock.json
?????€??€ package.json
?????€??€ prompt/...
?????€??€ prompt.md
?????€??€ prompt.yaml
?????€??€ secret.sh
?????€??€ src/...

```
package.json:
```
{
  ""name"": ""@aijunior/dev"",
  ""version"": ""0.0.1"",
  ""description"": ""Your AI Contributor"",
  ""type"": ""module"",
  ""main"": ""src/main.js"",
  ""bin"": {
    ""junior"": ""src/main.js"",
    ""junior-web"": ""npm start""
  },
  ""scripts"": {
    ""cli"": ""node src/main.js"",
    ""start"": ""node src/backend/server.js --prompt=prompt.yaml -s & vite src --open ""
  },
  ""keywords"": [
    ""cli"",
    ""uppercase""
  ],
  ""author"": """",
  ""license"": ""GPL"",
  ""dependencies"": {
    ""autoprefixer"": ""^10.4.14"",
    ""chatgpt"": ""^5.2.4"",
    ""clipboard-copy"": ""^4.0.1"",
    ""cors"": ""^2.8.5"",
    ""ejs"": ""^3.1.9"",
    ""express"": ""^4.18.2"",
    ""js-yaml"": ""^4.1.0"",
    ""marked"": ""^5.1.0"",
    ""postcss"": ""^8.4.24"",
    ""solid-js"": ""^1.7.7"",
    ""tailwindcss"": ""^3.3.2"",
    ""vite"": ""^4.3.9"",
    ""vite-plugin-solid"": ""^2.7.0""
  },
  ""directories"": {
    ""doc"": ""doc""
  },
  ""repository"": {
    ""type"": ""git"",
    ""url"": ""git+https://github.com/tisztamo/Junior.git""
  },
  ""bugs"": {
    ""url"": ""https://github.com/tisztamo/Junior/issues""
  },
  ""homepage"": ""https://github.com/tisztamo/Junior#readme"",
  ""devDependencies"": {
    ""babel-preset-solid"": ""^1.7.7""
  }
}

```

src/backend/server.js:
```
import express from 'express';
import cors from 'cors';
import { generateHandler, descriptorHandler, taskUpdateHandler } from './handlers.js';
import { listTasks } from './listTasks.js';

const app = express();

app.use(cors());
app.use(express.json());

app.get('/descriptor', descriptorHandler);
app.get('/tasks', (req, res) => res.json({ tasks: listTasks() }));

app.post('/generate', generateHandler);
app.post('/updatetask', taskUpdateHandler);

app.listen(3000, () => {
  console.log('Server is running on port 3000');
});

```


# Task

Implement the following feature!

- Create a plan!
- Create new files when needed!
- Every js file should only export a single function!
- Use ES6 imports!

Requirements:

A single js file called web.js is needed that starts both the server and vite, so that the &#34;start&#34; script can look like &#34;start&#34;: &#34;node src/web.js&#34;. Both the server and vite runs indefinitely, their output needs to be forwarded to the console of the &#34;node web.js&#34; process and they should be stopped when that process stops. Separate the start of them to files startServer.js and startVite.js.



# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, prefer heredoc-ing full files without substitution.
Assume OSX.
npm and jq are installed.
Do NOT write any text outside the script (the plan goes into it)!


EXAMPLE START

```sh
#!/bin/sh
# Goal: [Task description, max 7 words]
# Plan:
# 1. [...]

[Commands solving the task]
```

EXAMPLE END

",90
"You are AI Junior, you code like Donald Knuth.
# Working set

./src/frontend/components/GitStatusRow.jsx:
```
import getBackgroundColorForFile from './getBackgroundColorForFile';

const GitStatusRow = (props) => {
  const { index, path, working_dir } = props.entry;

  // Split the path to get filename and base directory
  const splitPath = path.split('/');
  const fileName = splitPath.pop();
  const baseDir = splitPath.join('/');

  const bgColor = getBackgroundColorForFile(index, path);
  return (
    <div class={`flex ${bgColor ? 'bg-' + bgColor : ''}`}>
      <span class=""w-50px overflow-x-auto"">{index + ' ' + working_dir}</span>
      <span class=""flex-grow w-60% overflow-x-auto"">{fileName}</span>
      <span class=""flex-shrink overflow-x-auto"">{baseDir}</span>
    </div>
  );
};

export default GitStatusRow;

```

./src/frontend/components/MultiSelect/ListItem.jsx:
```
import { createEffect } from ""solid-js"";
import useLongTap from ""./LongTapDetector"";

const ListItem = (props) => {
  let pathRef;
  const uniqueId = `item-${Math.random().toString(36).substr(2, 9)}`;
  const longTapActions = useLongTap(() => props.onLongTap(props.item));

  createEffect(() => {
    if (pathRef) {
      pathRef.scrollLeft = pathRef.scrollWidth;
    }
  });

  const handleClick = () => {
    if (typeof props.onItemClick === 'function') {
      props.onItemClick(props.item, uniqueId);
    }
  };

  const [filename, ...pathParts] = props.item.split('/').reverse();
  const directory = pathParts.reverse().join('/');

  return (
    <div id={uniqueId} onClick={handleClick} {...longTapActions} class=""flex justify-between items-center w-full font-mono cursor-pointer"">
      <span class=""text-base bg-main rounded p-1"">{filename}</span>
      <span ref={pathRef} class=""overflow-x-auto whitespace-no-wrap break-keep scrollbar-hidden ml-4 py-2 text-sm"">{directory}</span>
    </div>
  );
};

export default ListItem;

```


# Task

Implement the following feature!

- Create a plan!
- Create new files when needed!

Requirements:

In git status, set styles for filename and dir exactly as in ListItem. The first column should use what it needs and p-1. Do not create new files.


## Project Specifics

- Every js file should *only export a single function or signal, as default*! eg.: in createGitRepo.js: export default function createGitRepo ( ....
- Use *ES6 imports*!
- Prefer *async/await* over promises!
- The frontend uses *Solidjs* and Tailwind, edit .jsx files accordingly!

# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, avoid using sed in favor of heredoc-ing full files.

OS: OSX

Installed tools: npm, jq


Do NOT write any text outside the script!

EXAMPLE START
```sh
#!/bin/sh
set -e
goal=[Task description, max 9 words]
echo ""Plan:""
echo ""1. [...]""
cat > x.js << 'EOF'
[...]
'EOF'
echo ""\033[32mDone: $goal\033[0m\n""
```
EXAMPLE END

Before starting, check if you need more files or info to solve the task.

If the task is not clear:

EXAMPLE START
I need more information to solve the task. [Description of the missing info]
EXAMPLE END

Do not edit files not provided in the working set!
If you need more files:

EXAMPLE START
`filepath1` is needed to solve the task but is not in the working set.
EXAMPLE END


",85
"You are AI Junior, you code like Donald Knuth.
# Working set

./src/init.js:
```
#!/usr/bin/env node
import simpleGit from 'simple-git';
import { fileURLToPath } from 'url';
import { createPromptYaml } from './prompt/createPromptYaml.js';
import { createGitignore } from './git/createGitignore.js';
import { createPromptDir } from './prompt/createPromptDir.js';
import copyDefaults from './command/init/copyDefaults.js';
import path from 'path';

const git = simpleGit();

const __dirname = path.dirname(fileURLToPath(import.meta.url));

async function juniorInit() {
  const isRepo = await git.checkIsRepo();

  if (isRepo) {
    const status = await git.status();
    if (!status.isClean()) {
      console.error(""\x1b[31mDirectory is not clean. Please commit or stash changes and try again.\x1b[0m"");
      process.exit(1);
    }
  } else {
    await git.init();
  }

  createGitignore();
  await createPromptDir();
  createPromptYaml();

  const defaultsPath = path.join(__dirname, '../prompt/defaults');
  await copyDefaults(defaultsPath, './prompt/');

  await git.add('.');
  await git.commit(""Junior init"");

  console.log('\x1b[32mRepo initialized for Junior development\x1b[0m');
}

juniorInit();

```

./src/git/commitGit.js:
```
import { exec } from 'child_process';

export default function commitGit(message) {
  return new Promise((resolve, reject) => {
    exec(`git add . && git commit -m ""${message}""`, (err, stdout, stderr) => {
      if (err) {
        console.error(`exec error: ${err}`);
        reject(err);
        return;
      }
      console.log(`stdout: ${stdout}`);
      resolve(`Committed with message: ${message}`);
    });
  });
}

```


# Task

## Refactor by split

A file is too big. We need to split it into parts.
Identify the possible parts and refactor the code in separate files!

init.js should not use simple-git directly. We have  src/git/ dir, please create new files as needed and factor simple-git out.


## Project Specifics

- Every js file should *only export a single function or signal, as default*! eg.: in createGitRepo.js: export default function createGitRepo ( ....
- Use *ES6 imports*!
- Prefer *async/await* over promises!
- The frontend uses *Solidjs* and Tailwind, edit .jsx files accordingly!

# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, avoid using sed in favor of heredoc-ing full files.

OS: OSX

Installed tools: npm, jq


Do NOT write any text outside the script!

EXAMPLE START
```sh
#!/bin/sh
set -e
goal=[Task description, max 9 words]
echo ""Plan:""
echo ""1. [...]""
cat > x.js << 'EOF'
[...]
'EOF'
echo ""\033[32mDone: $goal\033[0m\n""
```
EXAMPLE END

Before starting, check if you need more files or info to solve the task.

If the task is not clear:

EXAMPLE START
I need more information to solve the task. [Description of the missing info]
EXAMPLE END

Do not edit files not provided in the working set!
If you need more files:

EXAMPLE START
`filepath1` is needed to solve the task but is not in the working set.
EXAMPLE END


",81
"# Working set

```
./
?????€??€ .DS_Store
?????€??€ .git/...
?????€??€ .gitignore
?????€??€ .vscode/...
?????€??€ README.md
?????€??€ babel.config.js
?????€??€ change.sh
?????€??€ dist/...
?????€??€ doc/...
?????€??€ node_modules/...
?????€??€ package-lock.json
?????€??€ package.json
?????€??€ prompt/...
?????€??€ prompt.md
?????€??€ prompt.yaml
?????€??€ secret.sh
?????€??€ src/...
?????€??€ tmp/...

```
src/backend/listTasks.js:
```
import fs from 'fs';
import path from 'path';

import { fileURLToPath } from 'url';
import { dirname } from 'path';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

function readDirRecursively(dir) {
    const files = [];

    fs.readdirSync(dir).forEach(file => {
        const filePath = path.join(dir, file);

        if (fs.statSync(filePath).isDirectory()) {
            files.push(...readDirRecursively(filePath));
        } else {
            files.push(filePath);
        }
    });

    return files;
}

export const listTasks = () => {
    const tasksDir = path.join(__dirname, '../../prompt/task');
    return readDirRecursively(tasksDir).map(file => path.relative(tasksDir, file));
};

```


# Task

## Refactor by split

A file is too big. We need to split it into parts.
Identify the possible parts and refactor the code in separate files!

Create backend/fileutils/readDirRecursively.js!



# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, prefer heredoc-ing full files without substitution.
Assume OSX.
npm and jq are installed.
Do NOT write any text outside the script (the plan goes into it)!


EXAMPLE START

```sh
#!/bin/sh
# Goal: [Task description, max 7 words]
# Plan:
# 1. [...]

[Commands solving the task]
```

EXAMPLE END

",75
"# Working set

```
./
?????€??€ .DS_Store
?????€??€ .git/...
?????€??€ .gitignore
?????€??€ .vscode/...
?????€??€ README.md
?????€??€ babel.config.js
?????€??€ change.sh
?????€??€ dist/...
?????€??€ doc/...
?????€??€ node_modules/...
?????€??€ package-lock.json
?????€??€ package.json
?????€??€ prompt/...
?????€??€ prompt.md
?????€??€ prompt.yaml
?????€??€ secret.sh
?????€??€ src/...
?????€??€ tmp/...

```
./package.json:
```
{
  ""name"": ""gpcontrib"",
  ""version"": ""0.0.1"",
  ""description"": ""Build large documents with AI"",
  ""type"": ""module"",
  ""main"": ""src/main.js"",
  ""bin"": {
    ""contrib"": ""src/main.js""
  },
  ""scripts"": {
    ""cli"": ""node src/main.js"",
    ""start"": ""node src/backend/server.js --prompt=prompt.yaml -s & vite src --open ""
  },
  ""keywords"": [
    ""cli"",
    ""uppercase""
  ],
  ""author"": """",
  ""license"": ""GPL"",
  ""dependencies"": {
    ""autoprefixer"": ""^10.4.14"",
    ""chatgpt"": ""^5.2.4"",
    ""clipboard-copy"": ""^4.0.1"",
    ""cors"": ""^2.8.5"",
    ""ejs"": ""^3.1.9"",
    ""express"": ""^4.18.2"",
    ""js-yaml"": ""^4.1.0"",
    ""marked"": ""^5.1.0"",
    ""postcss"": ""^8.4.24"",
    ""solid-js"": ""^1.7.7"",
    ""tailwindcss"": ""^3.3.2"",
    ""vite"": ""^4.3.9"",
    ""vite-plugin-solid"": ""^2.7.0""
  },
  ""directories"": {
    ""doc"": ""doc""
  },
  ""repository"": {
    ""type"": ""git"",
    ""url"": ""git+https://github.com/tisztamo/contributor.git""
  },
  ""bugs"": {
    ""url"": ""https://github.com/tisztamo/contributor/issues""
  },
  ""homepage"": ""https://github.com/tisztamo/contributor#readme"",
  ""devDependencies"": {
    ""babel-preset-solid"": ""^1.7.7""
  }
}

```

```
./src/
?????€??€ attention/...
?????€??€ backend/...
?????€??€ config.js
?????€??€ execute/...
?????€??€ frontend/...
?????€??€ index.html
?????€??€ interactiveSession/...
?????€??€ main.js
?????€??€ prompt/...
?????€??€ vite.config.js

```

# Task

Implement the following feature!

- Create a plan!
- Create new files when needed!
- Every js file should only export a single function!
- Use ES6 imports!

Requirements:

Rename the project to @aijunior/dev



# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, prefer heredoc-ing full files without substitution.
Assume OSX.
npm and jq are installed.
Do NOT write any text outside the script (the plan goes into it)!


EXAMPLE START

```sh
#!/bin/sh
# Goal: [Task description, max 7 words]
# Plan:
# 1. [...]

[Commands solving the task]
```

EXAMPLE END

",73
"# Working set

```
./
?????€??€ .DS_Store
?????€??€ .git/...
?????€??€ .gitignore
?????€??€ .vscode/...
?????€??€ README.md
?????€??€ babel.config.js
?????€??€ change.sh
?????€??€ dist/...
?????€??€ doc/...
?????€??€ node_modules/...
?????€??€ package-lock.json
?????€??€ package.json
?????€??€ prompt/...
?????€??€ prompt.md
?????€??€ prompt.yaml
?????€??€ secret.sh
?????€??€ src/...
?????€??€ tmp/...

```
./README.md:
```
Warn: This README is AI generated, just like all the source files of this project.

# The Contributor - Your AI contributor which writes itself.

## Description

The Contributor is an exploratory project aimed at revolutionizing the way programmers interact with the development process. Much like how Linus Thorwalds, the creator of the Linux Kernel, supervises its development without having to write code himself, this project allows developers to solely communicate with the AI and supervise the development process.

By detailing the specifics of a task in a prompt descriptor and highlighting the relevant parts of your project, you can delegate the implementation of code, documentation, tests, and more to your AI Contributor.

## Getting Started

### The Prompt Descriptor

A prompt descriptor is a YAML file (`prompt.yaml`) that outlines the necessary details for generating a task prompt for the AI model.

Here is an example of a prompt descriptor:

```yaml
task: prompt/task/feature/implement.md
attention:
  - src/interactiveSession/startInteractiveSession.js
  - src/prompt/createPrompt.js
  - src/attention/readAttention.js
  - prompt.yaml
requirements: >
  Write a README.md for this _exploratory_ project!
format: prompt/format/new_file_version.md
```

Each element in the descriptor serves a specific purpose:
- `task`: Describes the task type and scope. For example, you can check out the [prompt/task/implement.md](prompt/task/implement.md) file as an example.
- `attention`: Lists the files and directories that are most relevant to the task.
- `requirements`: Describes the actual task in a human-readable format.
- `format`: Determines how the output will be formatted. You can refer to the [prompt/format/new_file_version.md](prompt/format/new_file_version.md) file for an example.

### Attention Mechanism

The attention mechanism is an important part of this project. It guides the AI model by providing it with a working set, which helps overcome the limited working memory of large language models.

This working set is a subset of the entire project that's currently in focus. It includes both files and directories.

For files, the content is directly provided to the AI. For directories, a brief list of files and subdirectories within them is presented. Directories are denoted with a trailing `/`.

## Contributing and Support

Contributions are welcome! However, please keep in mind that this project is designed to write itself. Your main role will be to oversee the work, provide detailed prompts, and review the outcomes.

For support, please create an issue in the GitHub repository and the community will help you out.


```


# Task

Improve the documentation!

Add the following new info to the readme: There is a cli and a web interface. How to install How to run: &#34;npm start&#34; starts a local server on port 3000, where you can generate a prompt and auto-copy it to paste to chatgpt. How to use. What are tasks like &#34;feature/implement&#34; and &#34;bug/fix&#34;, &#34;refactor/&#34;. The cli uses the chatgpt api, so need an api key in OPENAI_API_KEY env var You need gpt-4 or a better model to get meaningful results (A note at the end).
Be concise!


# Output Format

Provide the new or modified file(s) as code blocks, each prefixed with its path and a colon.
JS files should only export a single function and be named after the function: e.g. `myFn.js` should export `myFn()`.
Always output full files, copying unchanged content.

E.g.:

texts/sample.txt:
```
A sample text file.
```


",77
"You are AI Junior, you code like Donald Knuth.
# Working set

src/frontend/components/MultiSelect/MultiSelectHeader.jsx:
```
const MultiSelectHeader = (props) => {
  return (
    <div class=""w-full p-2 bg-lightgray"">
      { props.items().length > 0 ? `${props.items().length} files in attention` : props.emptyMessage }
    </div>
  );
};

export default MultiSelectHeader;

```

src/frontend/components/MultiSelect/MultiSelect.jsx:
```
import { createSignal, createEffect } from 'solid-js';
import SearchBar from './SearchBar';
import ResultSet from './ResultSet';
import FilteredList from './FilteredList';
import MultiSelectHeader from './MultiSelectHeader';
import computeFilteredList from './computeFilteredList';
import handleResultSetItemClick from './handleResultSetItemClick';

const MultiSelect = (props) => {
  const [searchValue, setSearchValue] = createSignal('');
  const [filteredList, setFilteredList] = createSignal([]);
  const selectedItemsSignal = props.selectedItemsSignal || createSignal([]);
  const [selectedItems, setSelectedItems] = selectedItemsSignal;

  createEffect(() => {
    const currentQuery = searchValue() || props.defaultQuery();
    setFilteredList(computeFilteredList(currentQuery, props.availableItems, props.compare, props.itemCount, selectedItems(), props.defaultQuery()));
  });

  const handleKeyPress = (e) => {
    if (e.key === 'Enter') {
      const updatedItems = [filteredList()[0], ...selectedItems()];
      setSelectedItems(updatedItems);
    }
  };

  const handleFilterListItemClick = (item) => {
    const updatedItems = [item, ...selectedItems()];
    setSelectedItems(updatedItems);
  };

  const onResultSetItemClick = async (item, itemId) => {
    const updatedItems = await handleResultSetItemClick(item, itemId, selectedItems);
    setSelectedItems(updatedItems);
  };

  return (
    <div class=""w-full bg-emphasize text-emphasize p-2 rounded border border-border"">
      <MultiSelectHeader items={selectedItems} emptyMessage=""Attention is empty."" />
      <ResultSet items={selectedItems()} onItemClick={onResultSetItemClick} />
      <SearchBar searchValue={searchValue} setSearchValue={setSearchValue} onKeyPress={handleKeyPress} />
      <FilteredList items={filteredList()} onItemClick={handleFilterListItemClick} />
    </div>
  );
};

export default MultiSelect;

```


# Task

Implement the following feature!

- Create a plan!
- Create new files when needed!

Requirements:

Allow closing the multiselect using html details tag!
When closed, only the header should be visible.



## Project Specifics

- Every js file should *only export a single function or signal*!
- Use *ES6 imports*!
- Prefer *async/await* over promises!
- The frontend uses *Solidjs* and Tailwind, edit .jsx files accordingly!

# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, avoid using sed in favor of heredoc-ing full files.

OS: OSX

Installed tools: npm, jq


Do NOT write any text outside the script!

EXAMPLE START

```sh
#!/bin/sh
set -e
goal=[Task description, max 9 words]
echo ""Plan:""
echo ""1. [...]""
cat > x.js << 'EOF'
[...]
'EOF'
echo ""\033[32mDone: $goal\033[0m\n""
```

EXAMPLE END

Before starting, check if you need more files to solve the task.
Do not edit any file not provided in the working set!
If you need more files, do not try to solve the task, ask for the missing files instead!

EXAMPLE START

`filepath1` is needed to solve the task but is not in the working set.

EXAMPLE END

",62
"# Working set

```
./
?????€??€ .DS_Store
?????€??€ .git/...
?????€??€ .gitignore
?????€??€ .vscode/...
?????€??€ README.md
?????€??€ babel.config.js
?????€??€ change.sh
?????€??€ dist/...
?????€??€ doc/...
?????€??€ node_modules/...
?????€??€ package-lock.json
?????€??€ package.json
?????€??€ prompt/...
?????€??€ prompt.md
?????€??€ prompt.yaml
?????€??€ secret.sh
?????€??€ src/...
?????€??€ tmp/...

```
./README.md:
```
# The Contributor - Your AI contributor which writes itself.

## Description

The goal of this exploratory project is to allow programmers to communicate solely with the AI and merely supervise the development process. This is much like how Linus Thorwalds, the creator of Linux Kernel, supervises its development without having to write code himself.

## Getting Started

### The Prompt Descriptor

A prompt descriptor (prompt.yaml) provides details necessary to generate a prompt for the AI model.

For instance, here is an example of a prompt descriptor:

```yaml
task: prompt/task/feature/implement.md
attention:
  - src/interactiveSession/startInteractiveSession.js
  - src/prompt/createPrompt.js
  - src/attention/readAttention.js
  - prompt.yaml
requirements: >
  Write a README.md for this _exploratory_ project!
format: prompt/format/new_file_version.md
```

### Attention Mechanism

The attention mechanism provides the AI model with a working set, a subset of the entire project that's currently in focus. It includes both files and directories.

For files, the content is directly provided to the AI. For directories, a list of files and subdirectories within them is presented. Directories are denoted with a trailing `/`.

## Contributing and Support

Contributions are welcome, but remember, this project writes itself!

```


# Task

Improve the documentation!

Include the provided new information (if any).

# Output Format

Provide the new or modified file(s) as code blocks, each prefixed with its path and a colon.
JS files should only export a single function and be named after the function: e.g. `myFn.js` should export `myFn()`.
Always output full files, copying unchanged content.

E.g.:

texts/sample.txt:
```
A sample text file.
```


",85
"You are AI Junior, you code like Donald Knuth.
# Working set

src/frontend/components/MultiSelect/ResultSet.jsx:
```
import ListItem from ""./ListItem"";

const ResultSet = (props) => {
  return (
    <div>
      {props.items.length === 0 ? (
        <div class=""text-gray-400 pl-2"">{props.emptyMessage}</div>
      ) : (
        <ul class=""list-inside"">
          {props.items.map(item => <ListItem key={item} item={item} onItemClick={props.onItemClick} />)}
        </ul>
      )}
    </div>
  );
};

export default ResultSet;

```

src/frontend/components/MultiSelect/ListItem.jsx:
```
import { createEffect } from ""solid-js"";

const ListItem = (props) => {
  let pathRef;

  createEffect(() => {
    if (pathRef) {
      pathRef.scrollLeft = pathRef.scrollWidth;
    }
  });

  const handleClick = () => {
    if (typeof props.onItemClick === 'function') {
      props.onItemClick(props.item);
    }
  };

  // Split the path into filename and directory
  const [filename, ...pathParts] = props.item.split('/').reverse();
  const directory = pathParts.reverse().join('/');

  return (
    <div onClick={handleClick} class={`flex justify-between items-center w-full font-mono cursor-pointer item-${props.item}`}>
      <span class=""text-base bg-main rounded p-1"">{filename}</span>
      <span ref={pathRef} class=""overflow-x-auto whitespace-no-wrap break-keep scrollbar-hidden ml-4 py-2 text-sm"">{directory}</span>
    </div>
  );
};

export default ListItem;

```

src/frontend/styles/styles.css:
```
@import 'tailwindcss/base';
@import 'tailwindcss/components';
@import 'tailwindcss/utilities';
@import './colors.css';
@import './markdown.css';

```

src/frontend/components/MultiSelect/MultiSelect.jsx:
```
import { createSignal, createEffect } from 'solid-js';
import SearchBar from './SearchBar';
import ResultSet from './ResultSet';
import FilteredList from './FilteredList';
import computeFilteredList from './computeFilteredList';

const MultiSelect = (props) => {
  const [searchValue, setSearchValue] = createSignal('');
  const [filteredList, setFilteredList] = createSignal([]);
  const [selectedItems, setSelectedItems] = createSignal([...props.selectedItems]);

  createEffect(() => {
    const currentQuery = searchValue() || props.defaultQuery();
    setFilteredList(computeFilteredList(currentQuery, props.availableItems, props.compare, props.itemCount, selectedItems(), props.defaultQuery()));
  });

  const handleKeyPress = (e) => {
    if (e.key === 'Enter') {
      const updatedItems = [filteredList()[0], ...selectedItems()];
      setSelectedItems(updatedItems);
    }
  };

  const handleFilterListItemClick = (item) => {
    const updatedItems = [item, ...selectedItems()];
    setSelectedItems(updatedItems);
  };

  const handleResultSetItemClick = (item) => {
    const updatedItems = selectedItems().filter(selectedItem => selectedItem !== item);
    setSelectedItems(updatedItems);
  };

  return (
    <div class=""w-full bg-emphasize text-emphasize p-2 rounded border border-border"">
      <ResultSet items={selectedItems()} onItemClick={handleResultSetItemClick} emptyMessage=""Attention is empty."" />
      <SearchBar searchValue={searchValue} setSearchValue={setSearchValue} onKeyPress={handleKeyPress} />
      <FilteredList items={filteredList()} onItemClick={handleFilterListItemClick} />
    </div>
  );
};

export default MultiSelect;

```


# Task

Implement the following feature!

- Create a plan!
- Create new files when needed!

Requirements:

1. In ListItem, do not add the class item-${props.item}, generate a unique id attribute instead
2. Pass the id to the click handler as the second argument
3. In MultiSelect, slide-fade the div based on the id before unselecting


## Project Specifics

- Every js file should *only export a single function or signal*!
- Use *ES6 imports*!
- Prefer *async/await* over promises!
- The frontend uses *Solidjs* and Tailwind, edit .jsx files accordingly!

# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, avoid using sed in favor of heredoc-ing full files using 'EOF' to prevent substitution.

OS: OSX

Installed tools: npm, jq


Do NOT write any text outside the script!

EXAMPLE START

```sh
#!/bin/sh
set -e
goal=[Task description, max 7 words]
echo ""Plan:""
echo ""1. [...]""
[Commands solving the task]
echo ""\033[32mDone: $goal\033[0m\n""
```

EXAMPLE END

Before starting, check if you need more files to solve the task.
Do not edit any file not provided in the working set!
If you need more files, do not try to solve the task, ask for the missing files instead!

EXAMPLE START

`filepath1` is needed to solve the task but is not in the working set.

EXAMPLE END

",40
"You're the 'Contributor', an AI system aiding authors.

You are working on the source of a program, too large for your memory, so only part of it, the ""Working Set"" is provided here.

You will see a partial directory structure. Ask for the contents of subdirs marked with /... if needed.

Some files are printed in the working set.

Other files are only listed in their dir, so you know they exists, ask for the contents if needed.

# Working set

```
./
?????€??€ .DS_Store
?????€??€ .git/...
?????€??€ .gitignore
?????€??€ .vscode/...
?????€??€ README.md
?????€??€ babel.config.js
?????€??€ change.sh
?????€??€ dist/...
?????€??€ doc/...
?????€??€ node_modules/...
?????€??€ package-lock.json
?????€??€ package.json
?????€??€ prompt/...
?????€??€ prompt.md
?????€??€ prompt.yaml
?????€??€ secret.sh
?????€??€ src/...
?????€??€ tmp/...

```
src/interactiveSession/startInteractiveSession.js:
```
import processPrompt from '../prompt/promptProcessing.js';
import { saveAndSendPrompt } from './saveAndSendPrompt.js';

const startInteractiveSession = async (last_command_result = """", parent_message_id = null, rl, api) => {
  rl.question('$ ', async (task) => {
    const { prompt, parent_message_id: newParentMessageId } = await processPrompt(task, last_command_result);
    await saveAndSendPrompt(prompt, newParentMessageId, api, rl, last_command_result, startInteractiveSession);
  });
};

export { startInteractiveSession };

```

src/interactiveSession/handleApiResponse.js:
```
import { executeCode } from '../execute/executeCode.js';
import { extractCode } from '../execute/extractCode.js';
import { startInteractiveSession } from './startInteractiveSession.js';

const handleApiResponse = (msg, last_command_result, parent_message_id, rl, api) => {
  const cod = extractCode(msg);
  if (cod) {
    executeCode(cod, last_command_result, parent_message_id, rl, api);
  } else {
    last_command_result = """";
    startInteractiveSession(last_command_result, parent_message_id, rl, api);
  }
}

export { handleApiResponse };

```

src/execute/extractCode.js:
```

function extractCode(res) {
  const match = res.match(/```sh([\s\S]*?)```/);
  return match ? match[1].trim() : null;
}

export { extractCode };

```

src/execute/executeCode.js:
```
#!/usr/bin/env node

import { startInteractiveSession } from ""../interactiveSession/startInteractiveSession.js"";

const executeCode = async (cod, last_command_result, parent_message_id, rl) => {
  rl.question('\x1b[1mEXECUTE? [y/n]\x1b[0m ', async (answer) => {
    console.log("""");
    if (answer.toLowerCase() === 'y' || answer === """") {
      process.exec(cod, (error, stdout, stderr) => {
        if (error) {
          console.error(`${error.message}`);
          last_command_result = ""Command failed. Output:\n"" + error.message + ""\n"";
        } else {
          if (stdout.length > 0) {
            console.log(`${stdout}`);
          }
          if (stderr.length > 0) {
            console.log(`${stderr}`);
          }
          last_command_result = ""Command executed. Output:\n"" + stdout + ""\n"" + stderr + ""\n"";
        }
        startInteractiveSession(last_command_result, parent_message_id, rl)
      });
    } else {
      last_command_result = ""Command skipped.\n"";
      startInteractiveSession(last_command_result, parent_message_id, rl);
    }
  });
}

export { executeCode };

```


# Task

Implement the following feature!

- Write a plan first, only implement after the plan is ready!
- Create new files when needed!
- Every js js file should only export a single function!

Requirements:

scripts from bash code blocks should also be extracted and executed.



# Output Format

./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files should be heredoc.
Assume OSX. npm and jq are installed.

",41
"You're the 'Contributor', an AI system aiding authors.

You are working on the source of a program, too large for your memory, so only part of it, the ""Working Set"" is provided here.

You will see a partial directory structure. Ask for the contents of subdirs marked with /... if needed.

Some files are printed in the working set.

Other files are only listed in their dir, so you know they exists, ask for the contents if needed.

# Working set

```
./
?????€??€ .DS_Store
?????€??€ .git/...
?????€??€ .gitignore
?????€??€ .vscode/...
?????€??€ README.md
?????€??€ babel.config.js
?????€??€ change.sh
?????€??€ dist/...
?????€??€ doc/...
?????€??€ node_modules/...
?????€??€ package-lock.json
?????€??€ package.json
?????€??€ prompt/...
?????€??€ prompt.md
?????€??€ prompt.yaml
?????€??€ secret.sh
?????€??€ src/...
?????€??€ tmp/...

```
```
src/
?????€??€ attention/...
?????€??€ backend/...
?????€??€ config.js
?????€??€ execute/...
?????€??€ frontend/...
?????€??€ index.html
?????€??€ interactiveSession/...
?????€??€ main.js
?????€??€ prompt/...
?????€??€ utils/...
?????€??€ vite.config.js

```
src/frontend/components/TasksList.jsx:
```
import { createSignal, onCleanup, onMount } from 'solid-js';
import { fetchTasks } from '../fetchTasks';
import { handleTaskChange } from '../service/handleTaskChange';
import { fetchDescriptor } from '../service/fetchDescriptor';
import YAML from 'yaml';

const TasksList = () => {
  const tasks = fetchTasks();
  const [promptDescriptor, setPromptDescriptor] = createSignal('');
  const [selectedTask, setSelectedTask] = createSignal('');

  const parseYamlAndGetTask = (yamlString) => {
    const doc = YAML.parse(yamlString);
    return doc.task;
  };

  onMount(async () => {
    const text = await fetchDescriptor();
    const task = parseYamlAndGetTask(text);
    setPromptDescriptor(text);
    setSelectedTask(task);
  });

  onCleanup(() => {
    setPromptDescriptor('');
  });

  return (
    <div>
      <label>Task:</label>
      <select value={selectedTask()} onChange={e => handleTaskChange(e, setPromptDescriptor)}>
        {tasks().map(task => <option value={task}>{task}</option>)}
      </select>
      <pre>{promptDescriptor()}</pre>
    </div>
  );
};

export default TasksList;

```


# Task

Fix the following issue!

TaskList fails to set the initial value, because the parsed value is prefixed with &#34;prompt/task/&#34;. Remove this prefix!


# Output Format

./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files should be heredoc.
Assume OSX. npm and jq are installed.

",70
"You're the 'Contributor', an AI system aiding authors.

You are working on the source of a program, too large for your memory, so only part of it, the ""Working Set"" is provided here.

You will see a partial directory structure. Ask for the contents of subdirs marked with /... if needed.

Some files are printed in the working set.

Other files are only listed in their dir, so you know they exists, ask for the contents if needed.

# Working set

```
./
?????€??€ .DS_Store
?????€??€ .git/...
?????€??€ .gitignore
?????€??€ .vscode/...
?????€??€ README.md
?????€??€ babel.config.js
?????€??€ change.sh
?????€??€ dist/...
?????€??€ doc/...
?????€??€ node_modules/...
?????€??€ package-lock.json
?????€??€ package.json
?????€??€ prompt/...
?????€??€ prompt.md
?????€??€ prompt.yaml
?????€??€ secret.sh
?????€??€ src/...
?????€??€ tmp/...

```
```
src/
?????€??€ attention/...
?????€??€ backend/...
?????€??€ config.js
?????€??€ execute/...
?????€??€ frontend/...
?????€??€ index.html
?????€??€ interactiveSession/...
?????€??€ main.js
?????€??€ prompt/...
?????€??€ utils/...
?????€??€ vite.config.js

```
src/frontend/components/PromptDescriptorViewer.jsx:
```
import { createSignal, onMount } from 'solid-js';
import { fetchDescriptor } from '../service/fetchDescriptor';

const PromptDescriptorViewer = () => {
  const [descriptorContent, setDescriptorContent] = createSignal('');

  onMount(async () => {
    const text = await fetchDescriptor();
    setDescriptorContent(text);
  });

  return (
    <pre>{descriptorContent()}</pre>
  );
};

export default PromptDescriptorViewer;

```

src/frontend/components/TasksList.jsx:
```
import { createSignal, onCleanup, onMount } from 'solid-js';
import { fetchTasks } from '../fetchTasks';
import { handleTaskChange } from '../service/handleTaskChange';
import { fetchDescriptor } from '../service/fetchDescriptor';

const TasksList = () => {
  const tasks = fetchTasks();
  const [promptDescriptor, setPromptDescriptor] = createSignal('');

  onMount(async () => {
    const text = await fetchDescriptor();
    setPromptDescriptor(text);
  });

  onCleanup(() => {
    setPromptDescriptor('');
  });

  return (
    <div>
      <label>Tasks:</label>
      <select onChange={e => handleTaskChange(e, setPromptDescriptor)}>
        {tasks().map(task => <option value={task}>{task}</option>)}
      </select>
      <pre>{promptDescriptor()}</pre>
    </div>
  );
};

export default TasksList;

```

src/frontend/service/fetchDescriptor.js:
```
export const fetchDescriptor = async () => {
  const response = await fetch('http://localhost:3000/descriptor');
  const text = await response.text();
  return text;
};

```


# Task

Implement the following feature!

- Write a plan first, only implement after the plan is ready!
- Create new files when needed!
- Every js js file should only export a single function!

Requirements:

- After page open the task selector should show the task that is currently
  selected. It can be read out from the prompt descriptor, which is a yaml with a task attrobute.
- And the label should be &#34;Task:&#34;.



# Output Format

./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files should be heredoc.
Assume OSX. npm and jq are installed.

",94
"You're the 'Contributor', an AI system aiding authors.

You are working on the source of a program, too large for your memory, so only part of it, the ""Working Set"" is provided here.

You will see a partial directory structure. Ask for the contents of subdirs marked with /... if needed.

Some files are printed in the working set.

Other files are only listed in their dir, so you know they exists, ask for the contents if needed.

# Working set

```
./
?????€??€ .DS_Store
?????€??€ .git/...
?????€??€ .gitignore
?????€??€ .vscode/...
?????€??€ README.md
?????€??€ babel.config.js
?????€??€ change.sh
?????€??€ dist/...
?????€??€ doc/...
?????€??€ node_modules/...
?????€??€ package-lock.json
?????€??€ package.json
?????€??€ prompt/...
?????€??€ prompt.md
?????€??€ prompt.yaml
?????€??€ secret.sh
?????€??€ src/...
?????€??€ tmp/...

```
```
src/
?????€??€ attention/...
?????€??€ config.js
?????€??€ execute/...
?????€??€ frontend/...
?????€??€ index.html
?????€??€ interactiveSession/...
?????€??€ main.js
?????€??€ prompt/...
?????€??€ servePromptDescriptor.js
?????€??€ server.js
?????€??€ utils/...
?????€??€ vite.config.js

```
package.json:
```
{
  ""name"": ""gpcontrib"",
  ""version"": ""0.0.1"",
  ""description"": ""Build large documents with AI"",
  ""type"": ""module"",
  ""main"": ""src/main.js"",
  ""bin"": {
    ""contrib"": ""src/main.js""
  },
  ""scripts"": {
    ""cli"": ""node src/main.js"",
    ""start"": ""node src/server.js --prompt=prompt.yaml -s & vite src --open ""
  },
  ""keywords"": [
    ""cli"",
    ""uppercase""
  ],
  ""author"": """",
  ""license"": ""GPL"",
  ""dependencies"": {
    ""autoprefixer"": ""^10.4.14"",
    ""chatgpt"": ""^5.2.4"",
    ""clipboard-copy"": ""^4.0.1"",
    ""cors"": ""^2.8.5"",
    ""ejs"": ""^3.1.9"",
    ""express"": ""^4.18.2"",
    ""js-yaml"": ""^4.1.0"",
    ""marked"": ""^5.1.0"",
    ""postcss"": ""^8.4.24"",
    ""solid-js"": ""^1.7.7"",
    ""tailwindcss"": ""^3.3.2"",
    ""vite"": ""^4.3.9"",
    ""vite-plugin-solid"": ""^2.7.0""
  },
  ""directories"": {
    ""doc"": ""doc""
  },
  ""repository"": {
    ""type"": ""git"",
    ""url"": ""git+https://github.com/tisztamo/contributor.git""
  },
  ""bugs"": {
    ""url"": ""https://github.com/tisztamo/contributor/issues""
  },
  ""homepage"": ""https://github.com/tisztamo/contributor#readme"",
  ""devDependencies"": {
    ""babel-preset-solid"": ""^1.7.7""
  }
}

```

src/server.js:
```
import express from 'express';
import cors from 'cors';
import processPrompt from './prompt/promptProcessing.js';
import { servePromptDescriptor } from './servePromptDescriptor.js';

const app = express();

app.use(cors());
app.use(express.json());

app.get('/descriptor', servePromptDescriptor);

app.post('/generate', async (req, res) => {
  const { notes } = req.body;
  const { prompt } = await processPrompt(notes);
  res.json({ prompt: prompt });
});

app.listen(3000, () => {
  console.log('Server is running on port 3000');
});

```

src/servePromptDescriptor.js:
```
import { readFile } from 'fs/promises';
import path from 'path';

import { fileURLToPath } from 'url';
import { dirname } from 'path';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

export const servePromptDescriptor = async (req, res) => {
  const file = await readFile(path.resolve(__dirname, '../prompt.yaml'), 'utf-8');
  res.send(file);
};

```


# Task

## Refactor by split

A file is too big. We need to split it into parts.
Identify the possible parts and refactor the code in separate files!

The backend needs its own directory. Move server.js to it and split it into two. Also move servePromptDescriptor.js.



# Output Format

./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files should be heredoc.
Assume OSX. npm and jq are installed.

",90
"You're the 'Contributor', an AI system aiding authors.

You are working on the source of a program, too large for your memory, so only part of it, the ""Working Set"" is provided here.

You will see a partial directory structure. Ask for the contents of subdirs marked with /... if needed.

Some files are printed in the working set.

Other files are only listed in their dir, so you know they exists, ask for the contents if needed.

# Working set

```
./
?????€??€ .DS_Store
?????€??€ .git/...
?????€??€ .gitignore
?????€??€ .vscode/...
?????€??€ README.md
?????€??€ babel.config.js
?????€??€ current_prompt.md
?????€??€ current_prompt.yaml
?????€??€ dist/...
?????€??€ doc/...
?????€??€ frontend
?????€??€ node_modules/...
?????€??€ operation.sh
?????€??€ package-lock.json
?????€??€ package.json
?????€??€ prompt/...
?????€??€ secret.sh
?????€??€ src/...
?????€??€ tmp/...

```
src/prompt/createPrompt.js:
```
import { readAttention } from ""../attention/readAttention.js""
import util from 'util';
import fs from 'fs';
import yaml from 'js-yaml';
import ejs from 'ejs';
import { getPromptFlag } from './getPromptFlag.js';
import { getSystemPromptIfNeeded } from './getSystemPromptIfNeeded.js';
import { resolveTemplateVariables } from './resolveTemplateVariables.js';
import { extractTemplateVars } from './extractTemplateVars.js';
const readFile = util.promisify(fs.readFile);

const createPrompt = async (userInput) => {
  const promptDescriptor = yaml.load(await readFile(getPromptFlag() || ""current_prompt.yaml"", ""utf8""));
  let templateVars = extractTemplateVars(promptDescriptor);

  templateVars = await resolveTemplateVariables(templateVars);

  const attention = await readAttention(promptDescriptor.attention);
  const task = await ejs.renderFile(promptDescriptor.task, templateVars, {async: true});
  const format = await ejs.renderFile(promptDescriptor.format, templateVars, {async: true});
  const system = await getSystemPromptIfNeeded();
  const saveto = promptDescriptor.saveto;
  return {
    prompt: `${system}# Working set\n\n${attention.join(""\n"")}\n\n# Task\n\n${task}\n\n# Output Format\n\n${format}\n\n${userInput ? userInput : """"}`,
    saveto
  };
}

export { createPrompt };

```

src/prompt/promptProcessing.js:
```
import { createPrompt } from './createPrompt.js';
import fs from 'fs/promises';

const processPrompt = async (task, last_command_result, saveto = 'current_prompt.md', parent_message_id = null) => {
  const { prompt, saveto: newSaveto } = await createPrompt(task, last_command_result);
  await fs.writeFile(newSaveto || saveto, prompt);
  return { prompt, parent_message_id };
}

export default processPrompt;

```


# Task

Rename the following files

You need to follow dependencies to maintain coherence.

Before executing, write a concise plan! The plan should show:
 - How do you avoid breaking other parts of the code.
 - If you had to choose, your way of thinking.

current_prompt.yaml to prompt.yaml and current_prompt.md to prompt.md.


# Output Format

A single shell script that creates everything.

Assume Ubuntu. npm, nix, docker and jq are installed.

",70
"src/server.js:

import express from 'express';
import cors from 'cors';
import processPrompt from './prompt/promptProcessing.js';
import { marked } from 'marked';

const app = express();

app.use(cors());
app.use(express.json());

app.post('/generate', async (req, res) => {
  const { notes } = req.body;
  const { prompt } = await processPrompt(notes);
  const htmlPrompt = marked(prompt);  // Convert markdown to HTML
  res.json({ prompt: htmlPrompt });
});

app.listen(3000, () => {
  console.log('Server is running on port 3000');
});
src/frontend.jsx:

import { createSignal } from 'solid-js';
import { render } from 'solid-js/web';

const App = () => {
  const [notes, setNotes] = createSignal('');
  const [prompt, setPrompt] = createSignal('');

  const generatePrompt = async () => {
    const response = await fetch('http://localhost:3000/generate', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ notes: notes() })
    });

    const data = await response.json();
    setPrompt(data.prompt);
  };

  return (
    <>
      <input type=""text"" value={notes()} onInput={e => setNotes(e.target.value)} />
      <button onClick={generatePrompt}>Start</button>
      <div innerHTML={prompt()}></div>
    </>
  );
};

render(App, document.getElementById('app'));
Task
Implement the following feature!

Write a plan first, only implement after the plan is ready!
Create new files when needed!
Every js js file should only export a single function!
Requirements:

When the prompt arrives to the frontend, copy it to the clipboard.

Output Format
A single shell script that creates everything is the preferred output

do not create new files for trivial functions",88
"You are AI Junior, you code like Donald Knuth.
# Working set

src/frontend/components/MultiSelect/MultiSelect.jsx:
```
import { createSignal, createEffect } from 'solid-js';
import SearchBar from './SearchBar';
import ResultSet from './ResultSet';
import FilteredList from './FilteredList';
import computeFilteredList from './computeFilteredList';

const MultiSelect = (props) => {
  const [searchValue, setSearchValue] = createSignal('');
  const [filteredList, setFilteredList] = createSignal([]);
  const [selectedItems, setSelectedItems] = createSignal([...props.selectedItems]);

  createEffect(() => {
    const currentQuery = searchValue() || props.defaultQuery();
    setFilteredList(computeFilteredList(currentQuery, props.availableItems, props.compare, props.itemCount, selectedItems()));
  });

  const handleKeyPress = (e) => {
    if (e.key === 'Enter') {
      const updatedItems = [filteredList()[0], ...selectedItems()];
      setSelectedItems(updatedItems);
    }
  };

  const handleItemClick = (item) => {
    const updatedItems = [item, ...selectedItems()];
    setSelectedItems(updatedItems);
  };

  return (
    <div class=""w-full bg-emphasize text-emphasize p-2 rounded border border-border"">
      <ResultSet items={selectedItems()} />
      <SearchBar searchValue={searchValue} setSearchValue={setSearchValue} onKeyPress={handleKeyPress} />
      <FilteredList items={filteredList()} onItemClick={handleItemClick} />
    </div>
  );
};

export default MultiSelect;

```

src/frontend/components/MultiSelect/SearchBar.jsx:
```
const SearchBar = (props) => {
  const handleInputChange = (e) => {
    props.setSearchValue(e.target.value);
  };

  return (
    <input 
      type=""text""
      placeholder=""Suggestions below. Search here!""
      value={props.searchValue()}
      onInput={handleInputChange}
      onKeyPress={props.onKeyPress}
      class=""border border-gray-300 rounded p-2 w-full bg-emphasize text-emphasize my-2""
    />
  );
};

export default SearchBar;

```

src/frontend/components/MultiSelect/computeFilteredList.js:
```
export default function computeFilteredList(searchValue, items, compare, itemCount, selectedItems = []) {
  const comparisonFunction = compare || ((item, filter) => item.includes(filter) ? filter.length : 0);
  return items
    .filter(item => !selectedItems.includes(item) && comparisonFunction(item, searchValue) > 0)
    .sort((a, b) => comparisonFunction(b, searchValue) - comparisonFunction(a, searchValue))
    .slice(0, itemCount);
}

```


# Task

Implement the following feature!

- Create a plan!
- Create new files when needed!

Requirements:

Calculate the rank for the default query and add it to the searchvalue based rank when sorting.


## Project Specifics

- Every js file should *only export a single function or signal*!
- Use *ES6 imports*!
- Prefer *async/await* over promises!
- The frontend uses *Solidjs* and Tailwind, edit .jsx files accordingly!

# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, avoid using sed in favor of heredoc-ing full files using 'EOF' to prevent substitution.

OS: OSX

Installed tools: npm, jq


Do NOT write any text outside the script!

EXAMPLE START

```sh
#!/bin/sh
set -e
goal=[Task description, max 7 words]
echo ""Plan:""
echo ""1. [...]""
[Commands solving the task]
echo ""\033[32mDone: $goal\033[0m\n""
```

EXAMPLE END

Before starting, check if you need more files to solve the task.
Do not edit any file not provided in the working set!
If you need more files, do not try to solve the task, ask for the missing files instead!

EXAMPLE START

`filepath1` is needed to solve the task but is not in the working set.

EXAMPLE END

",95
"You are AI Junior, you code like Donald Knuth.
# Working set

src/frontend/components/NavBar.jsx:
```
import ThemeSwitcher from './ThemeSwitcher';
import SubTitle from './SubTitle';

const NavBar = () => {
  const title = 'Junior';

  return (
    <div class=""relative w-full"">
      <div class=""absolute top-0 right-0 m-4"">
        <ThemeSwitcher />
      </div>
      <div class=""flex flex-col items-center justify-center"">
        <a href=""https://github.com/tisztamo/Junior"" class=""text-center text-3xl mt-6 no-underline"">{title}</a>
        <SubTitle />
      </div>
    </div>
  );
};

export default NavBar;

```


# Task

Implement the following feature!

- Create a plan!
- Create new files when needed!

Requirements:

Create a new component <RepoInfo> which displays
""@aijunior/dev main"" with small mono font and emphasized
background with some paddig, rounded, no border.
Add it at as a new line of NavBar



## Project Specifics

- Every js file should *only export a single function*!
- Use *ES6 imports*!
- Prefer *async/await* over promises!
- The frontend uses *Solidjs* and Tailwind, edit .jsx file accordingly!


# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, avoid using sed in favor of heredoc-ing full files using 'EOF' to prevent substitution.

OS: OSX

Installed tools: npm, jq


Do NOT write any text outside the script!

EXAMPLE START

```sh
#!/bin/sh
set -e
goal=[Task description, max 7 words]
echo ""Plan:""
echo ""1. [...]""
[Commands solving the task]
echo ""\033[32mDone: $goal\033[0m\n""
```

EXAMPLE END

Before starting, check if you need more files to solve the task.
Do not edit any file not provided in the working set!
If you need more files, do not try to solve the task, ask for the missing files instead!

EXAMPLE START

`filepath1` is needed to solve the task but is not in the working set.

EXAMPLE END

",75
"You are AI Junior, you code like Donald Knuth.
# Working set

src/frontend/service/fetchDescriptor.js:
```
import { getBaseUrl } from '../getBaseUrl';

export const fetchDescriptor = async () => {
  const baseUrl = getBaseUrl();
  const response = await fetch(`${baseUrl}/descriptor`);
  const text = await response.text();
  return text;
};

```


# Task

Implement the following feature!

- Create a plan!
- Create new files when needed!

Requirements:

Create service/sampleService.js same-name fn in it, content based on this, except that it should default export instead of named


## Project Specifics

- Every js file should *only export a single function or signal*!
- Use *ES6 imports*!
- Prefer *async/await* over promises!
- The frontend uses *Solidjs* and Tailwind, edit .jsx files accordingly!
- Remove _all existing comments_ from the code!
- Then, comment every change with a single line describing the GOAL OF THE CHANGE!


# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, avoid using sed in favor of heredoc-ing full files using 'EOF' to prevent substitution.

OS: OSX

Installed tools: npm, jq


Do NOT write any text outside the script!

EXAMPLE START

```sh
#!/bin/sh
set -e
goal=[Task description, max 7 words]
echo ""Plan:""
echo ""1. [...]""
[Commands solving the task]
echo ""\033[32mDone: $goal\033[0m\n""
```

EXAMPLE END

Before starting, check if you need more files to solve the task.
Do not edit any file not provided in the working set!
If you need more files, do not try to solve the task, ask for the missing files instead!

EXAMPLE START

`filepath1` is needed to solve the task but is not in the working set.

EXAMPLE END

",40
"You are AI Junior, you code like Donald Knuth.
# Working set

package.json:
```
{
  ""name"": ""@aijunior/dev"",
  ""version"": ""0.2.0"",
  ""description"": ""Your AI Contributor which codes itself"",
  ""type"": ""module"",
  ""main"": ""src/main.js"",
  ""bin"": {
    ""junior"": ""src/main.js"",
    ""junior-web"": ""src/web.js"",
    ""junior-init"": ""src/init.js""
  },
  ""scripts"": {
    ""cli"": ""node src/main.js"",
    ""start"": ""node src/web.js"",
    ""build:css"": ""postcss ./src/frontend/styles.css -o ./dist/styles.css"",
    ""update-logo"": ""node ./scripts/updateLogo.js"",
    ""clear-branches"": ""node ./scripts/clearBranchesCommand.js $@"",
    ""test"": ""cypress open""
  },
  ""keywords"": [
    ""cli"",
    ""uppercase""
  ],
  ""author"": """",
  ""license"": ""BSL"",
  ""dependencies"": {
    ""@types/js-yaml"": ""^4.0.5"",
    ""autoprefixer"": ""^10.4.14"",
    ""chatgpt"": ""^5.2.4"",
    ""cors"": ""^2.8.5"",
    ""docsify-cli"": ""^4.4.4"",
    ""ejs"": ""^3.1.9"",
    ""express"": ""^4.18.2"",
    ""highlight.js"": ""^11.8.0"",
    ""js-yaml"": ""^4.1.0"",
    ""markdown-it"": ""^13.0.1"",
    ""marked"": ""^5.1.0"",
    ""postcss"": ""^8.4.26"",
    ""postcss-nested"": ""^6.0.1"",
    ""sharp"": ""^0.32.4"",
    ""simple-git"": ""^3.19.1"",
    ""solid-js"": ""^1.7.7"",
    ""tailwindcss"": ""^3.3.3"",
    ""vite"": ""^4.3.9"",
    ""vite-plugin-solid"": ""^2.7.0"",
    ""ws"": ""^8.13.0""
  },
  ""directories"": {
    ""doc"": ""docs""
  },
  ""repository"": {
    ""type"": ""git"",
    ""url"": ""git+https://github.com/tisztamo/Junior.git""
  },
  ""bugs"": {
    ""url"": ""https://github.com/tisztamo/Junior/issues""
  },
  ""homepage"": ""https://github.com/tisztamo/Junior#readme"",
  ""devDependencies"": {
    ""cypress"": ""^12.17.4""
  }
}

```

src/git/clearBranches.js:
```
import { promisify } from 'util';
import { exec as execCb } from 'child_process';

const exec = promisify(execCb);

export default async function clearBranches(exceptions = []) {
  try {
    const { stdout: currentBranch } = await exec('git rev-parse --abbrev-ref HEAD');
    const { stdout: allBranches } = await exec('git for-each-ref --format=""%(refname:short)"" refs/heads');

    const branches = allBranches.split('\n').filter(branch => branch !== currentBranch.trim() && !exceptions.includes(branch) && branch.trim() !== '');

    for (const branch of branches) {
      await executeCommand(`git branch -d ${branch}`);
    }
  } catch (err) {
    console.error(`An error occurred: ${err}`);
  }
}

async function executeCommand(command) {
  try {
    console.log(`Running command: ${command}`);
    const { stdout } = await exec(command);
    console.log(`stdout: ${stdout}`);
  } catch (err) {
    throw err;
  }
}

```

scripts/clearBranchesCommand.js:
```
import clearBranches from '../src/git/clearBranches.js';

const exceptions = process.argv.slice(2);
clearBranches(exceptions).catch(err => {
  console.error(`Failed to clear branches: ${err}`);
});

```


# Task

Implement the following feature!

- Create a plan!
- Create new files when needed!

Requirements:

clear-branches should skip branches that are not merged. Currently it stops with error on them. Also switch from exec to simple-git, eliminating executeCommand.



## Project Specifics

- Every js file should *only export a single function*!
- Use *ES6 imports*!
- Prefer *async/await* over promises!
- The frontend uses *Solidjs* and Tailwind, edit .jsx file accordingly!


# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, avoid using sed in favor of heredoc-ing full files using 'EOF' to prevent substitution.

OS: OSX

Installed tools: npm, jq


Do NOT write any text outside the script!

EXAMPLE START

```sh
#!/bin/sh
set -e
goal=[Task description, max 7 words]
echo ""Plan:""
echo ""1. [...]""
[Commands solving the task]
echo ""\033[32mDone: $goal\033[0m\n""
```

EXAMPLE END

Before starting, check if you need more files to solve the task.
Do not edit any file not provided in the working set!
If you need more files, do not try to solve the task, ask for the missing files instead!

EXAMPLE START

`filepath1` is needed to solve the task but is not in the working set.

EXAMPLE END

",60
"You are Junior, an AI system aiding developers.
You are working with a part of a large program called the ""Working Set.""
Before starting, check if you need more files to solve the task.
Do not edit files without knowing their contents!
Ask for them in normal conversational format instead.

# Working set

docs/README.md:
```
Warn: This README is AI generated, just like all the source files of this project.

# Junior - Your AI-first IDE 

[![Video: Junior codes itself](/assets/video_cover.jpg)](https://youtu.be/NL4uFJSvfW0)

*""Video: Junior codes itself""*

Junior is an **AI-first IDE** designed specifically for professional programmers who have a preference for customizing and fine-tuning their tools. 

With Junior, developers get a unique space where they can work hand-in-hand with AI throughout the development process. By using structured task descriptors and spotlighting relevant parts of a project, tasks like code implementation, documentation, and testing can be seamlessly delegated to Junior.

At its core, Junior embraces a design philosophy that prioritizes simplicity, configurability, and auditability. This ensures that the platform remains both accessible to its users and adaptable to a variety of use-cases.

Junior has been crafted exclusively with AI-powered coding right from its early days, way before its core functionalities were in place. This demonstrates Junior's pioneering approach to harnessing the potential of artificial intelligence in software development.

## Getting Started

For guidance on using Junior, please refer to [usage.md](usage.md).

## Contributing and Support

Your contributions make a difference! At Junior, we value the collaboration of the community. Your role as a contributor is to monitor the development, provide detailed prompts, and thoroughly review the generated outcomes.

For questions or assistance, please raise an issue in our GitHub repository.

**Note:** We've tested Junior primarily with the GPT-4 model. However, you're welcome to experiment with similarly capable models and share your findings. It's not compatible with GPT-3.5.

```


# Task

Improve the documentation!

Create docs/open_jobs.md and fill it based on the following:

I want to create a startup based on my open source project.

The first step is to find a co-founder CEO.

I got the advice from Jared Schrieber to look for the following:

""marketing person at a similar freemium user/product-led growth tools company""

Based on this info write a text that I can forward to the headhunter!

Name Jared and quote his advice!


Do not create backup files.

# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, avoid using sed in favor of heredoc-ing full files using 'EOF' to prevent substitution.

OS: OSX

Installed tools: npm, jq


Do NOT write any text outside the script!

EXAMPLE START

```sh
#!/bin/sh
set -e
goal=[Task description, max 7 words]
echo ""Plan:""
echo ""1. [...]""
[Commands solving the task]
echo ""\033[32mDone: $goal\033[0m\n""
```

EXAMPLE END

",76
"You are Junior, an AI system aiding developers.
You are working with a part of a large program called the ""Working Set.""
Before starting, check if you need more files to solve the task.
Do not edit files without knowing their contents!
Ask for them in normal conversational format instead.

# Working set

src/frontend/components/RequirementsEditor.jsx:
```
import { createEffect } from 'solid-js';
import postDescriptor from '../service/postDescriptor';
import { promptDescriptor, setPromptDescriptor } from '../model/promptDescriptor'; 
import { requirements, setRequirements } from '../model/requirements';
import { getYamlEntry } from '../service/getYamlEntry';
import jsyaml from 'js-yaml'; 
import AutoGrowingTextarea from './AutoGrowingTextarea';

const RequirementsEditor = () => {
  const handleRequirementsChange = async (e) => {
    await postDescriptor({ requirements: e.target.value });
  };

  const handleInput = (e) => {
    const descriptor = promptDescriptor();
    const parsed = jsyaml.load(descriptor);
    parsed.requirements = e.target.value; 
    const updatedDescriptor = jsyaml.dump(parsed);
    setPromptDescriptor(updatedDescriptor);
  };

  createEffect(() => {
    const descriptor = promptDescriptor();
    const currentRequirements = getYamlEntry(descriptor, 'requirements') || '';
    if (currentRequirements !== requirements()) {
      setRequirements(currentRequirements);
    }
  });

  return (
    <div class=""w-full flex justify-start bg-emphasize text-emphasize p-1 rounded border border-border mt-2"">
      <AutoGrowingTextarea
        class=""w-full bg-emphasize text-emphasize text-lg""
        placeholder=""Enter your requirements...""
        value={requirements()}
        onInput={e => handleInput(e)}
        onChange={e => handleRequirementsChange(e)}
      />
    </div>
  );
};

export default RequirementsEditor;

```

src/frontend/components/AutoGrowingTextarea.jsx:
```
import { onCleanup, onMount } from 'solid-js';

const AutoGrowingTextarea = (props) => {
  let textRef;

  const resize = () => {
    textRef.style.height = 'auto';
    textRef.style.height = textRef.scrollHeight + 'px';
  }

  // Use the onMount lifecycle hook to ensure the ref is available
  onMount(() => {
    textRef.addEventListener('input', resize, false);
    resize();  // To resize on initialization
  });

  // When the component unmounts, cleanup the event listener
  onCleanup(() => {
    textRef.removeEventListener('input', resize, false);
  });

  return (
    <textarea
      {...props}
      ref={textRef}
      onInput={resize} // Bind onInput event to the resize function
      rows=""1"" // Start with one row
      style=""overflow:hidden"" // Hide the scrollbar
    />
  );
};

export default AutoGrowingTextarea;

```


# Task

Implement the following feature!

- Create a plan!
- Create new files when needed!

Requirements:

If the --beta cli arg is not present:
  - Disable editing of the req editor
  - Change the placeholder to a text saying ""This is disabled for now. Call with 'npx junior-web -- --beta' to enable.""



## Project Specifics

- Every js file should *only export a single function*!
- Use *ES6 imports*!
- Prefer *async/await* over promises!
- The frontend uses *Solidjs* and Tailwind, edit .jsx file accordingly!


# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, avoid using sed in favor of heredoc-ing full files using 'EOF' to prevent substitution.

OS: OSX

Installed tools: npm, jq


Do NOT write any text outside the script!

EXAMPLE START

```sh
#!/bin/sh
set -e
goal=[Task description, max 7 words]
echo ""Plan:""
echo ""1. [...]""
[Commands solving the task]
echo ""\033[32mDone: $goal\033[0m\n""
```

EXAMPLE END

",65
"You are Junior, an AI system aiding developers.
You are working with a part of a large program called the ""Working Set.""
Before starting, check if you need more files to solve the task.
Do not edit files without knowing their contents!
Ask for them in normal conversational format instead.

# Working set

src/frontend/components/RequirementsEditor.jsx:
```
import { createEffect } from 'solid-js';
import postDescriptor from '../service/postDescriptor';
import { promptDescriptor } from '../model/promptDescriptor';
import { requirements, setRequirements } from '../model/requirements';
import { getYamlEntry } from '../service/getYamlEntry';

const RequirementsEditor = () => {
  const handleRequirementsChange = async (e) => {
    setRequirements(e.target.value);
    await postDescriptor({ requirements: e.target.value });
  };

  createEffect(() => {
    const descriptor = promptDescriptor();
    const currentRequirements = getYamlEntry(descriptor, 'requirements') || '';
    if (currentRequirements !== requirements()) {
      setRequirements(currentRequirements);
    }
  });

  return (
    <div class=""w-full flex justify-start bg-emphasize text-emphasize p-2 rounded border border-border mt-4"">
      <textarea
        class=""w-full bg-emphasize text-emphasize text-lg""
        placeholder=""Enter your requirements...""
        value={requirements()}
        onInput={e => handleRequirementsChange(e)}
      />
    </div>
  );
};

export default RequirementsEditor;

```

src/backend/handlers/updateDescriptorHandler.js:
```
import yaml from 'js-yaml';
import { loadPromptDescriptor } from ""../../prompt/loadPromptDescriptor.js"";
import { savePromptDescriptor } from ""../../prompt/savePromptDescriptor.js"";

const updateDescriptorHandler = async (req, res) => {
  const { requirements, attention } = req.body;
  
  try {
    const fileContent = await loadPromptDescriptor();
    const document = yaml.load(fileContent);

    if (requirements !== undefined) {
      document.requirements = requirements;
    }
    
    if (attention !== undefined) {
      document.attention = attention;
    }
    
    const newYamlStr = yaml.dump(document);
    await savePromptDescriptor(newYamlStr);
    
    res.status(200).json({ message: ""Descriptor updated successfully"" });
  } catch (error) {
    console.log(error);
    res.status(500).json({ message: ""Internal server error"" });
  }
};

export default updateDescriptorHandler;

```


# Task

Fix the following issue!

Remove the call to setRequirements from handleRequirementsChange
Add throttling handleRequirementsChange: Do not post more than once per second



## Project Specifics

- Every js file should *only export a single function*!
- Use *ES6 imports*!
- Prefer *async/await* over promises!
- The frontend uses *Solidjs* and Tailwind, edit .jsx file accordingly!


# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, avoid using sed in favor of heredoc-ing full files using 'EOF' to prevent substitution.

OS: OSX

Installed tools: npm, jq


Do NOT write any text outside the script!

EXAMPLE START

```sh
#!/bin/sh
set -e
goal=[Task description, max 7 words]
echo ""Plan:""
echo ""1. [...]""
[Commands solving the task]
echo ""\033[32mDone: $goal\033[0m\n""
```

EXAMPLE END

",75
"You are Junior, an AI system aiding developers. You are working with a part of a large program called the ""Working Set."" Ask for contents of subdirectories if needed. Some files are printed in the working set. Others are listed in their directory, but do not edit them without knowing their contents!

# Working set

```
./
?????€??€ .git/...
?????€??€ .github/...
?????€??€ .gitignore
?????€??€ .vscode/...
?????€??€ README.md
?????€??€ change.sh
?????€??€ docs/...
?????€??€ integrations/...
?????€??€ node_modules/...
?????€??€ package-lock.json
?????€??€ package.json
?????€??€ prompt/...
?????€??€ prompt.md
?????€??€ prompt.yaml
?????€??€ scripts/...
?????€??€ src/...

```
```
./prompt/
?????€??€ archive/...
?????€??€ defaults/...
?????€??€ format/...
?????€??€ format.md
?????€??€ installedTools.md
?????€??€ os.md
?????€??€ projectSpecifics.md
?????€??€ system.md
?????€??€ task/...

```
src/init.js:
```
#!/usr/bin/env node
import { execSync } from 'child_process';
import { createPromptYaml } from './prompt/createPromptYaml.js';
import { createGitignore } from './git/createGitignore.js';
import { createPromptDir } from './prompt/createPromptDir.js';

async function juniorInit() {
  execSync('git init', { stdio: 'inherit' });

  createGitignore();
  await createPromptDir();
  createPromptYaml();

  // Copying all files from prompt/defaults to the new repo
  execSync('cp -r ./prompt/defaults/* ./prompt/', { stdio: 'inherit' });

  execSync('git add .', { stdio: 'inherit' });
  execSync('git commit -m ""Junior init""', { stdio: 'inherit' });

  console.log('\x1b[32mRepo initialized for Junior development\x1b[0m');
}

juniorInit();

```

package.json:
```
{
  ""name"": ""@aijunior/dev"",
  ""version"": ""0.1.4"",
  ""description"": ""Your AI Contributor which codes itself"",
  ""type"": ""module"",
  ""main"": ""src/main.js"",
  ""bin"": {
    ""junior"": ""src/main.js"",
    ""junior-web"": ""src/web.js"",
    ""junior-init"": ""src/init.js""
  },
  ""scripts"": {
    ""cli"": ""node src/main.js"",
    ""start"": ""node src/web.js"",
    ""build:css"": ""postcss ./src/frontend/styles.css -o ./dist/styles.css"",
    ""update-logo"": ""node ./scripts/updateLogo.js"",
    ""clear-branches"": ""node ./scripts/clearBranchesCommand.js $@""
  },
  ""keywords"": [
    ""cli"",
    ""uppercase""
  ],
  ""author"": """",
  ""license"": ""GPL"",
  ""dependencies"": {
    ""@types/js-yaml"": ""^4.0.5"",
    ""autoprefixer"": ""^10.4.14"",
    ""chatgpt"": ""^5.2.4"",
    ""cors"": ""^2.8.5"",
    ""docsify-cli"": ""^4.4.4"",
    ""ejs"": ""^3.1.9"",
    ""express"": ""^4.18.2"",
    ""highlight.js"": ""^11.8.0"",
    ""js-yaml"": ""^4.1.0"",
    ""markdown-it"": ""^13.0.1"",
    ""marked"": ""^5.1.0"",
    ""postcss"": ""^8.4.26"",
    ""postcss-nested"": ""^6.0.1"",
    ""sharp"": ""^0.32.4"",
    ""simple-git"": ""^3.19.1"",
    ""solid-js"": ""^1.7.7"",
    ""tailwindcss"": ""^3.3.3"",
    ""vite"": ""^4.3.9"",
    ""vite-plugin-solid"": ""^2.7.0"",
    ""ws"": ""^8.13.0""
  },
  ""directories"": {
    ""doc"": ""docs""
  },
  ""repository"": {
    ""type"": ""git"",
    ""url"": ""git+https://github.com/tisztamo/Junior.git""
  },
  ""bugs"": {
    ""url"": ""https://github.com/tisztamo/Junior/issues""
  },
  ""homepage"": ""https://github.com/tisztamo/Junior#readme""
}

```


# Task

Fix the following issue!

When junior-init is executed on a newly created repo, prompt files have to be correctly located. They are in the installed version of Junior, and inside there in prompt/defaults/.



## Project Specifics

- Every js file should *only export a single function*!
- Use *ES6 imports*!
- Prefer *async/await* over promises!
- The frontend uses *Solidjs*, edit .jsx file accordingly


# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, avoid using sed in favor of heredoc-ing full files using 'EOF' to prevent substitution.

OS: OSX

Installed tools: npm, jq


Do NOT write any text outside the script!

EXAMPLE START

```sh
#!/bin/sh
set -e
goal=[Task description, max 7 words]
echo ""Plan:""
echo ""1. [...]""
[Commands solving the task]
echo ""\033[32mDone: $goal\033[0m\n""
```

EXAMPLE END

",70
"You are Junior, an AI system aiding developers. You are working with a part of a large program called the ""Working Set."" Ask for contents of subdirectories if needed. Some files are printed in the working set. Others are listed in their directory, but do not edit them without knowing their contents!

# Working set

scripts/updateLogo.js:
```
import sharp from 'sharp';
import { writeFileSync } from 'fs';

const inputSVGPath = 'docs/assets/logo.svg';
const outputPNGPath = 'docs/assets/logo.png';
const faviconDocsPath = 'docs/assets/favicon.ico';
const faviconFrontendPath = 'src/frontend/assets/favicon.ico';

const updateLogo = async () => {
  try {
    const buffer = await sharp(inputSVGPath).png().toBuffer();
    writeFileSync(outputPNGPath, buffer);

    // Convert logo to favicon sizes
    const faviconBuffer = await sharp(inputSVGPath).resize(16, 16).ico().toBuffer();
    
    // Update favicon in both the docs and frontend directories
    writeFileSync(faviconDocsPath, faviconBuffer);
    writeFileSync(faviconFrontendPath, faviconBuffer);
  } catch (err) {
    throw err;
  }
};

updateLogo();

```


# Task

Fix the following issue!

file:///Users/ko/projects-new/Junior/scripts/updateLogo.js:15
    const faviconBuffer = await sharp(inputSVGPath).resize(16, 16).ico().toBuffer();
                                                                  ^

TypeError: sharp(...).resize(...).ico is not a function
    at updateLogo (file:///Users/ko/projects-new/Junior/scripts/updateLogo.js:15:68)

Node.js v18.5.0



## Project Specifics

- Every js file should *only export a single function*!
- Use *ES6 imports*!
- Prefer *async/await* over promises!
- The frontend uses *Solidjs*, edit .jsx file accordingly


# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, avoid using sed in favor of heredoc-ing full files using 'EOF' to prevent substitution.

OS: OSX

Installed tools: npm, jq


Do NOT write any text outside the script!

EXAMPLE START

```sh
#!/bin/sh
set -e
goal=[Task description, max 7 words]
echo ""Plan:""
echo ""1. [...]""
[Commands solving the task]
echo ""\033[32mDone: $goal\033[0m\n""
```

EXAMPLE END

",85
"You are Junior, an AI system aiding developers. You are working with a part of a large program called the ""Working Set."" Ask for contents of subdirectories if needed. Some files are printed in the working set. Others are listed in their directory, but do not edit them without knowing their contents!

# Working set

```
./
?????€??€ .git/...
?????€??€ .github/...
?????€??€ .gitignore
?????€??€ .vscode/...
?????€??€ README.md
?????€??€ change.sh
?????€??€ docs/...
?????€??€ integrations/...
?????€??€ node_modules/...
?????€??€ package-lock.json
?????€??€ package.json
?????€??€ prompt/...
?????€??€ prompt.md
?????€??€ prompt.yaml
?????€??€ scripts/...
?????€??€ src/...

```
```
./scripts/
?????€??€ deleteBranchesCommand.js
?????€??€ updateLogo.js

```
src/git/clearBranches.js:
```
import { promisify } from 'util';
import { exec as execCb } from 'child_process';

const exec = promisify(execCb);

export default async function clearBranches(exceptions = []) {
  try {
    const { stdout: currentBranch } = await exec('git rev-parse --abbrev-ref HEAD');
    const { stdout: allBranches } = await exec('git for-each-ref --format=""%(refname:short)"" refs/heads');

    const branches = allBranches.split('\n').filter(branch => branch !== currentBranch.trim() && !exceptions.includes(branch));

    for (const branch of branches) {
      await executeCommand(`git branch -d ${branch}`);
    }
  } catch (err) {
    console.error(`An error occurred: ${err}`);
  }
}

async function executeCommand(command) {
  try {
    console.log(`Running command: ${command}`);
    const { stdout } = await exec(command);
    console.log(`stdout: ${stdout}`);
  } catch (err) {
    throw err;
  }
}

```

src/git/clearBranchesCommand.js:
```
import clearBranches from './clearBranches';

const exceptions = process.argv.slice(2);

async function run() {
  try {
    await clearBranches(exceptions);
    console.log('Branches deleted successfully.');
  } catch (err) {
    console.error(`An error occurred while deleting branches: ${err}`);
    process.exit(1);
  }
}

run();


```


# Task

Move the following files to the specified target dirs!

Find out the best target dir if it is not specified!

You need to follow dependencies to maintain coherence.

Before executing, write a concise plan! The plan should show:
 - How do you avoid breaking other parts of the code.
 - If you had to choose, your way of thinking.

Move clearBranchesCommand.js to scripts/
Delete scripts/deleteBranchesCommand.js


# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, avoid using sed in favor of heredoc-ing full files using 'EOF' to prevent substitution.

OS: OSX

Installed tools: npm, jq


Do NOT write any text outside the script!

EXAMPLE START

```sh
#!/bin/sh
set -e
goal=[Task description, max 7 words]
echo ""Plan:""
echo ""1. [...]""
[Commands solving the task]
echo ""\033[32mDone: $goal\033[0m\n""
```

EXAMPLE END

",85
"You're the 'Junior', an AI system aiding authors.

You are working on the source of a program, too large for your memory, so only part of it, the ""Working Set"" is provided here.

You will see a partial directory structure. Ask for the contents of subdirs marked with /... if needed.

Some files are printed in the working set.

Other files are only listed in their dir, so you know they exists. Do not edit files without knowing their current content, ask for their contents instead!

# Working set

prompt/system.md:
```
You're the 'Junior', an AI system aiding authors.

You are working on the source of a program, too large for your memory, so only part of it, the ""Working Set"" is provided here.

You will see a partial directory structure. Ask for the contents of subdirs marked with /... if needed.

Some files are printed in the working set.

Other files are only listed in their dir, so you know they exists. Do not edit files without knowing their current content, ask for their contents instead!

```


# Task

Implement the following feature!

- Create a plan!
- Create new files when needed!

Requirements:

Rewrite the system prompt in system.md to be concise but easy to &#34;understand&#34; for a language model. Start it with &#34;You are Junior, an AI system aiding developers&#34;



## Project Specifics

- Every js file should *only export a single function*!
- Use *ES6 imports*!
- Prefer *async/await* over promises!
- The frontend uses *Solidjs*, edit .jsx file accordingly


# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, avoid using sed in favor of heredoc-ing full files using 'EOF' to prevent substitution.

OS: OSX

Installed tools: npm, jq


Do NOT write any text outside the script!

EXAMPLE START

```sh
#!/bin/sh
set -e
goal=[Task description, max 7 words]
echo ""Plan:""
echo ""1. [...]""
[Commands solving the task]
echo ""\033[32mDone: $goal\033[0m\n""
```

EXAMPLE END

",60
"# Working set

src/frontend/components/ConfirmationDialog.jsx:
```
import { createEffect, createSignal } from ""solid-js"";

const ConfirmationDialog = (props) => {
  const [visible, setVisible] = createSignal(false);
  const [disableConfirmation, setDisableConfirmation] = createSignal(false);

  const handleCheckboxChange = (event) => {
    setDisableConfirmation(event.target.checked);
    localStorage.setItem('Junior.disableRollbackConfirmation', event.target.checked);
  };

  createEffect(() => {
    setVisible(props.visible);
  });

  return (
    <div className={visible() ? ""block"" : ""hidden""}>
      <div className=""fixed inset-0 flex items-center justify-center z-50"" style={{ backgroundColor: ""var(--background-color)"" }}>
        <div className=""bg-main p-8 rounded shadow-lg text-text"">
          <h3 className=""text-xl mb-4"">Are you sure you want to roll back?</h3>
          <p>This will reset the repo to the last commit and delete new files.</p>
          <label style={{ display: 'flex', alignItems: 'center', margin: '10px 0' }}>
            <input type=""checkbox"" style={{ marginRight: '10px' }} checked={disableConfirmation()} onChange={handleCheckboxChange} />
            Never show this again
          </label>
          <div>
            <button className=""bg-emphasize text-white px-4 py-2 rounded mr-4"" onClick={props.onConfirm}>Confirm</button>
            <button className=""bg-gray-400 text-white px-4 py-2 rounded"" onClick={props.onCancel}>Cancel</button>
          </div>
        </div>
      </div>
      <div className={visible() ? ""fixed inset-0 bg-black opacity-50"" : ""hidden""}></div>
    </div>
  );
};

export default ConfirmationDialog;

```

src/frontend/components/RollbackButton.jsx:
```
import { createSignal } from ""solid-js"";
import { resetGit } from '../service/resetGit';
import ConfirmationDialog from './ConfirmationDialog';

const RollbackButton = () => {
  const [showConfirmation, setShowConfirmation] = createSignal(false);

  const handleReset = async () => {
    const response = await resetGit();

    console.log(response.message);
  };

  const handleConfirm = () => {
    setShowConfirmation(false);
    handleReset();
  };

  const handleRollbackClick = () => {
    const disableConfirmation = localStorage.getItem('Junior.disableRollbackConfirmation') === 'true';
    if (disableConfirmation) {
      handleReset();
    } else {
      setShowConfirmation(true);
    }
  };

  return (
    <>
      <button className=""w-full px-4 py-4 bg-red-700 text-white rounded"" onClick={handleRollbackClick}>Roll Back</button>
      <ConfirmationDialog visible={showConfirmation()} onConfirm={handleConfirm} onCancel={() => setShowConfirmation(false)} />
    </>
  );
};

export default RollbackButton;

```


# Task

Move the following files to the specified target dirs!

Find out the best target dir if it is not specified!

You need to follow dependencies to maintain coherence.

Before executing, write a concise plan! The plan should show:
 - How do you avoid breaking other parts of the code.
 - If you had to choose, your way of thinking.

- Rename it to RollbackConfirmationDialog - Also change the bg-emphasize button background to red, and the label to &#34;Yes, Roll Back&#34;


# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, avoid using sed in favor of heredoc-ing full files using 'EOF' to prevent substitution.

OS: OSX

Installed tools: npm, jq


Do NOT write any text outside the script!

EXAMPLE START

```sh
#!/bin/sh
set -e
goal=[Task description, max 7 words]
echo ""Plan:""
echo ""1. [...]""
[Commands solving the task]
echo ""\033[32mDone: $goal\033[0m\n""
```

EXAMPLE END

",60
"# Working set

src/frontend/components/ChangeFinalization.jsx:
```
import CommitMessageInput from './CommitMessageInput';
import CommitButton from './CommitButton';
import RollbackButton from './RollbackButton';

const ChangeFinalization = () => {
  return (
    <>
      <CommitMessageInput />
      <CommitButton />
      <RollbackButton />
    </>
  );
};

export default ChangeFinalization;

```

src/frontend/components/RollbackButton.jsx:
```
import { resetGit } from '../service/resetGit';

const RollbackButton = () => {
  const handleReset = async () => {
    const response = await resetGit();

    console.log(response.message);
  };

  return (
    <button class=""w-64 px-4 py-4 bg-red-700 text-white rounded"" onClick={handleReset}>Roll Back to Last Commit</button>
  );
};

export default RollbackButton;

```

src/frontend/components/CommitButton.jsx:
```
import { postCommit } from '../service/postCommit';
import { commitMessage, setCommitMessage } from '../model/commitMessage';
import { fetchGitStatus } from '../service/fetchGitStatus';
import { setExecutionResult } from '../model/executionResult';
import { setPrompt } from '../model/prompt';
import { setChange } from '../model/change'; // Importing setChange to clear the change

const CommitButton = () => {
  const handleCommit = async () => {
    const response = await postCommit(commitMessage());
    console.log(response.message);
    const status = await fetchGitStatus();
    console.log(status);
    setChange(''); // Clearing the change after commit
    setExecutionResult('');
    setCommitMessage('');
    setPrompt('');
  };

  return (
    <button className=""w-64 px-4 py-4 bg-green-700 text-white rounded mt-2"" onClick={handleCommit}>Commit</button>
  );
};

export default CommitButton;

```


# Task

Implement the following feature!

- Create a plan!
- Create new files when needed!

Requirements:

Change the layout so that commitbutton and rollbackbutton are next to each other horizontally



## Project Specifics

- Every js file should *only export a single function*!
- Use *ES6 imports*!
- Prefer *async/await* over promises!
- The frontend uses *Solidjs*, edit .jsx file accordingly


# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, avoid using sed in favor of heredoc-ing full files using 'EOF' to prevent substitution.

OS: OSX

Installed tools: npm, jq


Do NOT write any text outside the script!

EXAMPLE START

```sh
#!/bin/sh
set -e
goal=[Task description, max 7 words]
echo ""Plan:""
echo ""1. [...]""
[Commands solving the task]
echo ""\033[32mDone: $goal\033[0m\n""
```

EXAMPLE END

",90
"# Working set

src/frontend/App.jsx:
```
import GenerateButton from './components/GenerateButton';
import ExecuteButton from './components/ExecuteButton';
import RollbackButton from './components/RollbackButton';
import CommitButton from './components/CommitButton';
import PromptDisplay from './components/PromptDisplay';
import TasksList from './components/TasksList';
import PromptDescriptor from './components/PromptDescriptor';
import NavBar from './components/NavBar';
import ExecutionResultDisplay from './components/ExecutionResultDisplay';
import GitStatusDisplay from './components/GitStatusDisplay';
import CommitMessageInput from './components/CommitMessageInput';

const App = () => {
  return (
    <div id=""app"" class=""p-2"">
      <div class=""max-w-desktop lg:max-w-desktop md:max-w-full sm:max-w-full xs:max-w-full mx-auto flex flex-col items-center space-y-8 sm:p-0"">
        <NavBar />
        <TasksList />
        <PromptDescriptor />
        <GenerateButton />
        <PromptDisplay />
        <ExecuteButton />
        <ExecutionResultDisplay />
        <GitStatusDisplay />
        <CommitMessageInput />
        <CommitButton />
        <RollbackButton />
      </div>
    </div>
  );
};

export default App;

```


# Task

## Refactor by split

A file is too big. We need to split it into parts.
Identify the possible parts and refactor the code in separate files!

Create components for
  - Prompt Creation (TaskList...PromptDisplay)
  - Change Execution
  - Change Inspection (GitStatusDisplay)
  - Change Finalization
And move the corresponding items from App to them.



# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, avoid using sed in favor of heredoc-ing full files using 'EOF' to prevent substitution.

OS: OSX

Installed tools: npm, jq


Do NOT write any text outside the script!

EXAMPLE START

```sh
#!/bin/sh
set -e
goal=[Task description, max 7 words]
echo ""Plan:""
echo ""1. [...]""
[Commands solving the task]
echo ""\033[32mDone: $goal\033[0m\n""
```

EXAMPLE END

",98
"# Working set

src/frontend/styles/colors.css:
```
:root {
  --text-color: #1a202c;
  --background-color: #f7fafc;
  --emphasize-color: #e2e8f0;
  --background-emphasize-color: #e5e7eb;
}

.dark {
  --text-color: #f7fafc;
  --background-color: #1a202c;
  --emphasize-color: #2d3748;
  --background-emphasize-color: #2c2f33;
}

```


# Task

Implement the following feature!

- Create a plan!
- Create new files when needed!

Requirements:

Change --emphasize-color to be close but visibly different from --text-color! Change --background-emphasize-color to be close but visibly different from  to be close but visibly different from background-color!



## Project Specifics

- Every js file should *only export a single function*!
- Use *ES6 imports*!
- Prefer *async/await* over promises!
- The frontend uses *Solidjs*, edit .jsx file accordingly


# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, avoid using sed in favor of heredoc-ing full files using 'EOF' to prevent substitution.

OS: OSX

Installed tools: npm, jq


Do NOT write any text outside the script!

EXAMPLE START

```sh
#!/bin/sh
set -e
goal=[Task description, max 7 words]
echo ""Plan:""
echo ""1. [...]""
[Commands solving the task]
echo ""\033[32mDone: $goal\033[0m\n""
```

EXAMPLE END

",85
"# Working set

src/frontend/tailwind.config.cjs:
```
module.exports = {
  darkMode: 'class',
  content: [__dirname + '/**/*.html', __dirname + '/**/*.jsx'],
  theme: {
    screens: {
      'xs': '320px',
      'sm': '640px',
      'md': '768px',
      'lg': '1024px',
      'xl': '1280px',
      '2xl': '1536px',
    },
    extend: {
      spacing: {
        '72': '18rem',
        '84': '21rem',
        '96': '24rem',
        '128': '32rem',
      },
      fontSize: {
        'btn': '1.5rem',
      },
      padding: {
        'btn': '1.5rem',
      },
      maxWidth: {
        'desktop': '640px',
      },
      colors: {
        text: ""var(--text-color)"",
        emphasize: ""var(--emphasize-color)"",
      },
      backgroundColor: {
        main: ""var(--background-color)"",
      },
    },
  },
  variants: {
    extend: {},
  },
  plugins: [],
}

```

src/frontend/styles/colors.css:
```
:root {
  --text-color: #1a202c;
  --background-color: #f7fafc;
  --emphasize-color: #e2e8f0;
}

.dark {
  --text-color: #f7fafc;
  --background-color: #1a202c;
  --emphasize-color: #2d3748;
}

```


# Task

Implement the following feature!

- Create a plan!
- Create new files when needed!

Requirements:

Add --background-emphasize-color variable to colors.css and ue it as &#34;emphasize&#34; backgroundColor in tailwind



## Project Specifics

- Every js file should *only export a single function*!
- Use *ES6 imports*!
- Prefer *async/await* over promises!
- The frontend uses *Solidjs*, edit .jsx file accordingly


# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, avoid using sed in favor of heredoc-ing full files using 'EOF' to prevent substitution.

OS: OSX

Installed tools: npm, jq


Do NOT write any text outside the script!

EXAMPLE START

```sh
#!/bin/sh
set -e
goal=[Task description, max 7 words]
echo ""Plan:""
echo ""1. [...]""
[Commands solving the task]
echo ""\033[32mDone: $goal\033[0m\n""
```

EXAMPLE END

",95
"# Working set

src/frontend/tailwind.config.cjs:
```
module.exports = {
  content: [__dirname + '/**/*.html', __dirname + '/**/*.jsx'],
  theme: {
    screens: {
      'xs': '320px',
      'sm': '640px',
      'md': '768px',
      'lg': '1024px',
      'xl': '1280px',
      '2xl': '1536px',
    },
    extend: {
      // Extend the spacing for larger gaps
      spacing: {
        '72': '18rem',
        '84': '21rem',
        '96': '24rem',
        '128': '32rem',
      },
      // Extend the button styles for larger buttons
      fontSize: {
        'btn': '1.5rem',
      },
      padding: {
        'btn': '1.5rem',
      },
      // Extend the maxWidth for desktop container
      maxWidth: {
        'desktop': '640px',
      },
    },
  },
  variants: {
    extend: {},
  },
  plugins: [],
}

```

src/frontend/components/ThemeSwitcher.jsx:
```
import { createEffect, createSignal } from 'solid-js';

const ThemeSwitcher = () => {
  const [theme, setTheme] = createSignal(window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light');

  createEffect(() => {
    const currentTheme = theme();
    document.body.className = currentTheme;
    localStorage.setItem('theme', currentTheme);
  });

  const toggleTheme = () => {
    setTheme(theme() === 'dark' ? 'light' : 'dark');
  };

  return (
    <button onClick={toggleTheme} class=""text-xl underline cursor-pointer"">
      {theme() === 'dark' ? 'Light Mode' : 'Dark Mode'}
    </button>
  );
};

export default ThemeSwitcher;

```


# Task

Fix the following issue!

The theme switcher switches classes on the body, but nothing happens on the screen.


# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, avoid using sed in favor of heredoc-ing full files using 'EOF' to prevent substitution.

OS: OSX

Installed tools: npm, jq


Do NOT write any text outside the script!

EXAMPLE START

```sh
#!/bin/sh
set -e
goal=[Task description, max 7 words]
echo ""Plan:""
echo ""1. [...]""
[Commands solving the task]
echo ""\033[32mDone: $goal\033[0m\n""
```

EXAMPLE END

",85
"# Working set

```
src/frontend/
?????€??€ App.jsx
?????€??€ assets/...
?????€??€ components/...
?????€??€ fetchTasks.js
?????€??€ generatePrompt.js
?????€??€ getBaseUrl.js
?????€??€ index.html
?????€??€ index.jsx
?????€??€ postcss.config.cjs
?????€??€ service/...
?????€??€ startVite.js
?????€??€ stores/...
?????€??€ styles/...
?????€??€ tailwind.config.cjs
?????€??€ vite.config.js

```
```
src/frontend/service/
?????€??€ createWebSocket.js
?????€??€ executeChange.js
?????€??€ fetchDescriptor.js
?????€??€ fetchGitStatus.js
?????€??€ handleTaskChange.js
?????€??€ parseYamlAndGetTask.js
?????€??€ postCommit.js
?????€??€ resetGit.js
?????€??€ useWebsocket.js

```
src/frontend/stores/change.js:
```
import { createSignal } from 'solid-js';

export const [change, setChange] = createSignal('');

```

src/frontend/stores/commitMessage.js:
```
import { createSignal } from 'solid-js';

const [commitMessage, setCommitMessage] = createSignal('');

export { commitMessage, setCommitMessage };

```


# Task

Implement the following feature!

- Create a plan!
- Create new files when needed!

Requirements:

Create a function in the servitce directory, which, when called, starts to
monitor the change signal, parses its content, which should be a shells script,
for a line:
goal=&#34;Some goal description&#34;
and if found, sets the commit message to the value of this goal variable



## Project Specifics

- Every js file should *only export a single function*!
- Use *ES6 imports*!
- Prefer *async/await* over promises!
- The frontend uses *Solidjs*, edit .jsx file accordingly


# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, prefer heredoc-ing full files using 'EOF' to prevent substitution.

OS: OSX

Installed tools: npm, jq


Do NOT write any text outside the script!

EXAMPLE START

```sh
#!/bin/sh
set -e
goal=[Task description, max 7 words]
echo ""Plan:""
echo ""1. [...]""
[Commands solving the task]
echo ""\033[32mDone: $goal\033[0m\n""
```

EXAMPLE END

",65
"# Working set

src/frontend/App.jsx:
```
import GenerateButton from './components/GenerateButton';
import ExecuteButton from './components/ExecuteButton';
import RollbackButton from './components/RollbackButton';
import CommitButton from './components/CommitButton';
import PromptDisplay from './components/PromptDisplay';
import TasksList from './components/TasksList';
import PromptDescriptor from './components/PromptDescriptor';
import NavBar from './components/NavBar';
import ExecutionResultDisplay from './components/ExecutionResultDisplay';
import GitStatusDisplay from './components/GitStatusDisplay';
import CommitMessageInput from './components/CommitMessageInput';

const App = () => {
  return (
    <div class=""m-2"">
      <div class=""max-w-desktop lg:max-w-desktop md:max-w-full sm:max-w-full xs:max-w-full mx-auto flex flex-col items-center space-y-8 sm:p-0"">
        <NavBar />
        <TasksList />
        <PromptDescriptor />
        <GenerateButton />
        <PromptDisplay />
        <ExecuteButton />
        <ExecutionResultDisplay />
        <GitStatusDisplay />
        <CommitMessageInput />
        <CommitButton />
        <RollbackButton />
      </div>
    </div>
  );
};

export default App;

```

src/frontend/components/ExecuteButton.jsx:
```
import { executeChange } from '../service/executeChange';
import { setExecutionResult } from '../stores/executionResult';

const ExecuteButton = () => {
  const handleExecuteChange = async () => {
    const change = await navigator.clipboard.readText();
    const response = await executeChange(change);
    setExecutionResult(response.output);
    console.log(response.output);
  };

  return (
    <button class=""w-64 px-4 py-4 bg-orange-300 text-white rounded"" onClick={handleExecuteChange}>Paste & Execute Change</button>
  );
};

export default ExecuteButton;

```

src/frontend/stores/executionResult.js:
```
import { createSignal } from 'solid-js';

export const [executionResult, setExecutionResult] = createSignal('');

```

src/frontend/components/CommitButton.jsx:
```
import { postCommit } from '../service/postCommit';
import { commitMessage, setCommitMessage } from '../stores/commitMessage';
import { fetchGitStatus } from '../service/fetchGitStatus';
import { setExecutionResult } from '../stores/executionResult'; // Importing the necessary function to clear execution result
import { setPrompt } from '../stores/prompt'; // Importing setPrompt to clear the prompt

const CommitButton = () => {
  const handleCommit = async () => {
    const response = await postCommit(commitMessage());
    console.log(response.message);
    const status = await fetchGitStatus();
    console.log(status);
    setExecutionResult(''); // Clearing the execution result after commit
    setCommitMessage(''); // Clearing the commit message after commit
    setPrompt(''); // Clearing the prompt after commit
  };

  return (
    <button className=""w-64 px-4 py-4 bg-green-700 text-white rounded mt-2"" onClick={handleCommit}>Commit</button>
  );
};

export default CommitButton;

```


# Task

Implement the following feature!

- Create a plan!
- Create new files when needed!

Requirements:

- Create a signal in src/frontend/stores/change.js
- Save the pasted change after it was executed.
- Clear the change after commit.



## Project Specifics

- Every js file should *only export a single function*!
- Use *ES6 imports*!
- Prefer *async/await* over promises!
- The frontend uses *Solidjs*, edit .jsx file accordingly


# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, prefer heredoc-ing full files using 'EOF' to prevent substitution.

OS: OSX

Installed tools: npm, jq


Do NOT write any text outside the script!

EXAMPLE START

```sh
#!/bin/sh
set -e
goal=[Task description, max 7 words]
echo ""Plan:""
echo ""1. [...]""
[Commands solving the task]
echo ""\033[32mDone: $goal\033[0m\n""
```

EXAMPLE END

",84
"# Working set

src/frontend/components/CommitButton.jsx:
```
import { postCommit } from '../service/postCommit';
import { commitMessage } from '../stores/commitMessage';
import { fetchGitStatus } from '../service/fetchGitStatus';
import { setExecutionResult } from '../stores/executionResult'; // Importing the necessary function to clear execution result

const CommitButton = () => {
  const handleCommit = async () => {
    const response = await postCommit(commitMessage());
    console.log(response.message);
    const status = await fetchGitStatus();
    console.log(status);
    setExecutionResult(''); // Clearing the execution result after commit
  };

  return (
    <button className=""w-64 px-4 py-4 bg-green-700 text-white rounded mt-2"" onClick={handleCommit}>Commit</button>
  );
};

export default CommitButton;

```

src/frontend/stores/commitMessage.js:
```
import { createSignal } from 'solid-js';

const [commitMessage, setCommitMessage] = createSignal('');

export { commitMessage, setCommitMessage };

```

src/frontend/stores/prompt.js:
```
import { createSignal } from 'solid-js';

export const [prompt, setPrompt] = createSignal('');

```


# Task

Implement the following feature!

- Create a plan!
- Create new files when needed!

Requirements:

After commit, clear the prompt  and the commit message to &#39;&#39;



## Project Specifics

- Every js file should *only export a single function*!
- Use *ES6 imports*!
- Prefer *async/await* over promises!
- The frontend uses *Solidjs*, edit .jsx file accordingly


# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, prefer heredoc-ing full files using 'EOF' to prevent substitution.

OS: OSX

Installed tools: npm, jq


Do NOT write any text outside the script!

EXAMPLE START

```sh
#!/bin/sh
set -e
goal=[Task description, max 7 words]
echo ""Plan:""
echo ""1. [...]""
[Commands solving the task]
echo ""\033[32mDone: $goal\033[0m\n""
```

EXAMPLE END

",76
"# Working set

```
./
?????€??€ .DS_Store
?????€??€ .git/...
?????€??€ .github/...
?????€??€ .gitignore
?????€??€ .vscode/...
?????€??€ README.md
?????€??€ change.sh
?????€??€ doc/...
?????€??€ integrations/...
?????€??€ node_modules/...
?????€??€ package-lock.json
?????€??€ package.json
?????€??€ prompt/...
?????€??€ prompt.md
?????€??€ prompt.yaml
?????€??€ src/...

```
```
doc/
?????€??€ .DS_Store
?????€??€ assets/...
?????€??€ example.html
?????€??€ example.md
?????€??€ index.html
?????€??€ introduction.html
?????€??€ introduction.md
?????€??€ screenshot.png
?????€??€ web.html
?????€??€ web.md

```
doc/index.html:
```
<!DOCTYPE html>
<html>
  <head>
    <meta charset=""UTF-8"">
    <title>Documentation</title>
  </head>
  <body>
    <h1>Welcome to our documentation!</h1>
    <p>Start with the <a href=""introduction.html"">introduction</a>.</p>
  </body>
</html>

    <p>Check out the <a href=""web.html"">Web Interface Guide</a>.</p>


```


# Task

Implement the following feature!

- Create a plan!
- Create new files when needed!

Requirements:

- Create roadmap.md with sections &#34;Usability &amp;??fixes&#34;, &#34;Programming on mobile&#34;, &#34;Auto-attention&#34;, &#34;Prompt-herd refactors&#34;
- Link roadmap.html from index.html
- Fix index.html by moving the ill-placed link to the web guide into the body.
- Mention the project name &#34;Junior&#34; in index.html text and title
- Delete introduction.* and unlink from index.html
- npm run build:doc for generating html from md



## Project Specifics

- Every js file should *only export a single function*!
- Use *ES6 imports*!
- Prefer *async/await* over promises!
- The frontend uses *Solidjs*, edit .jsx file accordingly


# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, prefer heredoc-ing full files using 'EOF' to prevent substitution.

OS: OSX

Installed tools: npm, jq


Do NOT write any text outside the script!

EXAMPLE START

```sh
#!/bin/sh
set -e
goal=[Task description, max 7 words]
echo ""Plan:""
echo ""1. [...]""
[Commands solving the task]
echo ""\033[32mDone: $goal\033[0m\n""
```

EXAMPLE END

",94
"# Working set

```
./
?????€??€ .DS_Store
?????€??€ .git/...
?????€??€ .github/...
?????€??€ .gitignore
?????€??€ .vscode/...
?????€??€ README.md
?????€??€ change.sh
?????€??€ doc/...
?????€??€ integrations/...
?????€??€ node_modules/...
?????€??€ package-lock.json
?????€??€ package.json
?????€??€ prompt/...
?????€??€ prompt.md
?????€??€ prompt.yaml
?????€??€ src/...

```
```
doc/
?????€??€ example.html
?????€??€ example.md
?????€??€ index.html
?????€??€ introduction.html
?????€??€ introduction.md
?????€??€ web.md

```
doc/index.html:
```
<!DOCTYPE html>
<html>
  <head>
    <meta charset=""UTF-8"">
    <title>Documentation</title>
  </head>
  <body>
    <h1>Welcome to our documentation!</h1>
    <p>Start with the <a href=""introduction.html"">introduction</a>.</p>
  </body>
</html>

```

doc/example.md:
```
# Example
This is an example of our documentation.

```

doc/example.html:
```
<h1>Example</h1>
<p>This is an example of our documentation.</p>

```

./README.md:
```
Warn: This README is AI generated, just like all the source files of this project.

# The Junior - Your AI contributor which writes itself.

## Description

The Contributor is an exploratory project aimed at revolutionizing the way programmers interact with the development process. Just like how Linus Torvalds oversees the Linux Kernel development without coding himself, this project allows developers to communicate with the AI and supervise the development process.

By providing specific task details in a prompt descriptor and highlighting the relevant parts of your project, you can delegate code implementation, documentation, testing, and more to your AI Contributor.

## Getting Started

### Installation

To install, clone the repository and run `npm install` in the root directory.

### Usage

There are two ways to use this project: a command-line interface (CLI) and a web interface.

#### Command-line interface (CLI)

To start the CLI, use `npm run cli`. This mode uses the ChatGPT API, and you'll need an API key stored in the `OPENAI_API_KEY` environment variable.

#### Web Interface

Run the application with `npm start` to start a local server on port 3000, where you can generate a prompt and automatically copy it to paste into ChatGPT. The web interface is designed for use with ChatGPT Pro and doesn't require an API key.

### The Prompt Descriptor

A prompt descriptor is a YAML file (`prompt.yaml`) outlining the details necessary for generating a task prompt for the AI model.

Here's an example of a prompt descriptor:

```yaml
task: prompt/task/feature/implement.md
attention:
  - src/interactiveSession/startInteractiveSession.js
  - src/prompt/createPrompt.js
  - src/attention/readAttention.js
  - prompt.yaml
requirements: >
  Write a README.md for this _exploratory_ project!
format: prompt/format/new_file_version.md
```

Each element in the descriptor serves a specific purpose:
- `task`: Describes the task type and scope. For example, `feature/implement`, `bug/fix`, or `refactor/`. You can check out the [prompt/task/feature/implement.md](prompt/task/feature/implement.md) file as an example.
- `attention`: Lists the files and directories most relevant to the task.
- `requirements`: Describes the actual task in a human-readable format.
- `format`: Determines how the output will be formatted.

### Attention Mechanism

The attention mechanism guides the AI model by providing it with a working set. It helps overcome the limited working memory of large language models.

The working set is a subset of the entire project that's currently in focus. It includes both files and directories. For files, the content is directly provided to the AI. For directories, a brief list of files and subdirectories within them is presented.

## Contributing and Support

Contributions are welcome! Remember, we eat our own dog food in this project. This project is designed to write itself. Your main role will be to oversee the work, provide detailed prompts, and review the outcomes.

For support, please create an issue in the GitHub repository.

**Note:** For meaningful results, it's recommended to use the GPT-4 model or a more recent version.
```


# Task

Improve the documentation!

Document the web interface in doc/web.md and npm run build:doc! Link it from index.html!
Read README.md carefully, but do not assume the reader knows it, and do not edit it!


&lt;/div&gt;&lt;/div&gt;&lt;button class=&#34;w-64 px-4 py-4 bg-blue-500 text-white rounded&#34;&gt;Generate &amp;amp; Copy Prompt&lt;/button&gt;&lt;details class=&#34;w-full max-w-screen overflow-x-auto whitespace-normal markdown&#34; style=&#34;display: none;&#34;&gt;&lt;summary&gt;prompt length: 0 chars&lt;/summary&gt;&lt;div&gt;&lt;/div&gt;&lt;/details&gt;&lt;button class=&#34;w-64 px-4 py-4 bg-orange-300 text-white rounded&#34;&gt;Paste &amp;amp; Execute Change&lt;/button&gt;&lt;div class=&#34;rounded overflow-auto max-w-full hidden&#34;&gt;&lt;div dir=&#34;ltr&#34; class=&#34;terminal xterm xterm-dom-renderer-owner-1&#34;&gt;&lt;div class=&#34;xterm-viewport&#34; style=&#34;background-color: rgb(0, 0, 0);&#34;&gt;&lt;div class=&#34;xterm-scroll-area&#34;&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;xterm-screen&#34; style=&#34;width: 0px; height: 0px;&#34;&gt;&lt;div class=&#34;xterm-helpers&#34;&gt;&lt;textarea class=&#34;xterm-helper-textarea&#34; aria-label=&#34;Terminal input&#34; aria-multiline=&#34;false&#34; autocorrect=&#34;off&#34; autocapitalize=&#34;off&#34; spellcheck=&#34;false&#34; tabindex=&#34;0&#34;&gt;&lt;/textarea&gt;&lt;span class=&#34;xterm-char-measure-element&#34; aria-hidden=&#34;true&#34; style=&#34;font-family: courier-new, courier, monospace; font-size: 15px;&#34;&gt;W&lt;/span&gt;&lt;div class=&#34;composition-view&#34;&gt;&lt;/div&gt;&lt;/div&gt;&lt;style&gt;.xterm-dom-renderer-owner-1 .xterm-rows span { display: inline-block; height: 100%; vertical-align: top; width: 0px}&lt;/style&gt;&lt;style&gt;.xterm-dom-renderer-owner-1 .xterm-rows { color: #ffffff; font-family: courier-new, courier, monospace; font-size: 15px;}.xterm-dom-renderer-owner-1 .xterm-rows .xterm-dim { color: #ffffff80;}.xterm-dom-renderer-owner-1 span:not(.xterm-bold) { font-weight: normal;}.xterm-dom-renderer-owner-1 span.xterm-bold { font-weight: bold;}.xterm-dom-renderer-owner-1 span.xterm-italic { font-style: italic;}@keyframes blink_box_shadow_1 { 50% {  box-shadow: none; }}@keyframes blink_block_1 { 0% {  background-color: #ffffff;  color: #000000; } 50% {  background-color: #000000;  color: #ffffff; }}.xterm-dom-renderer-owner-1 .xterm-rows:not(.xterm-focus) .xterm-cursor.xterm-cursor-block ,.xterm-dom-renderer-owner-1 .xterm-rows:not(.xterm-focus) .xterm-cursor.xterm-cursor-bar ,.xterm-dom-renderer-owner-1 .xterm-rows:not(.xterm-focus) .xterm-cursor.xterm-cursor-underline { outline: 1px solid #ffffff; outline-offset: -1px;}.xterm-dom-renderer-owner-1 .xterm-rows.xte #00000080; }.xterm-dom-renderer-owner-1 .xterm-bg-257 { background-color: #ffffff; }&lt;/style&gt;&lt;div class=&#34;xterm-rows&#34; aria-hidden=&#34;true&#34; style=&#34;line-height: normal;&#34;&gt;&lt;div style=&#34;width: 0px; height: 0px; line-height: 0px; overflow: hidden;&#34;&gt;&lt;span class=&#34;xterm-cursor xterm-cursor-block&#34;&gt; &lt;/span&gt;&lt;/div&gt;&lt;div class=&#34;xterm-decoration-container&#34;&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;pre class=&#34;rounded overflow-auto max-w-full block&#34;&gt; M prompt.md&lt;br&gt; M prompt.yaml&lt;br&gt;&lt;/pre&gt;&lt;button class=&#34;w-64 px-4 py-4 bg-red-700 text-white rounded&#34;&gt;Roll Back to Last Commit&lt;/button&gt;&lt;/div&gt;


# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, prefer heredoc-ing full files using 'EOF' to prevent substitution.

OS: OSX

Installed tools: npm, jq


Do NOT write any text outside the script!

EXAMPLE START

```sh
#!/bin/sh
set -e
goal=[Task description, max 7 words]
echo ""Plan:""
echo ""1. [...]""
[Commands solving the task]
echo ""\033[32mDone: $goal\033[0m\n""
```

EXAMPLE END

",80
"# Working set

src/init.js:
```
#!/usr/bin/env node
import { execSync } from 'child_process';
import { writeFileSync } from 'fs';
import { join } from 'path';
import { createGitignore } from './git/createGitignore.js';

function juniorInit() {
  execSync('git init', { stdio: 'inherit' });

  createGitignore();

  execSync('git add .gitignore', { stdio: 'inherit' });
  execSync('git commit -m ""Junior init""', { stdio: 'inherit' });

  const yamlContent = `task: prompt/task/feature/implement.md
attention:
  - ./
requirements: Create a Hello World in Node.js`;

  writeFileSync('prompt.yaml', yamlContent);

  console.log('\x1b[32mRepo initialized for Junior development\x1b[0m');
}

juniorInit();

```


# Task

Implement the following feature!

- Create a plan!
- Create new files when needed!

Requirements:

- Factor out prompt.yaml creation to src/prompt/createPromptYaml.js! - Also create and call src/prompt/createProjectSpecifics.js which creates ./prompt/projectSpecifics.md with the content &#34;## Project Specifics\n&#34;!


## Project Specifics

- Every js file should *only export a single function*!
- Use *ES6 imports*!
- Prefer *async/await* over promises!
- The frontend uses *Solidjs*, edit .jsx file accordingly


# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, prefer heredoc-ing full files using 'EOF' to prevent substitution.

OS: OSX

Installed tools: npm, jq


Do NOT write any text outside the script!

EXAMPLE START

```sh
#!/bin/sh
set -e
goal=[Task description, max 7 words]
echo ""Plan:""
echo ""1. [...]""
[Commands solving the task]
echo ""\033[32mDone: $goal\033[0m\n""
```

EXAMPLE END

",50
"# Working set

src/frontend/vite.config.js:
```
import { defineConfig } from 'vite'
import solidPlugin from 'vite-plugin-solid'

export default defineConfig({
  plugins: [solidPlugin()],
  css: {
    postcss: './src/frontend/postcss.config.cjs'
  },
  build: {
    target: 'esnext',
  },
})

```


# Task

Fix the following issue!

The postcss config path should be relative to the vite config file, not the working dir. Use dirname, they are in the same dir

# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, prefer heredoc-ing full files using 'EOF' to prevent substitution.

OS: OSX

Installed tools: npm, jq


Do NOT write any text outside the script!

EXAMPLE START

```sh
#!/bin/sh
set -e
goal=[Task description, max 7 words]
echo ""Plan:""
echo ""1. [...]""
[Commands solving the task]
echo ""\033[32mDone: $goal\033[0m\n""
```

EXAMPLE END

",85
"# Working set

src/git/gitStatus.js:
```
import { promisify } from 'util';
import { exec } from 'child_process';

const execAsync = promisify(exec);

export default async function gitStatus() {
  try {
    const { stdout, stderr } = await execAsync('git status');
    return stdout;
  } catch (error) {
    console.error(`exec error: ${error}`);
    throw error;
  }
}

```


# Task

Fix the following issue!

Add --porcelain=v1 when calling git status

# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, prefer heredoc-ing full files using 'EOF' to prevent substitution.

OS: OSX

Installed tools: npm, jq


Do NOT write any text outside the script!

EXAMPLE START

```sh
#!/bin/sh
set -e
goal=[Task description, max 7 words]
echo ""Plan:""
echo ""1. [...]""
[Commands solving the task]
echo ""\033[32mDone: $goal\033[0m\n""
```

EXAMPLE END

",85
"# Working set

src/frontend/components/GitStatusDisplay.jsx:
```
import { onMount, createEffect, onCleanup } from 'solid-js';
import { gitStatus, setGitStatus } from '../stores/gitStatus';
import { fetchGitStatus } from '../service/fetchGitStatus';

const GitStatusDisplay = () => {
  let statusContainer;

  onMount(async () => {
    const status = await fetchGitStatus();
    setGitStatus(status);
  });

  createEffect(() => {
    if (gitStatus() !== '') {
      statusContainer.innerText = gitStatus();
    }
  });

  onCleanup(() => {
    setGitStatus('');
  });

  return (
    <pre
      ref={statusContainer}
      class={`rounded overflow-auto max-w-full ${gitStatus() !== '' ? 'block' : 'hidden'}`}
    />
  );
};

export default GitStatusDisplay;

```


# Task

Fix the following issue!

gitStatus returns an object with status field.


# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, prefer heredoc-ing full files using 'EOF' to prevent substitution.

OS: OSX

Installed tools: npm, jq


Do NOT write any text outside the script!

EXAMPLE START

```sh
#!/bin/sh
set -e
goal=[Task description, max 7 words]
echo ""Plan:""
echo ""1. [...]""
[Commands solving the task]
echo ""\033[32mDone: $goal\033[0m\n""
```

EXAMPLE END

",70
"# Working set

src/frontend/components/ExecutionResultDisplay.jsx:
```
import { onMount, createEffect } from 'solid-js';
import { Terminal } from 'xterm';
import 'xterm/css/xterm.css';
import { executionResult } from '../stores/executionResult';

const ExecutionResultDisplay = () => {
  let container;
  let term;

  onMount(() => {
    term = new Terminal({ convertEol: true, rows: 7 });
    term.open(container);
  });

  createEffect(() => {
    if (term) {
 term.write(executionResult());
    }
  });

  return (
    <div ref={container} class=""rounded overflow-auto max-w-full""></div>
  );
};

export default ExecutionResultDisplay;

```


# Task

Fix the following issue!

Do not display the terminal when the execution result is empty.


# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, prefer heredoc-ing full files using 'EOF' to prevent substitution.
OS: Debian
Installed tools: npm, jq
Do NOT write any text outside the script!

EXAMPLE START

```sh
#!/bin/sh
set -e
goal=[Task description, max 7 words]
echo ""Plan:""
echo ""1. [...]""
[Commands solving the task]
echo ""\033[32mDone: $goal\033[0m\n""
```

EXAMPLE END

",80
"# Working set

src/frontend/App.jsx:
```
import NotesInput from './components/NotesInput';
import StartButton from './components/StartButton';
import ExecuteButton from './components/ExecuteButton';
import ResetButton from './components/ResetButton';
import PromptDisplay from './components/PromptDisplay';
import TasksList from './components/TasksList';
import PromptDescriptor from './components/PromptDescriptor';
import NavBar from './components/NavBar';
import { notes, setNotes } from './stores/notes';
import { setPrompt } from './stores/prompt';

const App = () => {
  return (
    <div class=""max-w-desktop lg:max-w-desktop md:max-w-full sm:max-w-full xs:max-w-full mx-auto flex flex-col items-center space-y-8 sm:p-0"">
      <NavBar />
      <TasksList />
      <PromptDescriptor />
      <NotesInput notes={notes} setNotes={setNotes} />
      <StartButton notes={notes} setPrompt={setPrompt} />
      <ExecuteButton />
      <ResetButton />
      <PromptDisplay />
    </div>
  );
};

export default App;

```

src/index.html:
```
<!DOCTYPE html>
<html lang=""en"">
<head>
  <meta charset=""UTF-8"">
  <meta name=""viewport"" content=""width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"">
  <title>Junior</title>
</head>
<body>
  <div id=""app""></div>
  <script type=""module"" src=""/frontend/index.jsx""></script>
</body>
</html>

```


# Task

Implement the following feature!

- Create a plan!
- Create new files when needed!
- Every js file should only export a single function!
- Use ES6 imports!

Requirements:

Add a small margin around the content using tailwind.



# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, prefer heredoc-ing full files without substitution.
Assume OSX.
npm and jq are installed.
Do NOT write any text outside the script (the plan goes into it)!


EXAMPLE START

```sh
#!/bin/sh
# Goal: [Task description, max 7 words]
# Plan:
# 1. [...]

[Commands solving the task]
```

EXAMPLE END

",80
"# Working set

./package.json:
```
{
  ""name"": ""@aijunior/dev"",
  ""version"": ""0.0.1"",
  ""description"": ""Your AI Contributor"",
  ""type"": ""module"",
  ""main"": ""src/main.js"",
  ""bin"": {
    ""junior"": ""src/main.js"",
    ""junior-web"": ""src/web.js""
  },
  ""scripts"": {
    ""cli"": ""node src/main.js"",
    ""start"": ""node src/web.js"",
    ""build:css"": ""postcss ./src/frontend/styles.css -o ./dist/styles.css"",
    ""build:docs"": ""node ./src/doc/buildDoc.js""
  },
  ""keywords"": [
    ""cli"",
    ""uppercase""
  ],
  ""author"": """",
  ""license"": ""GPL"",
  ""dependencies"": {
    ""chatgpt"": ""^5.2.4"",
    ""clipboard-copy"": ""^4.0.1"",
    ""cors"": ""^2.8.5"",
    ""ejs"": ""^3.1.9"",
    ""express"": ""^4.18.2"",
    ""js-yaml"": ""^4.1.0"",
    ""marked"": ""^5.1.0"",
    ""postcss-nested"": ""^6.0.1"",
    ""simple-git"": ""^3.19.1"",
    ""solid-js"": ""^1.7.7"",
    ""vite"": ""^4.3.9"",
    ""vite-plugin-solid"": ""^2.7.0"",
    ""ws"": ""^8.13.0""
  },
  ""directories"": {
    ""doc"": ""doc""
  },
  ""repository"": {
    ""type"": ""git"",
    ""url"": ""git+https://github.com/tisztamo/Junior.git""
  },
  ""bugs"": {
    ""url"": ""https://github.com/tisztamo/Junior/issues""
  },
  ""homepage"": ""https://github.com/tisztamo/Junior#readme"",
  ""devDependencies"": {
    ""@types/js-yaml"": ""^4.0.5"",
    ""autoprefixer"": ""^10.4.14"",
    ""babel-preset-solid"": ""^1.7.7"",
    ""highlight.js"": ""^11.8.0"",
    ""markdown-it"": ""^13.0.1"",
    ""postcss"": ""^8.4.26"",
    ""tailwindcss"": ""^3.3.3""
  }
}

```


# Task

Fix the following issue!

Rename build:docs to build:doc


# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, prefer heredoc-ing full files without substitution.
Assume OSX.
npm and jq are installed.
Do NOT write any text outside the script (the plan goes into it)!


EXAMPLE START

```sh
#!/bin/sh
# Goal: [Task description, max 7 words]
# Plan:
# 1. [...]

[Commands solving the task]
```

EXAMPLE END

",75
"# Working set

src/git/resetGit.js:
```
import git from 'simple-git';

export default async function resetGit() {
  const gitInstance = git();

  // Stash all changes including untracked files
  await gitInstance.stash(['-u']);

  // Clean the repository and reset to the latest commit
  await gitInstance.clean('f', ['-d']);
  await gitInstance.reset('hard');

  // Checkout only prompt.yaml from stash
  await gitInstance.checkout('stash@{0} -- prompt.yaml');

  // Drop the stash
  await gitInstance.stash(['drop']);
}

```


# Task

Fix the following issue!

Resetgit correctly deletes every new files,
and correctly reset other modified files,
but it fails to leave prompt.yaml untouched.
prompt.yaml should be excluded from the reset.


# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, prefer heredoc-ing full files without substitution.
Assume OSX.
npm and jq are installed.
Do NOT write any text outside the script (the plan goes into it)!


EXAMPLE START

```sh
#!/bin/sh
# Goal: [Task description, max 7 words]
# Plan:
# 1. [...]

[Commands solving the task]
```

EXAMPLE END

",46
"# Working set

src/prompt/loadPromptFile.js:
```
import fs from 'fs';
import path from 'path';
import ejs from 'ejs';
import { fileURLToPath } from 'url';

const __dirname = path.dirname(fileURLToPath(import.meta.url));

const loadPromptFile = async (filePath, templateVars) => {
  try {
    // Try to read the file relative to the current directory
    return await ejs.renderFile(filePath, templateVars, {async: true});
  } catch (err) {
    // If the file doesn't exist, try reading it from the project root directory
    const rootPath = path.resolve(__dirname, '../../', filePath);
    return await ejs.renderFile(rootPath, templateVars, {async: true});
  }
};

export { loadPromptFile };

```

src/prompt/createPrompt.js:
```
import { readAttention } from ""../attention/readAttention.js""
import yaml from 'js-yaml';
import { getSystemPromptIfNeeded } from './getSystemPromptIfNeeded.js';
import { resolveTemplateVariables } from './resolveTemplateVariables.js';
import { extractTemplateVars } from './extractTemplateVars.js';
import { loadPromptDescriptor } from './loadPromptDescriptor.js';
import { loadTaskTemplate } from './loadTaskTemplate.js';
import { loadFormatTemplate } from './loadFormatTemplate.js';

const createPrompt = async (userInput) => {
  const promptDescriptor = yaml.load(await loadPromptDescriptor());
  let templateVars = extractTemplateVars(promptDescriptor);

  templateVars = await resolveTemplateVariables(templateVars);

  const attention = await readAttention(promptDescriptor.attention);
  const task = await loadTaskTemplate(promptDescriptor.task, templateVars);
  const format = await loadFormatTemplate(promptDescriptor.format, templateVars);
  const system = await getSystemPromptIfNeeded();
  const saveto = promptDescriptor.saveto;
  return {
    prompt: `${system}# Working set\n\n${attention.join(""\n"")}\n\n# Task\n\n${task}\n\n# Output Format\n\n${format}\n\n${userInput ? userInput : """"}`,
    saveto
  };
}

export { createPrompt };

```

src/prompt/promptProcessing.js:
```
import { createPrompt } from './createPrompt.js';
import fs from 'fs/promises';

const processPrompt = async (task, last_command_result, saveto = 'prompt.md', parent_message_id = null) => {
  const { prompt, saveto: newSaveto } = await createPrompt(task, last_command_result);
  await fs.writeFile(newSaveto || saveto, prompt);
  return { prompt, parent_message_id };
}

export default processPrompt;

```

src/backend/generateHandler.js:
```
import processPrompt from '../prompt/promptProcessing.js';

export const generateHandler = async (req, res) => {
  const { notes } = req.body;
  const { prompt } = await processPrompt(notes);
  res.json({ prompt: prompt });
};

```

tailwind.config.js:
```
export default {
  content: ['./src/**/*.html', './src/**/*.js', './src/**/*.jsx', './src/**/*.tsx', './src/**/*.ts'],
  theme: {
    extend: {},
  },
  variants: {
    extend: {},
  },
  plugins: [],
}

```

src/prompt/loadPromptDescriptor.js:
```
import fs from 'fs';
import util from 'util';

const readFile = util.promisify(fs.readFile);
import { descriptorFileName } from ""./promptDescriptorConfig.js"";

const loadPromptDescriptor = async (rawPrinter) => {
  const descriptorContent = await readFile(descriptorFileName, 'utf8');
  if (rawPrinter) {
    rawPrinter(descriptorFileName + ':\n' + descriptorContent);
  }
  return descriptorContent;
};

export { loadPromptDescriptor };

```

src/prompt/loadFormatTemplate.js:
```
import { loadPromptFile } from './loadPromptFile.js';

const loadFormatTemplate = async (formatTemplatePath, templateVars) => {
  return await loadPromptFile(formatTemplatePath, templateVars);
};

export { loadFormatTemplate };

```


# Task

Fix the following issue!

node:internal/errors:477
  ErrorCaptureStackTrace(err);
  ^
TypeError [ERR_INVALID_ARG_TYPE]: The &#34;path&#34; argument must be of type string. Received undefined
  at new NodeError (node:internal/errors:388:5)
  at validateString (node:internal/validators:114:11)
  at Object.resolve (node:path:1098:7)
  at loadPromptFile (file:///Users/ko/projects-new/Junior/src/prompt/loadPromptFile.js:14:27)
  at async loadFormatTemplate (file:///Users/ko/projects-new/Junior/src/prompt/loadFormatTemplate.js:4:10)
  at async createPrompt (file:///Users/ko/projects-new/Junior/src/prompt/createPrompt.js:18:18)
  at async processPrompt (file:///Users/ko/projects-new/Junior/src/prompt/promptProcessing.js:5:41)
  at async generateHandler (file:///Users/ko/projects-new/Junior/src/backend/generateHandler.js:5:22) {


# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, prefer heredoc-ing full files without substitution.
Assume OSX.
npm and jq are installed.
Do NOT write any text outside the script (the plan goes into it)!


EXAMPLE START

```sh
#!/bin/sh
# Goal: [Task description, max 7 words]
# Plan:
# 1. [...]

[Commands solving the task]
```

EXAMPLE END

",60
"# Working set

src/frontend/App.jsx:
```
import { createSignal } from 'solid-js';
import NotesInput from './components/NotesInput';
import StartButton from './components/StartButton';
import PromptDisplay from './components/PromptDisplay';
import TasksList from './components/TasksList';

const App = () => {
  const [notes, setNotes] = createSignal('');
  const [prompt, setPrompt] = createSignal('');

  return (
    <>
      <NotesInput notes={notes} setNotes={setNotes} />
      <StartButton notes={notes} setPrompt={setPrompt} />
      <PromptDisplay prompt={prompt} />
      <TasksList />
    </>
  );
};

export default App;

```

src/frontend/components/TasksList.jsx:
```
import { createSignal, onCleanup, onMount } from 'solid-js';
import { fetchTasks } from '../fetchTasks';
import { handleTaskChange } from '../service/handleTaskChange';
import { fetchDescriptor } from '../service/fetchDescriptor';
import { parseYamlAndGetTask } from '../service/parseYamlAndGetTask';
import { useWebsocket } from '../service/useWebsocket';

const TasksList = () => {
  const tasks = fetchTasks();
  const [promptDescriptor, setPromptDescriptor] = createSignal('');
  const [selectedTask, setSelectedTask] = createSignal('');

  onMount(async () => {
    const text = await fetchDescriptor();
    const task = parseYamlAndGetTask(text);
    setPromptDescriptor(text);
    setSelectedTask(task);
  });

  useWebsocket(async (e) => {
    if (e.data === 'update') {
      const text = await fetchDescriptor();
      setPromptDescriptor(text);
    }
  });

  onCleanup(() => {
    setPromptDescriptor('');
  });

  return (
    <div>
      <label>Task:</label>
      <select value={selectedTask()} onChange={e => handleTaskChange(e, setPromptDescriptor)}>
        {tasks().map(task => <option value={task}>{task}</option>)}
      </select>
      <pre>{promptDescriptor()}</pre>
    </div>
  );
};

export default TasksList;

```


# Task

Refactor!

Create a dir &#34;src/frontend/stores&#34; and move all the signals and stores there. Create separate files for each signal and store.


# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, prefer heredoc-ing full files without substitution.
Assume OSX.
npm and jq are installed.
Do NOT write any text outside the script (the plan goes into it)!


EXAMPLE START

```sh
#!/bin/sh
# Goal: [Task description, max 7 words]
# Plan:
# 1. [...]

[Commands solving the task]
```

EXAMPLE END

",70
"# Working set

```
./
?????€??€ .DS_Store
?????€??€ .git/...
?????€??€ .gitignore
?????€??€ README.md
?????€??€ babel.config.js
?????€??€ change.sh
?????€??€ doc/...
?????€??€ integrations/...
?????€??€ node_modules/...
?????€??€ package-lock.json
?????€??€ package.json
?????€??€ prompt/...
?????€??€ prompt.md
?????€??€ prompt.yaml
?????€??€ secret.sh
?????€??€ src/...

```
```
integrations/vscode/
?????€??€ .eslintrc.json
?????€??€ .gitignore
?????€??€ .vscode/...
?????€??€ .vscodeignore
?????€??€ CHANGELOG.md
?????€??€ README.md
?????€??€ node_modules/...
?????€??€ out/...
?????€??€ package-lock.json
?????€??€ package.json
?????€??€ src/...
?????€??€ tsconfig.json
?????€??€ vsc-extension-quickstart.md

```
integrations/vscode/src/writeAttention.ts:
```
import * as vscode from 'vscode';
import * as fs from 'fs';
import * as path from 'path';
import * as yaml from 'js-yaml';
import { filterAttentionExcludes } from './filterAttentionExcludes';

export const writeAttention = async () => {
    const workspaceFolders = vscode.workspace.workspaceFolders;
    if (workspaceFolders === undefined) {
        return;
    }
    
    const rootFolder = workspaceFolders[0].uri.fsPath;
    const promptFilePath = path.join(rootFolder, 'prompt.yaml');
    const excludeList = vscode.workspace.getConfiguration('junior').get('attentionExcludeList', []);
    try {
        if (fs.existsSync(promptFilePath)) {
            const currentWindows = vscode.workspace.textDocuments.map(doc => path.relative(rootFolder, doc.fileName));
            const filteredWindows = filterAttentionExcludes(currentWindows, excludeList, rootFolder);
            const promptFile: any = yaml.load(fs.readFileSync(promptFilePath, 'utf8'));
            promptFile.attention = filteredWindows;
            fs.writeFileSync(promptFilePath, yaml.dump(promptFile), 'utf8');
            vscode.window.showInformationMessage('Prompt file updated successfully!');
        } else {
            vscode.window.showErrorMessage('No prompt.yaml file found in the project root!');
        }
    } catch (error) {
        vscode.window.showErrorMessage('Error updating the prompt.yaml file!');
    }
};

```

integrations/vscode/src/filterAttentionExcludes.ts:
```
import * as glob from 'glob';
import * as path from 'path';
import * as fs from 'fs';

export const filterAttentionExcludes = (windowPaths: string[], excludeList: string[], rootFolder: string) => {
    return windowPaths.filter(windowPath => {
        return !windowPath.endsWith('.git') && windowPath !== 'prompt.yaml' && windowPath !== 'prompt.md' && windowPath !== 'change.sh' && !excludeList.some((pattern) => glob.sync(pattern, { cwd: rootFolder }).includes(windowPath)) && fs.existsSync(path.join(rootFolder, windowPath));
    });
}

```

README.md:
```
Warn: This README is AI generated, just like all the source files of this project.

# The Junior - Your AI contributor which writes itself.

## Description

The Contributor is an exploratory project aimed at revolutionizing the way programmers interact with the development process. Just like how Linus Torvalds oversees the Linux Kernel development without coding himself, this project allows developers to communicate with the AI and supervise the development process.

By providing specific task details in a prompt descriptor and highlighting the relevant parts of your project, you can delegate code implementation, documentation, testing, and more to your AI Contributor.

## Getting Started

### Installation

To install, clone the repository and run `npm install` in the root directory.

### Usage

There are two ways to use this project: a command-line interface (CLI) and a web interface.

#### Command-line interface (CLI)

To start the CLI, use `npm run cli`. This mode uses the ChatGPT API, and you'll need an API key stored in the `OPENAI_API_KEY` environment variable.

#### Web Interface

Run the application with `npm start` to start a local server on port 3000, where you can generate a prompt and automatically copy it to paste into ChatGPT. The web interface is designed for use with ChatGPT Pro and doesn't require an API key.

### The Prompt Descriptor

A prompt descriptor is a YAML file (`prompt.yaml`) outlining the details necessary for generating a task prompt for the AI model.

Here's an example of a prompt descriptor:

```yaml
task: prompt/task/feature/implement.md
attention:
  - src/interactiveSession/startInteractiveSession.js
  - src/prompt/createPrompt.js
  - src/attention/readAttention.js
  - prompt.yaml
requirements: >
  Write a README.md for this _exploratory_ project!
format: prompt/format/new_file_version.md
```

Each element in the descriptor serves a specific purpose:
- `task`: Describes the task type and scope. For example, `feature/implement`, `bug/fix`, or `refactor/`. You can check out the [prompt/task/feature/implement.md](prompt/task/feature/implement.md) file as an example.
- `attention`: Lists the files and directories most relevant to the task.
- `requirements`: Describes the actual task in a human-readable format.
- `format`: Determines how the output will be formatted.

### Attention Mechanism

The attention mechanism guides the AI model by providing it with a working set. It helps overcome the limited working memory of large language models.

The working set is a subset of the entire project that's currently in focus. It includes both files and directories. For files, the content is directly provided to the AI. For directories, a brief list of files and subdirectories within them is presented.

## Contributing and Support

Contributions are welcome! Remember, we eat our own dog food in this project. This project is designed to write itself. Your main role will be to oversee the work, provide detailed prompts, and review the outcomes.

For support, please create an issue in the GitHub repository.

**Note:** For meaningful results, it's recommended to use the GPT-4 model or a more recent version.
```


# Task

Improve the documentation!

We need a readme for the vscode extension, which is part of the Junior project. Write it to be catchy and to include relevant info about the project (based on the project readme).
Mention that the extension and its doc was fully generated by ChatGPT!
Features: 
  - The &#34;Write Attention&#34; junior.writeAttention command overwrites the attention descriptor based on the currently opened windows in vscode.
  - configuration is possible (extract relevant info from the code)


# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, prefer heredoc-ing full files without substitution.
Assume OSX.
npm and jq are installed.
Do NOT write any text outside the script (the plan goes into it)!


EXAMPLE START

```sh
#!/bin/sh
# Goal: [Task description, max 7 words]
# Plan:
# 1. [...]

[Commands solving the task]
```

EXAMPLE END

",75
"You're the 'Contributor', an AI system aiding authors.

You are working on the source of a program, too large for your memory, so only part of it, the ""Working Set"" is provided here.

You will see a partial directory structure. Ask for the contents of subdirs marked with /... if needed.

Some files are printed in the working set.

Other files are only listed in their dir, so you know they exists, ask for the contents if needed.

# Working set

src/attention/filesystem.js:
import fs from 'fs'
import path from 'path'
import util from 'util'

const readFile = util.promisify(fs.readFile)

export const processFile = async (root, p) => {
  const fullPath = path.join(root, p)
  try {
    const content = await readFile(fullPath, ""utf8"")
    return `${p}:\n${content}\n`
  } catch (error) {
    return `${p}: err!\n`
  }
}



# Task

Implement the following feature!

- Write a plan first, only implement after the plan is ready!
- Create new files when needed!
- Every js js file should only export a single function!

Requirements:

When printing the contents of a file in the attention, use markdown code blocks. E.g.: dir/sample.txt: ``` This is the contents of the file. ``` Also find a better name for filesystem.js!



# Output Format

Provide the new or modified file(s) as code blocks, each prefixed with its path and a colon.
Always output full files, copying unchanged content.

E.g.:

texts/sample.txt:
```
A sample text file.
```


",90
"You're the 'Contributor', an AI system aiding authors.

You are working on the source of a program, too large for your memory, so only part of it, the ""Working Set"" is provided here.

Some files are printed in the working set.

Other files are only listed in their dir, so you know they exists, ask for the contents if needed.

The contents of some dirs are not listed, ask for their content if needed.

# Working set

src/:
attention, config.js, execute, interactiveSession, main.js, prompt, utils

src/prompt/createPrompt.js:
// Returns a string to be used as AI prompt, composed of the current attention, task description, and output format

import { readAttention } from ""../attention/readAttention.js""
import fs from 'fs';
import util from 'util';
import yaml from 'js-yaml';
import { getSystemPrompt } from ""../config.js"";
const readFile = util.promisify(fs.readFile);

// Get the value of the --prompt flag, if it exists
function getPromptFlag() {
  const promptFlag = process.argv.find(arg => arg.startsWith(""--prompt=""));
  if (promptFlag) {
    return promptFlag.split(""="")[1];
  }
}

// return the system prompt if the --system-prompt or -s flag is present
async function getSystemPromptIfNeeded() {
  if (process.argv.includes(""--system-prompt"") || process.argv.includes(""-s"")) {
    return `${await getSystemPrompt()}\n`;
  }
  return """";
}

const createPrompt = async (userInput) => {
  const promptDescriptor = yaml.load(await readFile(getPromptFlag() || ""prompt/prompt-list.yaml"", ""utf8""));  
  const attention = await readAttention(promptDescriptor.attention);
  const task = await readFile(promptDescriptor.task, ""utf8"");
  const format = await readFile(promptDescriptor.format, ""utf8"");
  const system = await getSystemPromptIfNeeded();
  const saveto = promptDescriptor.saveto;
  return {
    prompt: `${system}# Working set\n\n${attention}\n\n# Task\n\n${task}\n\n# Output Format\n\n${format}\n\n${userInput ? userInput : """"}`,
    saveto
  };
}

export { createPrompt };

src/attention/readAttention.js:
import fs from 'fs';
import path from 'path';
import util from 'util';
import { processPath } from './filesystem.js';
import { processInterfaceSection } from './processInterfaceSection.js';

const readFile = util.promisify(fs.readFile);

export const readAttention = async (attentionFilePath = ""prompt/attention.txt"", attentionRootDir = '.') => {
  try {
    const data = await readFile(path.join(attentionRootDir, attentionFilePath), ""utf8"");
    const lines = data.split(""\n"");
    const processedLines = await Promise.all(lines.map(line => {
      const trimmedLine = line.trim();
      if (trimmedLine.endsWith(' iface')) {
        const filePath = trimmedLine.slice(0, -6).trim();
        return processInterfaceSection(attentionRootDir, filePath);
      } else {
        return processPath(attentionRootDir, trimmedLine);
      }
    }));
    return processedLines.join(""\n"");
  } catch (error) {
    console.warn(error);
    throw new Error(""Attention file is missing or unreadable!"");
  }
};



# Task

Implement the following feature!

- Write a small synopsis about the implementation!
- Create new files when needed!
- When a file is larger than 25 lines or can be splitted logically, split it!

# Output Format

Provide the new file(s) as code blocks, each prefixed with its path and a colon.
Avoid any explanatory text, as your output will be programmatically processed!

The use of attention.txt should be eliminated. Instead of reading the attention from this external file, include its line as an array in the prompt descriptor yaml file.",30
"You are AI Junior, you code like Donald Knuth.

# Working set

./src/frontend/service/terminal/setupXTerm.js:
```
import { Terminal } from 'xterm';
import { FitAddon } from 'xterm-addon-fit';

export function setupXTerm() {
  const term = new Terminal();
  const fitAddon = new FitAddon();
  term.loadAddon(fitAddon);
  
  return { term, fitAddon };
}

```
./src/frontend/components/terminal/TerminalComponent.jsx:
```
import { onCleanup, onMount } from 'solid-js';
import 'xterm/css/xterm.css';
import terminalConnection from '../../service/terminal/terminalConnection';
import { setupXTerm } from '../../service/terminal/setupXTerm';
import DetailsComponent from '../DetailsComponent';

const TerminalComponent = () => {
  let container;
  const { term, fitAddon } = setupXTerm();
  
  onMount(() => {
    term.open(container);
    fitAddon.fit();

    terminalConnection.setOnDataReceived((data) => {
      term.write(data);
    });

    term.onData((data) => {
      terminalConnection.sendDataToTerminal(data);
    });
  });
  
  // Ensure terminal instance gets destroyed and WebSocket connection gets closed on component cleanup
  onCleanup(() => {
    term.dispose();
    terminalConnection.closeConnection();
  });

  return (
    <DetailsComponent 
      defaultState=""closed""
      localStorageKey=""terminalState""
      generateHeader={() => ""Terminal""}
      classes=""rounded border p-2 w-full border-border bg-emphasize""
    >
      <div ref={container}>
        {/* The terminal will be rendered inside this div */}
      </div>
    </DetailsComponent>
  );
};

export default TerminalComponent;

```
./src/backend/terminal/setupTerminalServer.js:
```
import os from 'os';
import pty from 'node-pty';

export default function setupTerminalServer(socket) {
  const defaultShell = process.env.SHELL || '/bin/sh';
  const shell = os.platform() === 'win32' ? 'powershell.exe' : defaultShell;
  const terminal = pty.spawn(shell, [], {
    name: 'xterm-color',
    env: process.env,
  });

  socket.on('message', (data) => {
    terminal.write(data);
  });

  terminal.on('data', (data) => {
    socket.send(data);
  });

  terminal.on('exit', () => {
    socket.close();
  });
}

```
./src/frontend/service/terminal/terminalConnection.js:
```
import { createWebSocket } from '../createWebSocket';

const socket = createWebSocket('/terminal');

const sendDataToTerminal = (data) => {
  if (socket.readyState === WebSocket.OPEN) {
    socket.send(data);
  }
};

const setOnDataReceived = (callback) => {
  socket.onmessage = (event) => {
    callback(event.data);
  };
};

const closeConnection = () => {
  if (socket.readyState === WebSocket.OPEN) {
    socket.close();
  }
};

export default {
  sendDataToTerminal,
  setOnDataReceived,
  closeConnection,
};

```

# Task

Implement the following feature!

- Create a plan!
- Create new files when needed!

Requirements:

We set the terminal size to fit the width of the container element. However, the shell running inside is not notified. How to do it?


## Project Specifics

- Every js file should *only export a single function or signal*! eg.: in createGitRepo.js: export function createGitRepo ( ....
- Use *ES6 imports*!
- Prefer *async/await* over promises!
- The frontend uses *Solidjs* and Tailwind, edit .jsx files accordingly!

# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, avoid using sed in favor of heredoc-ing full files.

OS: Debian


Installed tools: npm, jq


Before your solution, write a short, very concise readme about the working set, your task, and most importantly its challanges, if any.


EXAMPLE START
```sh
#!/bin/sh
set -e
goal=[Task description, max 9 words]
echo ""Plan:""
echo ""1. [...]""
cat > x.js << 'EOF'
[...]
'EOF'
echo ""\033[32mDone: $goal\033[0m\n""
```
EXAMPLE END

Before starting, check if you need more files or info to solve the task.

If the task is not clear:

EXAMPLE START
I need more information to solve the task. [Description of the missing info]
EXAMPLE END

Do not edit files not provided in the working set!
If you need more files:

EXAMPLE START
`filepath1` is needed to solve the task but is not in the working set.
EXAMPLE END

",78
"You are AI Junior, you code like Donald Knuth.
# Working set

./src/frontend/components/CommitMessageInput.jsx:
```
import { commitMessage, setCommitMessage } from '../model/commitMessage';
import monitorChange from '../model/monitorChange';
import handleCommitService from '../service/lifecycle/handleCommitService';

const CommitMessageInput = () => {
  monitorChange();

  const handleChange = (e) => {
    setCommitMessage(e.target.value);
  };

  const handleKeyPress = (e) => {
    if(e.key === 'Enter') {
      handleCommitService();
    }
  }

  return (
    <input type=""text"" className=""w-full px-4 py-2 border rounded bg-emphasize text-emphasize border-border"" placeholder=""Commit message..."" value={commitMessage()} onInput={handleChange} onKeyPress={handleKeyPress} />
  );
};

export default CommitMessageInput;

```

./src/frontend/components/ChangeFinalization.jsx:
```
import CommitMessageInput from './CommitMessageInput';
import ProofInput from './ProofInput';
import CommitButton from './CommitButton';
import RollbackButton from './RollbackButton';

const ChangeFinalization = () => {
  return (
    <>
      <div className=""flex w-full space-x-4"">
        <CommitMessageInput className=""flex-grow w-7/10"" />
        <ProofInput className=""w-3/10"" />
      </div>
      <div className=""flex w-full mt-1 space-x-4"">
        <RollbackButton />
        <CommitButton />
      </div>
    </>
  );
};

export default ChangeFinalization;

```


# Task

Fix the following issue!

The Proof should take 30% only, but it fails to do that. The two are 50-50.


## Project Specifics

- Every js file should *only export a single function or signal, as default*! eg.: in createGitRepo.js: export default function createGitRepo ( ....
- Use *ES6 imports*!
- Prefer *async/await* over promises!
- The frontend uses *Solidjs* and Tailwind, edit .jsx files accordingly!

# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, avoid using sed in favor of heredoc-ing full files.

OS: OSX

Installed tools: npm, jq


Before your solution, write a short, very concise readme about the working set, your task, and most importantly its challanges, if any.


EXAMPLE START
```sh
#!/bin/sh
set -e
goal=[Task description, max 9 words]
echo ""Plan:""
echo ""1. [...]""
cat > x.js << 'EOF'
[...]
'EOF'
echo ""\033[32mDone: $goal\033[0m\n""
```
EXAMPLE END

Before starting, check if you need more files or info to solve the task.

If the task is not clear:

EXAMPLE START
I need more information to solve the task. [Description of the missing info]
EXAMPLE END

Do not edit files not provided in the working set!
If you need more files:

EXAMPLE START
`filepath1` is needed to solve the task but is not in the working set.
EXAMPLE END


",79
"# Working set

```
./
?????€??€ .DS_Store
?????€??€ .git/...
?????€??€ .github/...
?????€??€ .gitignore
?????€??€ .vscode/...
?????€??€ README.md
?????€??€ change.sh
?????€??€ docs/...
?????€??€ integrations/...
?????€??€ node_modules/...
?????€??€ package-lock.json
?????€??€ package.json
?????€??€ prompt/...
?????€??€ prompt.md
?????€??€ prompt.yaml
?????€??€ src/...

```

# Task

Fix the following issue!

clean install gives: npm ERR! notarget No matching version found for docsify-cli@^4.4.7. #35
pbharrin opened this issue 3 hours ago ?? 3 comments
Comments
pbharrin commented 3 hours ago
A clean install gives me the following error:
npm ERR! notarget No matching version found for docsify-cli@^4.4.7.

Running npm view docsify-cli versions
returns
[ &#39;0.1.0&#39;, &#39;0.2.1&#39;,  &#39;0.2.2&#39;,  &#39;1.0.0&#39;,  &#39;1.1.0&#39;, &#39;1.1.1&#39;, &#39;1.2.0&#39;,  &#39;1.2.1&#39;,  &#39;1.3.0&#39;,  &#39;1.4.0&#39;, &#39;1.5.0&#39;, &#39;1.5.1&#39;,  &#39;2.0.0&#39;,  &#39;2.1.0&#39;,  &#39;3.0.0&#39;, &#39;3.0.1&#39;, &#39;3.0.2&#39;,  &#39;3.1.0&#39;,  &#39;3.1.1&#39;,  &#39;3.2.0&#39;, &#39;3.2.1&#39;, &#39;3.2.2&#39;,  &#39;3.2.3&#39;,  &#39;3.2.4&#39;,  &#39;3.2.5&#39;, &#39;3.3.0&#39;, &#39;3.3.1&#39;,  &#39;3.3.2&#39;,  &#39;4.0.0&#39;,  &#39;4.0.1&#39;, &#39;4.0.2&#39;, &#39;4.1.0&#39;,  &#39;4.1.1&#39;,  &#39;4.1.2&#39;,  &#39;4.1.3&#39;, &#39;4.1.4&#39;, &#39;4.1.5&#39;,  &#39;4.1.6&#39;,  &#39;4.1.7&#39;,  &#39;4.1.8&#39;, &#39;4.1.9&#39;, &#39;4.1.10&#39;, &#39;4.1.11&#39;, &#39;4.1.12&#39;, &#39;4.2.0&#39;, &#39;4.2.1&#39;, &#39;4.3.0&#39;,  &#39;4.4.0&#39;,  &#39;4.4.1&#39;,  &#39;4.4.2&#39;, &#39;4.4.3&#39;, &#39;4.4.4&#39; ]

No version 4.4.7 has been published.

@pbharrin
Tip
Author
pbharrin commented 3 hours ago
I also looked into the source of docsify-cli and could not find a 4.4.7.

@tisztamo
Tip
Owner
tisztamo commented 3 hours ago
Uh, it was added today, I will check it soon but currently on mobile. Try to go back a few commits please!

@tisztamo
Tip
Owner
tisztamo commented 3 hours ago
Found the cause here:
https://chat.openai.com/share/937d8682-300c-4e1f-84e5-607425cc4b21

I asked gpt both to install docsify-cli and also to edit package.json by heredocing the full file, in the same script. So it guessed the version in order to not loose the newly installed dep.


# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, avoid using sed in favor of heredoc-ing full files using 'EOF' to prevent substitution.

OS: OSX

Installed tools: npm, jq


Do NOT write any text outside the script!

EXAMPLE START

```sh
#!/bin/sh
set -e
goal=[Task description, max 7 words]
echo ""Plan:""
echo ""1. [...]""
[Commands solving the task]
echo ""\033[32mDone: $goal\033[0m\n""
```

EXAMPLE END

",80
"# Working set

```
./
?????€??€ .DS_Store
?????€??€ .git/...
?????€??€ .github/...
?????€??€ .gitignore
?????€??€ README.md
?????€??€ babel.config.js
?????€??€ change.sh
?????€??€ doc/...
?????€??€ integrations/...
?????€??€ node_modules/...
?????€??€ package-lock.json
?????€??€ package.json
?????€??€ postcss.config.js
?????€??€ prompt/...
?????€??€ prompt.md
?????€??€ prompt.yaml
?????€??€ secret.sh
?????€??€ src/...
?????€??€ tailwind.config.js

```
```
./doc/
?????€??€ .nojekyll
?????€??€ api/...
?????€??€ buildDoc.js
?????€??€ convertDirectory.js
?????€??€ createMarkdownRenderer.js
?????€??€ example.html
?????€??€ example.md
?????€??€ examples/...
?????€??€ getting-started/...
?????€??€ index.html
?????€??€ introduction.html
?????€??€ introduction.md

```
```
./src/
?????€??€ .DS_Store
?????€??€ attention/...
?????€??€ backend/...
?????€??€ config.js
?????€??€ execute/...
?????€??€ frontend/...
?????€??€ git/...
?????€??€ index.html
?????€??€ interactiveSession/...
?????€??€ main.js
?????€??€ prompt/...
?????€??€ startVite.js
?????€??€ vite.config.js
?????€??€ web.js

```
doc/buildDoc.js:
```
import createMarkdownRenderer from './createMarkdownRenderer';
import convertDirectory from './convertDirectory';

const md = createMarkdownRenderer();
convertDirectory('./doc', md);

```

doc/convertDirectory.js:
```
import { readFileSync, writeFileSync, readdirSync, statSync } from 'fs';
import { join, extname } from 'path';
import createMarkdownRenderer from './createMarkdownRenderer';

export default function convertDirectory(dir, md = createMarkdownRenderer()) {
    const files = readdirSync(dir);
    files.forEach(file => {
        const filePath = join(dir, file);
        const stats = statSync(filePath);
        if (stats.isDirectory()) {
            convertDirectory(filePath, md);
        } else if (extname(file) === '.md') {
            const markdown = readFileSync(filePath, 'utf8');
            const html = md.render(markdown);
            writeFileSync(filePath.replace('.md', '.html'), html);
        }
    });
}

```

doc/createMarkdownRenderer.js:
```
import MarkdownIt from 'markdown-it';
import hljs from 'highlight.js';

export default function createMarkdownRenderer() {
    return new MarkdownIt({
        html: true,
        linkify: true,
        typographer: true,
        highlight: function (str, lang) {
            if (lang && hljs.getLanguage(lang)) {
                try {
                    return hljs.highlight(str, { language: lang }).value;
                } catch (__) {}
            }
            return ''; 
        }
    });
}

```


# Task

Move the following files to the specified target dirs!

Find out the best target dir if it is not specified!

You need to follow dependencies to maintain coherence.

Before executing, write a concise plan! The plan should show:
 - How do you avoid breaking other parts of the code.
 - If you had to choose, your way of thinking.

Move every .js file from doc to src/doc
update the line
&#34;build:docs&#34;: &#34;node ./doc/build.js&#34; 
in package.json accordingly


# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, prefer heredoc-ing full files without substitution.
Assume OSX.
npm and jq are installed.
Do NOT write any text outside the script (the plan goes into it)!


EXAMPLE START

```sh
#!/bin/sh
# Goal: [Task description, max 7 words]
# Plan:
# 1. [...]

[Commands solving the task]
```

EXAMPLE END

",76
"# Working set

```
./
?????€??€ .DS_Store
?????€??€ .git/...
?????€??€ .github/...
?????€??€ .gitignore
?????€??€ README.md
?????€??€ babel.config.js
?????€??€ change.sh
?????€??€ doc/...
?????€??€ integrations/...
?????€??€ node_modules/...
?????€??€ package-lock.json
?????€??€ package.json
?????€??€ postcss.config.js
?????€??€ prompt/...
?????€??€ prompt.md
?????€??€ prompt.yaml
?????€??€ secret.sh
?????€??€ src/...
?????€??€ tailwind.config.js

```
./doc: err!

./doc/build.js:
```
import { readFileSync, writeFileSync, readdirSync, statSync } from 'fs';
import { join, extname } from 'path';
import MarkdownIt from 'markdown-it';
import hljs from 'highlight.js';

const md = new MarkdownIt({
  html: true,
  linkify: true,
  typographer: true,
  highlight: function (str, lang) {
    if (lang && hljs.getLanguage(lang)) {
      try {
        return hljs.highlight(str, { language: lang }).value;
      } catch (__) {}
    }
    return ''; 
  }
});

const convertDirectory = (dir) => {
  const files = readdirSync(dir);
  files.forEach(file => {
    const filePath = join(dir, file);
    const stats = statSync(filePath);
    if (stats.isDirectory()) {
      convertDirectory(filePath);
    } else if (extname(file) === '.md') {
      const markdown = readFileSync(filePath, 'utf8');
      const html = md.render(markdown);
      writeFileSync(filePath.replace('.md', '.html'), html);
    }
  });
}

convertDirectory('./doc');

```


# Task

Fix the following issue!

Rename build.js dor buildDoc.js
Factor the md = new MarkdownIt creation to createMarkdownRenderer.js
Similarly create convertDirectory.js


# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, prefer heredoc-ing full files without substitution.
Assume OSX.
npm and jq are installed.
Do NOT write any text outside the script (the plan goes into it)!


EXAMPLE START

```sh
#!/bin/sh
# Goal: [Task description, max 7 words]
# Plan:
# 1. [...]

[Commands solving the task]
```

EXAMPLE END

",60
"How could I improve these bullet points to make them more concise and readable?
""

    Configured hotspot starts automatically on boot, no extra configuration necessary

    Configured WiFi network is WPA encrypted.

    Default SSID of ""RaspberryPiFi"" and WPA key of ""0123456789A"" can be modified during install

    Once set up, the local network facilites of the Pi will still operate as normal

    Easy setup of either a custom or preconfigured DNS server (including unblock-us for removing netflix geoblocks)

    Router enumeration for WiFi network

    Allows chromecast compatibility with unblock-us by intercepting google's DNS requests on the pi""",97
"Refactor given component using functional components and hooks. 
Please show all the lines so that I don't need to add anything myself.

import React from 'react';

import style from './Timeline.module.scss';

class Timeline extends React.Component {
    render() {
        const steps = this.props.steps;
        const currentStep = this.props.currentStep;
        return (
            <ul className={style.Timeline}>
                {steps.map((step, index) => {
                    const stepClasses = [style.Timeline_item];
                    
                    if(index + 1 < currentStep) {
                        stepClasses.push(style.Timeline_item__completed);
                    } else if(currentStep === index + 1) {
                        stepClasses.push(style.Timeline_item__current);
                    }

                    return (
                        <li className={stepClasses.join(' ')} key={index}>
                            <div className={style.Timeline_item_circle}></div>
                            <span className={style.Timeline_item_text}>{step}</span>
                        </li>
                    )
                })}
            </ul>
        );
    }
}

export default Timeline;",100
cn in tailwind,45
"Why is my redirect not working? Here is my client side code
DOM.btnSubmitPlugin.addEventListener(""click"", async () => {
    const pluginData = {
        name: DOM.inputPluginName.value,
        creator: DOM.inputPluginCreator.value,
        currentVersion: DOM.inputPluginVersion.value,
        latestVersion: radioValuetoBoolean().version,
        isNetworkActive: radioValuetoBoolean().network,
    };
    // console.log(pluginData);

    try {
        const response = await fetch(""/plugins"", {
            method: ""POST"",
            headers: {
                ""Content-Type"": ""application/json"",
            },
            body: JSON.stringify(pluginData),
        });

        if (response.ok) {
            console.log(""Data sent to server"");
        } else {
            const errorData = await response.json();
            throw errorData;
        }
    } catch (e) {
        console.error(e.error);
    } finally {
       
    }
});

And here is my relevant server-side code
router.post(""/"", async (request, response) => {
    const plugin = new Plugin({
        name: request.body.name,
        creator: request.body.creator,
        currentVersion: request.body.currentVersion,
        latestVersion: request.body.latestVersion,
        isNetworkActive: request.body.isNetworkActive,
        sitesActivated: request.body.sitesActivated,
    });

    console.log(plugin);

    try {
        await Plugin.create(plugin);
        return response.redirect(`/plugins/${plugin._id}`);
    } catch (error) {
        console.error(error);
    }
});

Everything else works as intended, except that it will not redirect. What is the issue here?
",50
what are a list of python and tkinter tools i can use when making a gui that can be used to display and play Tic Tac Toe,90
"Getting this error in the browser
caught SyntaxError: Unexpected token 'export' - game.js: 1


game.js
export default class Game {
    constructor() {
        this.user = this.getUser();
        this.initialize();
    }

    startPlaying() {
        var rikishi = document.querySelector('#rikishi').value;
        var picks = this.getPicks();
        var message = ""You selected: "" + rikishi + ""\nPrevious Picks: "" + JSON.stringify(picks);
        this.updatePicks(rikishi); // Update the picks with the new selection
        return message;
    }

    getUser() {
        // get user from local storage
        var user = localStorage.getItem('user');
        if (!user) {
            user = 'admin';
            localStorage.setItem('user', user);
        }
        return user;
    }

    getPicks() {
        var picks = JSON.parse(localStorage.getItem(this.user));
        if (!picks) {
            picks = {};
        }
        return picks;
    }

    updatePicks(rikishi) {
        var picks = this.getPicks();
        var currentContest = new Date().getMonth();
        if ([0, 2, 4, 6, 8, 10].includes(currentContest)) {
            var contestName = new Date().toLocaleString('default', { month: 'long' }) + ' ' + new Date().getFullYear();
            picks[contestName] = rikishi;
            localStorage.setItem(this.user, JSON.stringify(picks));
        }
    }

    switchUser() {
        var newUser = document.querySelector('#userSwitch').value;
        localStorage.setItem('user', newUser);
        document.querySelector('#user').textContent = 'Current user: ' + newUser;
        this.user = newUser;
    }

    backfillResults() {
        var contestName = document.querySelector('#backfillContest').value;
        var rikishi = document.querySelector('#backfillRikishi').value;
        var picks = this.getPicks();
        picks[contestName] = rikishi;
        localStorage.setItem(this.user, JSON.stringify(picks));
    }

    initialize() {
        var userElement = document.querySelector('#user');
        if (userElement) {
            userElement.textContent = 'Current user: ' + this.user;
        }
    }
}

function initGame() {
  const game = new Game();

  document.querySelector(""#startPlayingButton"").addEventListener('click', () => game.startPlaying());
  document.querySelector(""#switchUserButton"").addEventListener('click', () => game.switchUser());
  document.querySelector(""#backfillResultsButton"").addEventListener('click', () => game.backfillResults());
}

if (typeof window !== 'undefined') {
    window.onload = initGame;
}",91
"I have these files (below) but I can't run the unit test. Set up the files I need to run the unit test.

index.html
<!DOCTYPE html>
<html>
<head>
    <title>Banzuke Surfing Game</title>
    <script src=""https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js""></script>
    <!-- Link to the external CSS file -->
    <!-- Uncomment this if you have styles to include -->
    <!-- <link rel=""stylesheet"" href=""styles.css""> -->
</head>
<body>
    <h1>Welcome to Banzuke Surfing Game!</h1>
    <p>Select your Rikishi and start playing!</p>
    <select id=""rikishi"">
        <option value=""1"">Rikishi 1</option>
        <option value=""2"">Rikishi 2</option>
        <!-- more options here -->
    </select>
    <button onclick=""startPlaying()"">Start Playing</button>
    <!-- Link to the external JavaScript file -->
    <script src=""game.js""></script>
</body>
</html>

game.js
function startPlaying() {
    var rikishi = $('#rikishi').val();
    // This is where you'd connect to your game logic
    // For example:
    // sendRikishiToServer(rikishi);
    alert(""You selected: "" + rikishi);
}

game.test.js
const { startPlaying } = require('./game');

test('check if startPlaying is defined', () => {
  expect(startPlaying).toBeDefined();
});",71
"Please move scripts and stylesheets out to separate files and set up a jest unit test.

<!DOCTYPE html>
<html>
<head>
    <title>Banzuke Surfing Game</title>
    <script src=""https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js""></script>
</head>
<body>
    <h1>Welcome to Banzuke Surfing Game!</h1>
    <p>Select your Rikishi and start playing!</p>
    <select id=""rikishi"">
        <option value=""1"">Rikishi 1</option>
        <option value=""2"">Rikishi 2</option>
        <!-- more options here -->
    </select>
    <button onclick=""startPlaying()"">Start Playing</button>
    <script>
        function startPlaying() {
            var rikishi = $('#rikishi').val();
            // This is where you'd connect to your game logic
            // For example:
            // sendRikishiToServer(rikishi);
            alert(""You selected: "" + rikishi);
        }
    </script>
</body>
</html>",45
"Please build a web interface for this game

Hi there,

this is to invite you to participate in Banzuke Surfing in the upcoming basho.
The rules are very simple.

Banzuke Surfing is run in several waves, with a new wave starting every year.

The goal is to move up the banzuke as far and fast as possible. You do so by temporarily ""adopting"" one or more rikishi at a given banzuke position. If your rikishi moves up the banzuke, so will you, if the rikishi moves down by getting MK, so will you (at least, if all your picked rikishi move down). If your rikishi goes intai, you will get his last position next time. In the basho after the current one you will be taking the banzuke position of the best-placed rikishi you've picked this time.

If your name appears on the list below, you have already participated. The column ""Allowed Picks"" shows you which rikishi of the banzuke you are allowed to pick next basho. If you are participating for the first time, you are allowed to pick any of the rikishi in the bottom 32 of the banzuke (as indicated below).
The rikishi that you are allowed to pick are all rikishi below your last (or most successful) pick. So generally, you cannot pick the same rikishi twice. An exception is if your rikishi drops into the last 32 of the banzuke or goes banzuke-gai. In this case, of course, you can pick any of the bottom 32 rikishi (just like a new player).

During your entire career of a given wave you can use up to three so-called jokers (indicated by the number of asterisks behind your name). In addition to the regular rikishi you pick for a basho, you can use one joker if still available. The more successful one of these two will determine your new banzuke position.

Deadline is shonichi 8 AM JST.

All new players are allowed to pick Jk6w Sawaisamu and below.

Rank Shikona              Last Surfer     Position Allowed Picks                 
1.   Jejima               Oho             M6w      M7e Takayasu and below             
2.   Wamahada*            Roga            J2e      J2w Mitoryu and below              
3.   Ganzohnesushi**      Takahashi       Ms4w     Ms5e Ishizaki and below            
4.   Hironoumi***         Kazekeno        Ms6e     Ms6w Kaisho and below              
5.   Sakura               Kazekeno        Ms6e     Ms6w Kaisho and below              
6.   Jakusotsu**          Takerufuji      Ms17e    Ms17w Hokaho and below             
7.   Achiyama*            Takerufuji      Ms17e    Ms17w Hokaho and below             
8.   chishafuwaku*        Hatsuyama       Ms19w    Ms20e Ryuo and below               
9.   WAKATAKE*            Toshunryu       Ms22e    Ms22w Tokunomusashi and below      
10.  Oortael*             Kazuto          Ms29w    Ms30e Kaizen and below             
11.  Andoreasu***         Kazuto          Ms29w    Ms30e Kaizen and below             
12.  Terarno              Kaizen          Ms30e    Ms30w Narutaki and below           
13.  Hoshotakamoto***     Suguro          Sd32e    Sd32w Tomiyutaka and below         
14.  Chiyotasuke***       Haruyama        Jd15e    Jd15w Mabuchi and below            
15.  Koorifuu***          DNP(2nd)        Jd28w    Jd29e Fujimusashi and below       ??? ",35
"img = np.fromfile(dph_files[0], dtype=np.uint16)
print (img.size) 

is there a faster way to check raw array size?",90
"I have a server.js  please refactor it

const express = require('express');
const app = express();
const port = process.env.PORT || 5000;
const path = require('path');
const fs = require('fs')
const contentful = require(""contentful"");
const compression = require('compression');

const SPACE_ID = process.env.REACT_APP_SPACE_ID;
const ACCESS_TOKEN = process.env.REACT_APP_ACCESS_TOKEN;
const MANAGER_TOKEN = process.env.REACT_APP_MANAGER_TOKEN;
const ENVIRONMENT = process.env.REACT_APP_ENVIRONMENT || ""master"";

const client = contentful.createClient({
  space: SPACE_ID,
  accessToken: ACCESS_TOKEN,
  environment: ENVIRONMENT
});

const getJob = (slug) => client.getEntries({
  content_type: 'job',
  'fields.slug': slug,
  select: 'fields.ogTitle,fields.ogDescription,fields.ogImage,fields.position,fields.company,fields.city',
  limit: 1,
});

const mainTitle = ""IT jobs with salaries - Jobs For IT"";
const mainDescription = ""Job offers for software developers, testers, UX designers, DevOps"";
const mainImage = ""https://www.jobsforit.de/static/media/wiewior.4979dfde.png"";

app.use(compression());
app.use(express.static(path.resolve(__dirname, '..', 'build')));

const filePath = path.resolve(__dirname, '..', 'build', 'index.html');
const filePathPolicy = path.resolve(__dirname, '..', 'build', 'privacy-policy.html');

app.get('/jobs/:id', function(request, response) {
  const id = request.params.id;
  fs.readFile(filePath, 'utf8', (err,data) => {
    if (err) {
      return console.log(err);
    }

    getJob(id)
      .then(entries => {
        const { position, ogTitle, ogDescription, ogImage } = entries.items[0].fields;
        const { name: company, logo } = entries.items[0].fields.company.fields;
        const { name: city } = entries.items[0].fields.city.fields;
        const title = ogTitle || `${position} Job - ${company} - ${city} - Jobs For IT`;
        const description = ogDescription || `Working in IT: ${company} is looking for ${position}. Job ${city}.`;
        const image = ogImage ? ogImage.fields.file.url : logo.fields.file.url;
        data = data.replace(new RegExp(mainTitle,""g""), title);
        data = data.replace(new RegExp(mainDescription,""g""), description);
        data = data.replace(mainImage, ""https:"" + image);
        response.send(data);
      }).catch(err => {
      console.error(err);
      response.send(data);
    });
     });
});

// fixed client side urls: https://stackoverflow.com/questions/27928372/react-router-urls-dont-work-when-refreshing-or-writing-manually?page=2&tab=active#tab-top
app.get('/*', function(req, res) {
  res.sendFile(filePath, function(err) {
    if (err) {
      res.status(500).send(err)
    }
  })
})

app.listen(port, () => console.log(`Listening to you on port ${port}`));



",92
"modifiziere 

rsync_command = [
            ""rsync"", ""-abP"", ""--delete"", ""--delete-excluded"",
            ""--link-dest="" + previous_version_path,
            source_path, current_version_path
        ]

so, dass folgender fehler nichtmehr auftritt:

Traceback (most recent call last):
  File ""/usr/local/sbin/backup-to-usb.python"", line 62, in <module>
    main()
  File ""/usr/local/sbin/backup-to-usb.python"", line 44, in main
    ""--link-dest="" + previous_version_path,
    ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~
TypeError: can only concatenate str (not ""NoneType"") to str",80
getting a java  spring boot error in a docker container on kubernetes like this,85
"You are AI Junior, you code like Donald Knuth.

# Working set

./docs/config/env_or_cli.md:
```
# Junior Configuration

The Junior process can be started using the following commands:
- `npx junior-web [args]`
- `npx junior-cli [args]`
- For self-development from the git repo: `npm start -- [args]`.

## Configurations

- **--ignore, JUNIOR_IGNORE**
  - List of items to ignore in a comma-separated format.
  - Defaults to: .git, node_modules, ./prompt, and many more. Check the getIgnoreList function for the full default list.
  - The final ignore list is a combination of the default list, command line arguments, and environmental variables.
  - Example: --ignore=./pathToIgnore

- **--server-port, JUNIOR_SERVER_PORT**
  - The port for the server.
  - Default: 10101
  - Example: --server-port=8080

- **--host**
  - Host configuration. If provided without a value, it enables the host. Otherwise, specify an IP.
  - Example: --host or --host=192.168.1.2

- **-d, --dry-run** (CLI Only)
  - Runs the application in dry run mode. Please note: the CLI is not fully functional at this time.

- **--model**
  - Specifies the model to be used.
  - Default: gpt-4
  - Example: --model=gpt-5

- **--noaudit**
  - Disables the audit trail.

- **--frontend-port, JUNIOR_FRONTEND_PORT**
  - The port for the frontend.
  - Default: 5864
  - Example: --frontend-port=8081

- **--system-prompt, -s** (CLI Only)
  - Forces the system prompt. Please note: the CLI is not fully functional at this time.

## Examples

### Hosting on a VPN IP
```
npx junior-web --host=192.168.1.2
```

### Ignoring a Directory from Attention Scan
```
npx junior-cli --ignore=./myDirectory
```


```
./docs/web.md:
```
# Web Interface

Junior's web interface was designed for use with ChatGPT Pro and doesn't require an API key.

## Architecture

The web interface is composed of two different servers: a frontend and a backend. The frontend server runs on port 5864, and the backend server runs on port 10101.

## Starting the Web Interface

Run the application with `npx junior-web` from your project or with `npm start` from Junior itself. A web browser window will automatically open at `http://localhost:5864`, which is where you can access the web interface.

For configuration options and details, refer to the [Configuration](./config/env_or_cli.md) documentation.

## Workflow

The typical workflow begins with editing the `prompt.yaml` file in your code editor of choice (we recommend Visual Studio Code with the Junior plugin for an optimal experience). Once you're satisfied with your task setup, you proceed to the web interface for execution and monitoring.

## Usage

The web interface has a few interactive components:

![Web Interface](./screenshot.png)

- **Generate & Copy Prompt button (Blue)**: Click this to generate a task prompt based on your `prompt.yaml` file and copy it to your clipboard. The copied prompt should be pasted to ChatGPT 4 or similar for execution.

- **Paste & Execute Change button (Orange)**: Paste the response from the AI model (a shell script) into the input field and click this button to execute the changes.

- **Roll Back to Last Commit button (Red)**: If you made a mistake or aren't happy with the changes, click this button to revert to the last commit. Please note, the rollback operation preserves the `prompt.yaml` file, but drops every change since the last commit, including new files created in the meantime, even if they were not created by Junior.

- **Commit Changes button (Green)**: After you're satisfied with your changes, click this button to commit your modifications to git.

- **Terminal**: Displays the output of your command execution. It's a simple console that shows the progress of the task.

For a more detailed guide on using the web interface, refer to our video tutorial [here](https://youtu.be/W_iwry8uT7E).

Remember, you can always refer to your `prompt.yaml` file to modify the task details or attention mechanism.

Happy developing with your AI contributor!

```

# Task

Improve the documentation!

- npx is not needed to run Junior, the commands are on the path after install now.
- Remove mentions of npm start from the repo this is a separate workflow that we will document elsewhere

Do NOT create backup files.

# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, avoid using sed in favor of heredoc-ing full files.

OS: OSX

Installed tools: npm, jq


Before your solution, write a short, very concise readme about the working set, your task, and most importantly its challanges, if any.


EXAMPLE START
```sh
#!/bin/sh
set -e
goal=[Task description, max 9 words]
echo ""Plan:""
echo ""1. [...]""
cat > x.js << 'EOF'
[...]
'EOF'
echo ""\033[32mDone: $goal\033[0m\n""
```
EXAMPLE END

Before starting, check if you need more files or info to solve the task.

If the task is not clear:

EXAMPLE START
I need more information to solve the task. [Description of the missing info]
EXAMPLE END

Do not edit files not provided in the working set!
If you need more files:

EXAMPLE START
`filepath1` is needed to solve the task but is not in the working set.
EXAMPLE END

",91
"You are AI Junior, you code like Donald Knuth.

# Working set

./docs/README.md:
```
# Junior - Your AI-first IDE 

[![Video: Junior codes itself](/assets/video_cover.jpg)](https://youtu.be/NL4uFJSvfW0)

*""Video: Junior codes itself""*

Junior is an **AI-first IDE** designed specifically for professional programmers who have a preference for customizing and fine-tuning their tools. 

With Junior, developers get a unique space where they can work hand-in-hand with AI throughout the development process. By using structured task descriptors and spotlighting relevant parts of a project, tasks like code implementation, documentation, and testing can be seamlessly delegated to Junior.

At its core, Junior embraces a design philosophy that prioritizes simplicity, configurability, and auditability. This ensures that the platform remains both accessible to its users and adaptable to a variety of use-cases.

Junior has been crafted exclusively with AI-powered coding right from its early days, way before its core functionalities were in place. This demonstrates Junior's pioneering approach to harnessing the potential of artificial intelligence in software development.

## Getting Started

For guidance on using Junior, please refer to [usage.md](usage.md).

## Contributing and Support

Your contributions make a difference! At Junior, we value the collaboration of the community. Your role as a contributor is to monitor the development, provide detailed prompts, and thoroughly review the generated outcomes.

For questions or assistance, please raise an issue in our GitHub repository.

**Note:** We've tested Junior primarily with the GPT-4 model. However, you're welcome to experiment with similarly capable models and share your findings. It's not compatible with GPT-3.5.

```
./docs/usage.md:
```
# Developing External Projects with Junior

## Installation

Install Junior as a development dependency by running the following command:

```
npm add @aijunior/dev --save-dev
```
Additionally, you can install the ""Junior"" vscode extension from the vscode extension marketplace.

## Initialization

You can initialize the necessary files in the repository with the command:

```
npx junior-init
```

This will create the following files:

```
.gitignore
prompt/projectSpecifics.md
prompt.yaml
```

The Task Interaction Files (TIF) will be gitignored:
  - `prompt.yaml`, the prompt descriptor filled by the user ([descriptor.md](./descriptor.md))
  - `prompt.md`, the generated prompt by Junior
  - `change.sh`, the changeset generated by the language model

### Project Specifics

`prompt/projectSpecifics.md` is used to provide instructions about the codebase that Junior is working on, like preferred tools. It is important to keep this file minimal as it will be included in most prompts, and unnecessary complexity may result in the language model losing track and failing to solve the task.

## Starting Junior

You can start Junior with:

```
npx junior-web
```

For more information about the web interface, please refer to [web.md](./web.md).

```

# Task

Improve the documentation!

Global install is the recommended way, so that npx is not needed to start Junior. The user has to run junior-web in the project they want to work on. Update the docs!
Also fix the naming issue: The paid ChatGPT is calles Plus, not Pro.

Do NOT create backup files.

# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, avoid using sed in favor of heredoc-ing full files.

OS: OSX

Installed tools: npm, jq


Before your solution, write a short, very concise readme about the working set, your task, and most importantly its challanges, if any.


EXAMPLE START
```sh
#!/bin/sh
set -e
goal=[Task description, max 9 words]
echo ""Plan:""
echo ""1. [...]""
cat > x.js << 'EOF'
[...]
'EOF'
echo ""\033[32mDone: $goal\033[0m\n""
```
EXAMPLE END

Before starting, check if you need more files or info to solve the task.

If the task is not clear:

EXAMPLE START
I need more information to solve the task. [Description of the missing info]
EXAMPLE END

Do not edit files not provided in the working set!
If you need more files:

EXAMPLE START
`filepath1` is needed to solve the task but is not in the working set.
EXAMPLE END

",70
"You are AI Junior, you code like Donald Knuth.

# Working set

./src/frontend/components/terminal/TerminalComponent.jsx:
```
import { onCleanup, onMount } from 'solid-js';
import 'xterm/css/xterm.css';
import terminalConnection from '../../service/terminal/terminalConnection';
import { setupXTerm } from '../../service/terminal/setupXTerm';
import { sendTerminalResizeNotification } from '../../service/terminal/sendTerminalResizeNotification';
import DetailsComponent from '../DetailsComponent';
import VirtualKey from './VirtualKey';
import terminalVirtualKeyBindings from '../../config/terminalVirtualKeyBindings';

const TerminalComponent = () => {
  let container;
  const { term, fitAddon } = setupXTerm();

  const sendVirtualKey = (key) => {
    terminalConnection.sendDataToTerminal(JSON.stringify({ type: 'input', data: key }));
    term.focus();
  };

  onMount(() => {
    term.open(container);
    fitAddon.fit();

    const { rows, cols } = term;
    sendTerminalResizeNotification(rows, cols);

    terminalConnection.setOnDataReceived((data) => {
      term.write(data);
    });

    term.onData((data) => {
      terminalConnection.sendDataToTerminal(JSON.stringify({ type: 'input', data }));
    });

    term.onResize(({ newRows, newCols }) => {
      sendTerminalResizeNotification(newRows, newCols);
    });
  });
  
  onCleanup(() => {
    term.dispose();
    terminalConnection.closeConnection();
  });

  return (
    <DetailsComponent 
      defaultState=""closed""
      localStorageKey=""terminalState""
      generateHeader={() => ""Terminal""}
      classes=""rounded border p-2 w-full border-border bg-emphasize""
    >
      <div ref={container}></div>
      <div class=""flex overflow-x-auto whitespace-nowrap"">
        {terminalVirtualKeyBindings().map(({ label, action }) => (
          <VirtualKey label={label} action={() => sendVirtualKey(action)} />
        ))}
      </div>
    </DetailsComponent>
  );
};

export default TerminalComponent;

```

# Task

Implement the following feature!

- Create a plan!
- Create new files when needed!

Requirements:

Create a TerminalSummary component and use it as the details summary. It should get a string prop ""lastWritten"", find the last line of the input and render it reactively. Use a span, not a div for making it inline.
Add the summary component after the ""Terminal"" text in the summary.


## Project Specifics

- Every js file should *only export a single function or signal*! eg.: in createGitRepo.js: export function createGitRepo ( ....
- Use *ES6 imports*!
- Prefer *async/await* over promises!
- The frontend uses *Solidjs* and Tailwind, edit .jsx files accordingly!

Write concise, self-documenting and idiomatic ES6 code!

# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, avoid using sed in favor of heredoc-ing full files.

OS: OSX

Installed tools: npm, jq


Before your solution, write a short, very concise readme about the working set, your task, and most importantly its challanges, if any.


EXAMPLE START
```sh
#!/bin/sh
set -e
goal=[Task description, max 9 words]
echo ""Plan:""
echo ""1. [...]""
cat > x.js << 'EOF'
[...]
'EOF'
echo ""\033[32mDone: $goal\033[0m\n""
```
EXAMPLE END

Before starting, check if you need more files or info to solve the task.

If the task is not clear:

EXAMPLE START
I need more information to solve the task. [Description of the missing info]
EXAMPLE END

Do not edit files not provided in the working set!
If you need more files:

EXAMPLE START
`filepath1` is needed to solve the task but is not in the working set.
EXAMPLE END

",97
"You are AI Junior, you code like Donald Knuth.

# Working set

./docs/roadmap.md:
```
# Roadmap

## Usability & fixes
`v0.2 (Released: Aug 2023)`
- ??? Done: Implement the four buttons
- ??? Done: Fix every major bug
- ??? Done: Write docs to allow using Junior for developing external projects

## Programming on mobile
`v0.3 (Expected: Q4 2023)`
- ???? Develop a file browser to allow the user to select attention files from mobile
- Allow secure hosting
- Create an app by wrapping the frontend
- Test it by developing at the local Playground and while commuting

## Plugin system
`v0.4 (Expected: Q4 2023)`
- Allow writing any of the current components as a plugin

## Auto-attention
`v0.5 (Expected: Q1 2024)`
- Propose an attention based on the requirements and task the user selected
- Embed every file in the project
- Store the embeddings in a vector database

## Prompt herds
`v0.6 (Expected: Q2 2024)`
- Scan and transform (refactor) the codebase gradually

```
./.gitignore:
```
/secret.sh
/node_modules/
/tmp/
/prompt.yaml
/prompt.md
/change.sh

node_modules
# Backup patterns for .md files
*.md.backup
*.md.bak
*.md~
*.md.tmp
*.md.old
*.md.orig
*.md.save

```

# Task

Implement the following feature!

- Create a plan!
- Create new files when needed!

Requirements:

1. Update the roadmap status:
- Secure hosting is ready
- ""file browser"" and playground tests are ongoing
- Do not create backup files
2. gitignore *_backup.md files


## Project Specifics

- Every js file should *only export a single function or signal*! eg.: in createGitRepo.js: export function createGitRepo ( ....
- Use *ES6 imports*!
- Prefer *async/await* over promises!
- The frontend uses *Solidjs* and Tailwind, edit .jsx files accordingly!

Write concise, self-documenting and idiomatic code!

# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, avoid using sed in favor of heredoc-ing full files.

OS: OSX

Installed tools: npm, jq


Before your solution, write a short, very concise readme about the working set, your task, and most importantly its challanges, if any.


EXAMPLE START
```sh
#!/bin/sh
set -e
goal=[Task description, max 9 words]
echo ""Plan:""
echo ""1. [...]""
cat > x.js << 'EOF'
[...]
'EOF'
echo ""\033[32mDone: $goal\033[0m\n""
```
EXAMPLE END

Before starting, check if you need more files or info to solve the task.

If the task is not clear:

EXAMPLE START
I need more information to solve the task. [Description of the missing info]
EXAMPLE END

Do not edit files not provided in the working set!
If you need more files:

EXAMPLE START
`filepath1` is needed to solve the task but is not in the working set.
EXAMPLE END

",70
"You are AI Junior, you code like Donald Knuth.

# Working set

./src/frontend/components/GitStatusRow.jsx:
```
import { createEffect } from ""solid-js"";
import getBackgroundColorForFile from './getBackgroundColorForFile';

const GitStatusRow = (props) => {
  const { index, path, working_dir } = props.entry;
  const { onClick } = props;

  const splitPath = path.split('/');
  const fileName = splitPath.pop();
  const baseDir = splitPath.join('/');

  const bgColor = getBackgroundColorForFile(index, path);

  let pathRef;

  createEffect(() => {
    if (pathRef) {
      pathRef.scrollLeft = pathRef.scrollWidth;
    }
  });

  return (
    <div class={`flex ${bgColor ? 'bg-' + bgColor : ''}`} onClick={() => onClick(path)}>
      <span class=""w-50px overflow-x-auto p-1"">{index + ' ' + working_dir}</span>
      <span class=""text-base bg-main rounded p-1"">{fileName}</span>
      <span ref={pathRef} class=""overflow-x-auto whitespace-no-wrap break-keep scrollbar-hidden ml-4 py-2 text-sm"">{baseDir}</span>
    </div>
  );
};

export default GitStatusRow;

```
./src/frontend/components/getBackgroundColorForFile.jsx:
```
export default function getBackgroundColorForFile(index, path) {
  if (index === 'M') { // Modified files
    return 'rgb(34 197 94)';
  } else if (index === 'A' && !path.includes('prompt/history')) { // New files excluding ones with 'prompt/history' in path
    return 'rgb(253 186 116)';
  }
  return ''; // Default no background color
}

```

# Task

Fix the following issue!

In git status, file background color values are rgb, set them as background color styles, not classes in git status
Also rename the file and fn to file getStyleForFileStatus


## Project Specifics

- Every js file should *only export a single function or signal*! eg.: in createGitRepo.js: export function createGitRepo ( ....
- Use *ES6 imports*!
- Prefer *async/await* over promises!
- The frontend uses *Solidjs* and Tailwind, edit .jsx files accordingly!

# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, avoid using sed in favor of heredoc-ing full files.

OS: OSX

Installed tools: npm, jq


Before your solution, write a short, very concise readme about the working set, your task, and most importantly its challanges, if any.


EXAMPLE START
```sh
#!/bin/sh
set -e
goal=[Task description, max 9 words]
echo ""Plan:""
echo ""1. [...]""
cat > x.js << 'EOF'
[...]
'EOF'
echo ""\033[32mDone: $goal\033[0m\n""
```
EXAMPLE END

Before starting, check if you need more files or info to solve the task.

If the task is not clear:

EXAMPLE START
I need more information to solve the task. [Description of the missing info]
EXAMPLE END

Do not edit files not provided in the working set!
If you need more files:

EXAMPLE START
`filepath1` is needed to solve the task but is not in the working set.
EXAMPLE END

",95
"You are AI Junior, you code like Donald Knuth.

# Working set

./src/frontend/components/MultiSelect/MultiSelect.jsx:
```
import { createSignal, createEffect } from 'solid-js';
import SearchBar from './SearchBar';
import ResultSet from './ResultSet';
import FilteredList from './FilteredList';
import MultiSelectHeader from './MultiSelectHeader';
import computeFilteredList from './computeFilteredList';
import handleResultSetItemClick from './handleResultSetItemClick';

const MultiSelect = (props) => {
  const [searchValue, setSearchValue] = createSignal('');
  const [filteredList, setFilteredList] = createSignal([]);
  const selectedItemsSignal = props.selectedItemsSignal || createSignal([]);
  const [selectedItems, setSelectedItems] = selectedItemsSignal;

  createEffect(() => {
    const currentQuery = searchValue() || props.defaultQuery();
    setFilteredList(computeFilteredList(currentQuery, props.availableItems, props.compare, props.itemCount, selectedItems(), props.defaultQuery()));
  });

  const handleKeyPress = (e) => {
    if (e.key === 'Enter') {
      const updatedItems = [...selectedItems(), filteredList()[0]];
      setSelectedItems(updatedItems);
    }
  };

  const handleFilterListItemClick = (item) => {
    const updatedItems = [...selectedItems(), item];
    setSelectedItems(updatedItems);
  };

  const onResultSetItemClick = async (item, itemId) => {
    const updatedItems = await handleResultSetItemClick(item, itemId, selectedItems);
    setSelectedItems(updatedItems);
  };

  const handleClearSelection = () => {
    setSelectedItems([]);
  };

  return (
    <div class=""w-full bg-emphasize text-emphasize p-2 rounded border border-border"">
      <details open>
        <MultiSelectHeader items={selectedItems} emptyMessage=""Attention is empty."" onClear={handleClearSelection} />
        <div>
          <ResultSet items={selectedItems()} onItemClick={onResultSetItemClick} />
          <SearchBar searchValue={searchValue} setSearchValue={setSearchValue} onKeyPress={handleKeyPress} />
          <FilteredList items={filteredList()} onItemClick={handleFilterListItemClick} />
        </div>
      </details>
    </div>
  );
};

export default MultiSelect;

```
./src/frontend/components/MultiSelect/computeFilteredList.js:
```
import computeRank from './computeRank';

export default function computeFilteredList(searchValue, items, compare, itemCount, selectedItems = [], defaultQuery = """") {
  const comparisonFunction = compare || ((item, filter) => item.includes(filter) ? filter.length : 0);
  
  return items
    .filter(item => !selectedItems.includes(item) && computeRank(item, searchValue, defaultQuery, comparisonFunction) > 0)
    .sort((a, b) => computeRank(b, searchValue, defaultQuery, comparisonFunction) - computeRank(a, searchValue, defaultQuery, comparisonFunction))
    .slice(0, itemCount);
}

```
./src/frontend/components/AttentionFileList.jsx:
```
import { createEffect, createSignal } from 'solid-js';
import { fileList, setFileList } from '../model/fileList';
import fetchFileList from '../service/fetchFileList';
import MultiSelect from './MultiSelect/MultiSelect';
import getComparison from '../service/helpers/getComparison';
import flattenPaths from '../service/helpers/flattenPaths';
import extractQuery from '../service/helpers/extractQuery';
import { requirements } from '../model/requirements';
import { attention, setAttention } from '../model/attentionModel';
import { getAttentionFromDescriptor } from '../service/getAttentionFromDescriptor';
import { handleAttentionChange } from '../service/handleAttentionChange';

const AttentionFileList = () => {
  createEffect(async () => {
    const data = await fetchFileList();
    const flattenedPaths = flattenPaths(data, '');
    setFileList(flattenedPaths);
  });

  createEffect(() => {
    const attentionFromDescriptor = getAttentionFromDescriptor();
    setAttention(attentionFromDescriptor);
  });

  const [defaultQuery, setDefaultQuery] = createSignal("""");

  createEffect(() => {
    setDefaultQuery(extractQuery(requirements()));
  });

  const onAttentionChange = async (newAttention) => {
    if (await handleAttentionChange(newAttention)) {
      setAttention(newAttention);
    }
  };

  return (
    <div class=""w-full"">
      <MultiSelect 
        availableItems={fileList()} 
        selectedItemsSignal={[attention, onAttentionChange]} 
        compare={getComparison()} 
        itemCount={5} 
        defaultQuery={defaultQuery} 
      />
    </div>
  );
};

export default AttentionFileList;

```
./src/frontend/service/helpers/extractQuery.js:
```
const ignoreList = ['and', 'or', 'the'];

export default function extractQuery(requirements) {
  return requirements.split(/\W+/)
    .filter(word => word.length > 2 && !ignoreList.includes(word.toLowerCase()))
    .join(' ');
}

```
./src/frontend/service/helpers/getComparison.js:
```
const getComparison = () => {
  return (item, filter) => {
    const filterWords = filter.split(/\s+/).map(word => word.toLowerCase());
    const lowercasedItem = item.toLowerCase();
    // Calculate the rank based on the sum of the lengths of matching words.
    const rank = filterWords.reduce((acc, word) => lowercasedItem.includes(word) ? acc + word.length : acc, 0);
    return rank;
  };
};

export default getComparison;

```

# Task

Implement the following feature!

- Create a plan!
- Create new files when needed!

Requirements:

in multiselect, queries should be array of objects like:
{ keyword: ""frontend"", weight: 1.0 }

Modify extractQuery to return such an array.
Call extractquery on the search value
In getComparison, eliminate split and weight words based correctly


## Project Specifics

- Every js file should *only export a single function or signal*! eg.: in createGitRepo.js: export function createGitRepo ( ....
- Use *ES6 imports*!
- Prefer *async/await* over promises!
- The frontend uses *Solidjs* and Tailwind, edit .jsx files accordingly!

# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, avoid using sed in favor of heredoc-ing full files.

OS: OSX

Installed tools: npm, jq


Before your solution, write a short, very concise readme about the working set, your task, and most importantly its challanges, if any.


EXAMPLE START
```sh
#!/bin/sh
set -e
goal=[Task description, max 9 words]
echo ""Plan:""
echo ""1. [...]""
cat > x.js << 'EOF'
[...]
'EOF'
echo ""\033[32mDone: $goal\033[0m\n""
```
EXAMPLE END

Before starting, check if you need more files or info to solve the task.

If the task is not clear:

EXAMPLE START
I need more information to solve the task. [Description of the missing info]
EXAMPLE END

Do not edit files not provided in the working set!
If you need more files:

EXAMPLE START
`filepath1` is needed to solve the task but is not in the working set.
EXAMPLE END

",90
"You are AI Junior, you code like Donald Knuth.

# Working set

./src/frontend/service/terminal/terminalConnection.js:
```
import { createWebSocket } from '../createWebSocket';

const socket = createWebSocket('/terminal');

const sendDataToTerminal = (data) => {
  if (socket.readyState === WebSocket.OPEN) {
    socket.send(data);
  }
};

const setOnDataReceived = (callback) => {
  socket.onmessage = (event) => {
    callback(event.data);
  };
};

const closeConnection = () => {
  if (socket.readyState === WebSocket.OPEN) {
    socket.close();
  }
};

export default {
  sendDataToTerminal,
  setOnDataReceived,
  closeConnection,
};

```

# Task

Implement the following feature!

- Create a plan!
- Create new files when needed!

Requirements:

Terminalconnection should queue and send early messages.


## Project Specifics

- Every js file should *only export a single function or signal*! eg.: in createGitRepo.js: export function createGitRepo ( ....
- Use *ES6 imports*!
- Prefer *async/await* over promises!
- The frontend uses *Solidjs* and Tailwind, edit .jsx files accordingly!

# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, avoid using sed in favor of heredoc-ing full files.

OS: Debian


Installed tools: npm, jq


Before your solution, write a short, very concise readme about the working set, your task, and most importantly its challanges, if any.


EXAMPLE START
```sh
#!/bin/sh
set -e
goal=[Task description, max 9 words]
echo ""Plan:""
echo ""1. [...]""
cat > x.js << 'EOF'
[...]
'EOF'
echo ""\033[32mDone: $goal\033[0m\n""
```
EXAMPLE END

Before starting, check if you need more files or info to solve the task.

If the task is not clear:

EXAMPLE START
I need more information to solve the task. [Description of the missing info]
EXAMPLE END

Do not edit files not provided in the working set!
If you need more files:

EXAMPLE START
`filepath1` is needed to solve the task but is not in the working set.
EXAMPLE END

",92
"You are AI Junior, you code like Donald Knuth.
# Working set

./src/backend/terminal/setupTerminalServer.js:
```
import { spawn } from 'child_process';

export default function setupTerminalServer(socket) {
  console.log(""Setting up terminal server..."");

  const shell = spawn('/bin/sh');

  socket.on('message', (data) => {
    console.log(""Received message:"", data.toString());
    shell.stdin.write(data);
  });

  shell.stdout.on('data', (data) => {
    console.log(""Shell output:"", data.toString());
    socket.send(data);
  });

  shell.stderr.on('data', (data) => {
    console.log(""Shell error output:"", data.toString());
    socket.send(data);
  });

  shell.on('exit', () => {
    console.log(""Shell exited"");
    socket.close();
  });
}

```

./src/backend/startServer.js:
```
import express from 'express';
import cors from 'cors';
import { createServer } from 'http';
import { parse } from 'url';
import { WebSocketServer } from 'ws';
import { setupRoutes } from './setupRoutes.js';
import { notifyOnFileChange } from './notifyOnFileChange.js';
import { getServerPort } from './serverConfig.js';
import hostConfig from '../config/hostConfig.js';
import terminalRoutes from './terminal/terminalRoutes.js';

export function startServer() {
  const app = express();

  app.use(cors());
  app.use(express.json());

  const server = createServer(app);
  
  const wssTerminal = new WebSocketServer({ noServer: true });
  const wssNotify = new WebSocketServer({ noServer: true });

  notifyOnFileChange(wssNotify);
  
  terminalRoutes(wssTerminal);

  server.on('upgrade', function upgrade(request, socket, head) {
    const { pathname } = parse(request.url);
    if (pathname === '/terminal') {
      wssTerminal.handleUpgrade(request, socket, head, function done(ws) {
        wssTerminal.emit('connection', ws, request);
      });
    } else if (pathname === '/') {
      wssNotify.handleUpgrade(request, socket, head, function done(ws) {
        wssNotify.emit('connection', ws, request);
      });
    } else {
      socket.destroy();
    }
  });

  setupRoutes(app);

  const { enabled, ip } = hostConfig();
  const port = getServerPort();
  server.listen(port, ip || (enabled ? '0.0.0.0' : undefined), () => {
    console.log('Server is running on port', port);
  });
}

```

./src/backend/terminal/terminalRoutes.js:
```
import setupTerminalServer from './setupTerminalServer.js';

export default function terminalRoutes(wss) {
  wss.on('connection', (socket) => {
    setupTerminalServer(socket);
  }, { path: '/terminal' });
}

```


# Task

Implement the following feature!

- Create a plan!
- Create new files when needed!

Requirements:

Install and use node-pty for creating terminals!

An example for your reference:
```
const WebSocket = require('ws')
var os = require('os');
var pty = require('node-pty');

const wss = new WebSocket.Server({ port: 6060 })

console.log(""Socket is up and running..."")

var shell = os.platform() === 'win32' ? 'powershell.exe' : 'bash';
var ptyProcess = pty.spawn(shell, [], {
    name: 'xterm-color',
    //   cwd: process.env.HOME,
    env: process.env,
});
wss.on('connection', ws => {
    console.log(""new session"")
    ws.on('message', command => {
        ptyProcess.write(command);
    })

    ptyProcess.on('data', function (data) {
        ws.send(data)
        console.log(data);

    });
})
```



## Project Specifics

- Every js file should *only export a single function or signal*! eg.: in createGitRepo.js: export function createGitRepo ( ....
- Use *ES6 imports*!
- Prefer *async/await* over promises!
- The frontend uses *Solidjs* and Tailwind, edit .jsx files accordingly!

# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, avoid using sed in favor of heredoc-ing full files.

OS: OSX

Installed tools: npm, jq


Before your solution, write a short, very concise readme about the working set, your task, and most importantly its challanges, if any.


EXAMPLE START
```sh
#!/bin/sh
set -e
goal=[Task description, max 9 words]
echo ""Plan:""
echo ""1. [...]""
cat > x.js << 'EOF'
[...]
'EOF'
echo ""\033[32mDone: $goal\033[0m\n""
```
EXAMPLE END

Before starting, check if you need more files or info to solve the task.

If the task is not clear:

EXAMPLE START
I need more information to solve the task. [Description of the missing info]
EXAMPLE END

Do not edit files not provided in the working set!
If you need more files:

EXAMPLE START
`filepath1` is needed to solve the task but is not in the working set.
EXAMPLE END


",53
"You are AI Junior, you code like Donald Knuth.
# Working set

./src/frontend/service/terminal/terminalConnection.js:
```
import { createWebSocket } from '../createWebSocket';

const socket = createWebSocket();

const sendDataToTerminal = (data) => {
  if (socket.readyState === WebSocket.OPEN) {
    socket.send(data);
  }
};

const setOnDataReceived = (callback) => {
  socket.onmessage = (event) => {
    callback(event.data);
  };
};

const closeConnection = () => {
  if (socket.readyState === WebSocket.OPEN) {
    socket.close();
  }
};

export default {
  sendDataToTerminal,
  setOnDataReceived,
  closeConnection,
};

```

./src/frontend/service/createWebSocket.js:
```
import { getBaseUrl } from '../getBaseUrl.js';

export const createWebSocket = () => {
  const baseUrl = getBaseUrl();
  const wsUrl = baseUrl.replace(/^http/, 'ws');
  const ws = new WebSocket(wsUrl);
  return ws;
};

```


# Task

Implement the following feature!

- Create a plan!
- Create new files when needed!

Requirements:

- Allow createwebsocket to handle optional path (default ""/"" ) for the connection
- Connect to /terminal as the terminal connection.
- Do not change existing exports even if they are non-conformant.


## Project Specifics

- Every js file should *only export a single function or signal, as default*! eg.: in createGitRepo.js: export default function createGitRepo ( ....
- Use *ES6 imports*!
- Prefer *async/await* over promises!
- The frontend uses *Solidjs* and Tailwind, edit .jsx files accordingly!

# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, avoid using sed in favor of heredoc-ing full files.

OS: OSX

Installed tools: npm, jq


Before your solution, write a concise readme about the working set, your task, and most importantly its challanges, if any.


EXAMPLE START
```sh
#!/bin/sh
set -e
goal=[Task description, max 9 words]
echo ""Plan:""
echo ""1. [...]""
cat > x.js << 'EOF'
[...]
'EOF'
echo ""\033[32mDone: $goal\033[0m\n""
```
EXAMPLE END

Before starting, check if you need more files or info to solve the task.

If the task is not clear:

EXAMPLE START
I need more information to solve the task. [Description of the missing info]
EXAMPLE END

Do not edit files not provided in the working set!
If you need more files:

EXAMPLE START
`filepath1` is needed to solve the task but is not in the working set.
EXAMPLE END


",84
"You are AI Junior, you code like Donald Knuth.
# Working set

./src/frontend/service/createWebSocket.js:
```
import { getBaseUrl } from '../getBaseUrl.js';

export const createWebSocket = () => {
  const baseUrl = getBaseUrl();
  const wsUrl = baseUrl.replace(/^http/, 'ws');
  const ws = new WebSocket(wsUrl);
  return ws;
};

```

./src/frontend/App.jsx:
```
import { onCleanup } from 'solid-js';
import useKeyBindings from './service/useKeyBindings';
import keyBindings from './config/keyBindings';
import NavBar from './components/NavBar';
import PromptCreation from './components/PromptCreation';
import ChangeExecution from './components/ChangeExecution';
import ChangeInspection from './components/ChangeInspection';
import ChangeFinalization from './components/ChangeFinalization';

const App = () => {
  const bindings = keyBindings();
  const unregister = useKeyBindings(bindings);

  onCleanup(unregister); 

  return (
    <div class=""bg-main min-h-screen max-w-desktop lg:max-w-desktop md:max-w-full sm:max-w-full xs:max-w-full mx-auto flex flex-col items-center space-y-8 px-2 sm:px-4 xs:px-4 pb-8"">
      <NavBar />
      <PromptCreation />
      <ChangeExecution />
      <ChangeInspection />
      <ChangeFinalization />
    </div>
  );
};

export default App;

```

./src/frontend/components/SampleComponent.jsx:
```
import { createSignal, onCleanup } from 'solid-js';
import { sample, setSample } from '../model/sampleModel';
import sampleService from '../service/sampleService';
import MultiSelect from './MultiSelect';

const SampleComponent = () => {
  const modelValue = sample();
  const [localState, setLocalState] = createSignal('');
  const selectedItems = [""item1"", ""item2""];
  const availableItems = [""item1"", ""item2"", ""item3"", ""item4"", ""item5""];

  const fetchData = async () => {
    const data = await sampleService();
    setLocalState(data);
  };

  return (
    <div class=""rounded border p-4"">
      <div>{modelValue}</div>
      <div>{localState()}</div>
      <button class=""bg-blue-500 text-white px-4 py-2 rounded"" onClick={fetchData}>Fetch Data</button>
      <MultiSelect selectedItems={selectedItems} availableItems={availableItems} />
    </div>
  );
};

export default SampleComponent;

```


# Task

Implement the following feature!

- Create a plan!
- Create new files when needed!

Requirements:

1. xterm.js is installed, create a component to utilize it!
2. Add it to the end of the app.


## Project Specifics

- Every js file should *only export a single function or signal, as default*! eg.: in createGitRepo.js: export default function createGitRepo ( ....
- Use *ES6 imports*!
- Prefer *async/await* over promises!
- The frontend uses *Solidjs* and Tailwind, edit .jsx files accordingly!

# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, avoid using sed in favor of heredoc-ing full files.

OS: OSX

Installed tools: npm, jq


Before your solution, write a concise readme about the working set, your task, and most importantly its challanges, if any.


EXAMPLE START
```sh
#!/bin/sh
set -e
goal=[Task description, max 9 words]
echo ""Plan:""
echo ""1. [...]""
cat > x.js << 'EOF'
[...]
'EOF'
echo ""\033[32mDone: $goal\033[0m\n""
```
EXAMPLE END

Before starting, check if you need more files or info to solve the task.

If the task is not clear:

EXAMPLE START
I need more information to solve the task. [Description of the missing info]
EXAMPLE END

Do not edit files not provided in the working set!
If you need more files:

EXAMPLE START
`filepath1` is needed to solve the task but is not in the working set.
EXAMPLE END


",20
"You are AI Junior, you code like Donald Knuth.
# Working set

./src/frontend/components/RequirementsEditor.jsx:
```
import { createSignal, createEffect } from 'solid-js';
import postDescriptor from '../service/postDescriptor';
import { promptDescriptor, setPromptDescriptor } from '../model/promptDescriptor'; 
import { requirements, setRequirements } from '../model/requirements';
import { getYamlEntry } from '../service/getYamlEntry';
import isBetaEnabled from '../service/config/isBetaEnabled'; 
import jsyaml from 'js-yaml'; 
import AutoGrowingTextarea from './AutoGrowingTextarea';

const RequirementsEditor = () => {
  const [isBeta, setIsBeta] = createSignal(false);

  const init = async () => {
    const betaStatus = await isBetaEnabled();
    setIsBeta(betaStatus);
  };

  createEffect(init);

  const handleInput = (e) => {
    const descriptor = promptDescriptor();
    const parsed = jsyaml.load(descriptor);
    parsed.requirements = e.target.value; 
    const updatedDescriptor = jsyaml.dump(parsed);
    setPromptDescriptor(updatedDescriptor);
  };

  const handleChange = async (e) => {
    handleInput(e);
    const currentRequirements = e.target.value;
    await postDescriptor({ requirements: currentRequirements });
  };

  createEffect(() => {
    const descriptor = promptDescriptor();
    const currentRequirements = getYamlEntry(descriptor, 'requirements') || '';
    if (currentRequirements !== requirements()) {
      setRequirements(currentRequirements);
    }
  });

  return (
    <div class=""w-full flex justify-start bg-emphasize text-emphasize p-1 rounded border border-border mt-2"">
      <AutoGrowingTextarea
        class=""w-full bg-emphasize text-emphasize text-lg px-2""
        placeholder={isBeta() ? ""Enter your requirements..."" : ""This is disabled for now. Call with 'npx junior-web -- --beta' to enable.""}
        valueSignal={requirements}
        onInput={e => handleInput(e)}
        onChange={e => handleChange(e)}
        disabled={!isBeta()}
      />
    </div>
  );
};

export default RequirementsEditor;

```


# Task

Implement the following feature!

- Create a plan!
- Create new files when needed!

Requirements:

Requirements editor is out of beta, eliminate every beta-related check and just work.


## Project Specifics

- Every js file should *only export a single function or signal, as default*! eg.: in createGitRepo.js: export default function createGitRepo ( ....
- Use *ES6 imports*!
- Prefer *async/await* over promises!
- The frontend uses *Solidjs* and Tailwind, edit .jsx files accordingly!

# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, avoid using sed in favor of heredoc-ing full files.

OS: OSX

Installed tools: npm, jq


Before your solution, write a concise readme about the working set, your task, and most importantly its challanges, if any.


EXAMPLE START
```sh
#!/bin/sh
set -e
goal=[Task description, max 9 words]
echo ""Plan:""
echo ""1. [...]""
cat > x.js << 'EOF'
[...]
'EOF'
echo ""\033[32mDone: $goal\033[0m\n""
```
EXAMPLE END

Before starting, check if you need more files or info to solve the task.

If the task is not clear:

EXAMPLE START
I need more information to solve the task. [Description of the missing info]
EXAMPLE END

Do not edit files not provided in the working set!
If you need more files:

EXAMPLE START
`filepath1` is needed to solve the task but is not in the working set.
EXAMPLE END


",80
"You are AI Junior, you code like Donald Knuth.
# Working set

./src/frontend/components/GitStatusDisplay.jsx:
```
import { onMount, createEffect } from 'solid-js';
import getBackgroundColorForFile from './getBackgroundColorForFile';
import { gitStatus } from '../model/gitStatus';
import { fetchGitStatus } from '../service/fetchGitStatus';

const GitStatusDisplay = () => {
  let statusContainer;

  onMount(fetchGitStatus);

  createEffect(() => {
    const gitStatusValue = gitStatus();
    if (gitStatusValue) {
      if (gitStatusValue.error) {
        statusContainer.innerText = `${gitStatusValue.message}\n${gitStatusValue.error.stderr}`;
      } else if (gitStatusValue.data && gitStatusValue.data.files && gitStatusValue.data.files.length > 0) {
        statusContainer.innerHTML = gitStatusValue.data.files.map(entry => {
          const { index, path, working_dir } = entry;
          const bgColor = getBackgroundColorForFile(index, path);
          return `<div class=""grid grid-cols-3 ${bgColor ? 'bg-' + bgColor : ''}"">
                    <span class=""col-span-1 w-50px"">${index}</span>
                    <span class=""col-span-1 w-60%"">${path}</span>
                    <span class=""col-span-1"">${working_dir}</span>
                  </div>`;
        }).join('');
      }
    }
  });

  return (
    <pre
      ref={statusContainer}
      class={`rounded overflow-auto max-w-full ${gitStatus() && gitStatus().data && gitStatus().data.files && gitStatus().data.files.length > 0 ? 'block' : 'hidden'}`}
    />
  );
};

export default GitStatusDisplay;

```


# Task

Refactor!

Factor the rendering of a single row out to
GitStatusRow.jsx
While doing so, also eliminate innerHTML use!
Render normally, using jsx/solid.
Simplify, if possible.


## Project Specifics

- Every js file should *only export a single function or signal, as default*! eg.: in createGitRepo.js: export default function createGitRepo ( ....
- Use *ES6 imports*!
- Prefer *async/await* over promises!
- The frontend uses *Solidjs* and Tailwind, edit .jsx files accordingly!

# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, avoid using sed in favor of heredoc-ing full files.

OS: OSX

Installed tools: npm, jq


Do NOT write any text outside the script!

EXAMPLE START
```sh
#!/bin/sh
set -e
goal=[Task description, max 9 words]
echo ""Plan:""
echo ""1. [...]""
cat > x.js << 'EOF'
[...]
'EOF'
echo ""\033[32mDone: $goal\033[0m\n""
```
EXAMPLE END

Before starting, check if you need more files or info to solve the task.

If the task is not clear:

EXAMPLE START
I need more information to solve the task. [Description of the missing info]
EXAMPLE END

Do not edit files not provided in the working set!
If you need more files:

EXAMPLE START
`filepath1` is needed to solve the task but is not in the working set.
EXAMPLE END


",80
"You are AI Junior, you code like Donald Knuth.
# Working set

./src/frontend/components/GitStatusDisplay.jsx:
```
import { onMount, createEffect } from 'solid-js';
import { gitStatus } from '../model/gitStatus';
import { fetchGitStatus } from '../service/fetchGitStatus';

const GitStatusDisplay = () => {
  let statusContainer;

  onMount(fetchGitStatus);

  createEffect(() => {
    const gitStatusValue = gitStatus();
    if (gitStatusValue) {
      if (gitStatusValue.error) {
        statusContainer.innerText = `${gitStatusValue.message}\n${gitStatusValue.error.stderr}`;
      } else if (gitStatusValue.data && gitStatusValue.data.files && gitStatusValue.data.files.length > 0) {
        statusContainer.innerHTML = gitStatusValue.data.files.map(entry => {
          const { index, path, working_dir } = entry;
          return `<div class=""grid grid-cols-3"">
                    <span class=""col-span-1"">${index}</span>
                    <span class=""col-span-1"">${path}</span>
                    <span class=""col-span-1"">${working_dir}</span>
                  </div>`;
        }).join('');
      }
    }
  });

  return (
    <pre
      ref={statusContainer}
      class={`rounded overflow-auto max-w-full ${gitStatus() && gitStatus().data && gitStatus().data.files && gitStatus().data.files.length > 0 ? 'block' : 'hidden'}`}
    />
  );
};

export default GitStatusDisplay;

```


# Task

Implement the following feature!

- Create a plan!
- Create new files when needed!

Requirements:

1. The first column should be 50px, the second should get up to 60% of the full available width, and the last what remains.
2. Make background color of rows of modified files rgb(34 197 94), new files rgb(253 186 116), exept when path of new files contains ""prompt/history"", which should leaved without coloring.


## Project Specifics

- Every js file should *only export a single function or signal, as default*! eg.: in createGitRepo.js: export default function createGitRepo ( ....
- Use *ES6 imports*!
- Prefer *async/await* over promises!
- The frontend uses *Solidjs* and Tailwind, edit .jsx files accordingly!

# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, avoid using sed in favor of heredoc-ing full files.

OS: OSX

Installed tools: npm, jq


Do NOT write any text outside the script!

EXAMPLE START
```sh
#!/bin/sh
set -e
goal=[Task description, max 9 words]
echo ""Plan:""
echo ""1. [...]""
cat > x.js << 'EOF'
[...]
'EOF'
echo ""\033[32mDone: $goal\033[0m\n""
```
EXAMPLE END

Before starting, check if you need more files or info to solve the task.

If the task is not clear:

EXAMPLE START
I need more information to solve the task. [Description of the missing info]
EXAMPLE END

Do not edit files not provided in the working set!
If you need more files:

EXAMPLE START
`filepath1` is needed to solve the task but is not in the working set.
EXAMPLE END


",80
"You are AI Junior, you code like Donald Knuth.
# Working set

./src/backend/handlers/fileListHandler.js:
```
import readFileList from '../fileutils/readFileList.js';

export async function fileListHandler(req, res) {
  try {
    const filesList = await readFileList(""./"");
    res.json(filesList);
  } catch (error) {
    res.status(500).json({ error: 'Failed to list files' });
  }
}

```

./src/backend/handlers/fileReadHandler.js:
```
import fs from 'fs';
import { promisify } from 'util';

const readFileAsync = promisify(fs.readFile);

export async function fileReadHandler(req, res) {
  const { filepath } = req.params;

  if (!filepath) {
    return res.status(400).send({ error: 'File path is required' });
  }

  try {
    const fileContent = await readFileAsync(filepath, 'utf8');
    res.send(fileContent);
  } catch (error) {
    res.status(500).send({ error: 'Unable to read file' });
  }
}

```

./src/backend/setupRoutes.js:
```
import { setupGitRoutes } from './routes/setupGitRoutes.js';
import { setupPromptRoutes } from './routes/setupPromptRoutes.js';
import { executeHandler } from './handlers/executeHandler.js';
import { configHandler } from './handlers/configHandler.js';
import { fileListHandler } from './handlers/fileListHandler.js';
import { fileReadHandler } from './handlers/fileReadHandler.js';  // Added this line

export function setupRoutes(app) {
  setupPromptRoutes(app);
  setupGitRoutes(app);
  app.post('/execute', executeHandler);
  app.get('/config', configHandler);
  app.get('/files/list/', fileListHandler);
  app.get('/files/read/:filepath', fileReadHandler); // Added this line
}

```


# Task

Refactor!

Move files-prefixed routes to setupFilesRoutes.js
Move the related handlers to handlers/files/ 
Create the dir.


## Project Specifics

- Every js file should *only export a single function or signal*!
- Use *ES6 imports*!
- Prefer *async/await* over promises!
- The frontend uses *Solidjs* and Tailwind, edit .jsx files accordingly!

# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, avoid using sed in favor of heredoc-ing full files.

OS: OSX

Installed tools: npm, jq


Do NOT write any text outside the script!

EXAMPLE START
```sh
#!/bin/sh
set -e
goal=[Task description, max 9 words]
echo ""Plan:""
echo ""1. [...]""
cat > x.js << 'EOF'
[...]
'EOF'
echo ""\033[32mDone: $goal\033[0m\n""
```
EXAMPLE END

Before starting, check if you need more files or info to solve the task.

If the task is not clear:

EXAMPLE START
I need more information to solve the task. [Description of the missing info]
EXAMPLE END

Do not edit files not provided in the working set!
If you need more files:

EXAMPLE START
`filepath1` is needed to solve the task but is not in the working set.
EXAMPLE END


",50
"You are AI Junior, you code like Donald Knuth.
# Working set

/./src/frontend/components/MultiSelect/MultiSelectHeader.jsx:
```
const MultiSelectHeader = (props) => {
  return (
    <summary>
      <div style={{ display: 'inline-flex', justifyContent: 'flex-end' }}>
        <div style={{ flexGrow: 1 }}>
          { props.items().length > 0 ? `${props.items().length} files in attention` : props.emptyMessage }
        </div>
        { props.items().length > 0 && 
          <span class=""cursor-pointer ml-2"" onClick={props.onClear}>
            ????
          </span>
        }
      </div>
    </summary>
  );
};

export default MultiSelectHeader;

```


# Task

Implement the following feature!

- Create a plan!
- Create new files when needed!

Requirements:

In the multiselect header:
- Use a link ""clear"" with left padding instead of the bin icon
- When clicking clear, do not switch the details tag
- Create a function for generating the N files... msg and ensure it print grammatically correct msg for 1 file too.


## Project Specifics

- Every js file should *only export a single function or signal*!
- Use *ES6 imports*!
- Prefer *async/await* over promises!
- The frontend uses *Solidjs* and Tailwind, edit .jsx files accordingly!

# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, avoid using sed in favor of heredoc-ing full files.

OS: OSX

Installed tools: npm, jq


Do NOT write any text outside the script!

EXAMPLE START

```sh
#!/bin/sh
set -e
goal=[Task description, max 9 words]
echo ""Plan:""
echo ""1. [...]""
cat > x.js << 'EOF'
[...]
'EOF'
echo ""\033[32mDone: $goal\033[0m\n""
```

EXAMPLE END

Before starting, check if you need more files to solve the task.
Do not edit any file not provided in the working set!
If you need more files, do not try to solve the task, ask for the missing files instead!

EXAMPLE START

`filepath1` is needed to solve the task but is not in the working set.

EXAMPLE END

",92
"You are AI Junior, you code like Donald Knuth.
# Working set

/./src/frontend/components/CommitButton.jsx:
```
import { postCommit } from '../service/postCommit';
import postDescriptor from '../service/postDescriptor';
import { commitMessage } from '../model/commitMessage';
import { fetchGitStatus } from '../service/fetchGitStatus';
import clearState from '../service/clearState';

const CommitButton = () => {
  const handleCommit = async () => {
    const response = await postCommit(commitMessage());
    console.log(response.message);
    
    await postDescriptor({ requirements: '', attention: '' });
    
    const status = await fetchGitStatus();
    console.log(status);
    clearState();
  };

  return (
    <button className=""w-full px-4 py-4 bg-green-500 text-lg text-bg font-semibold rounded"" onClick={handleCommit}>Commit</button>
  );
};

export default CommitButton;

```


# Task

Implement the following feature!

- Create a plan!
- Create new files when needed!

Requirements:

Do not clear the attention after commit


## Project Specifics

- Every js file should *only export a single function or signal*!
- Use *ES6 imports*!
- Prefer *async/await* over promises!
- The frontend uses *Solidjs* and Tailwind, edit .jsx files accordingly!

# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, avoid using sed in favor of heredoc-ing full files.

OS: OSX

Installed tools: npm, jq


Do NOT write any text outside the script!

EXAMPLE START

```sh
#!/bin/sh
set -e
goal=[Task description, max 9 words]
echo ""Plan:""
echo ""1. [...]""
cat > x.js << 'EOF'
[...]
'EOF'
echo ""\033[32mDone: $goal\033[0m\n""
```

EXAMPLE END

Before starting, check if you need more files to solve the task.
Do not edit any file not provided in the working set!
If you need more files, do not try to solve the task, ask for the missing files instead!

EXAMPLE START

`filepath1` is needed to solve the task but is not in the working set.

EXAMPLE END

",50
"You are AI Junior, you code like Donald Knuth.
# Working set

/./src/frontend/components/MultiSelect/MultiSelect.jsx:
```
import { createSignal, createEffect } from 'solid-js';
import SearchBar from './SearchBar';
import ResultSet from './ResultSet';
import FilteredList from './FilteredList';
import computeFilteredList from './computeFilteredList';
import handleResultSetItemClick from './handleResultSetItemClick';

const MultiSelect = (props) => {
  const [searchValue, setSearchValue] = createSignal('');
  const [filteredList, setFilteredList] = createSignal([]);
  const selectedItemsSignal = props.selectedItemsSignal || createSignal([]);
  const [selectedItems, setSelectedItems] = selectedItemsSignal;

  createEffect(() => {
    const currentQuery = searchValue() || props.defaultQuery();
    setFilteredList(computeFilteredList(currentQuery, props.availableItems, props.compare, props.itemCount, selectedItems(), props.defaultQuery()));
  });

  const handleKeyPress = (e) => {
    if (e.key === 'Enter') {
      const updatedItems = [filteredList()[0], ...selectedItems()];
      setSelectedItems(updatedItems);
    }
  };

  const handleFilterListItemClick = (item) => {
    const updatedItems = [item, ...selectedItems()];
    setSelectedItems(updatedItems);
  };

  const onResultSetItemClick = async (item, itemId) => {
    const updatedItems = await handleResultSetItemClick(item, itemId, selectedItems);
    setSelectedItems(updatedItems);
  };

  return (
    <div class=""w-full bg-emphasize text-emphasize p-2 rounded border border-border"">
      <ResultSet items={selectedItems()} onItemClick={onResultSetItemClick} emptyMessage=""Attention is empty."" />
      <SearchBar searchValue={searchValue} setSearchValue={setSearchValue} onKeyPress={handleKeyPress} />
      <FilteredList items={filteredList()} onItemClick={handleFilterListItemClick} />
    </div>
  );
};

export default MultiSelect;

```

/./src/frontend/components/AttentionFileList.jsx:
```
import { createEffect, createSignal } from 'solid-js';
import { fileList, setFileList } from '../model/fileList';
import fetchFileList from '../service/fetchFileList';
import MultiSelect from './MultiSelect/MultiSelect';
import getComparison from '../service/helpers/getComparison';
import flattenPaths from '../service/helpers/flattenPaths';
import extractQuery from '../service/helpers/extractQuery';
import { requirements } from '../model/requirements';
import { attention, setAttention } from '../model/attentionModel';
import { getAttentionFromDescriptor } from '../service/getAttentionFromDescriptor';
import { handleAttentionChange } from '../service/handleAttentionChange';

const AttentionFileList = () => {
  createEffect(async () => {
    const data = await fetchFileList();
    const flattenedPaths = flattenPaths(data, '');
    setFileList(flattenedPaths);
  });

  createEffect(() => {
    const attentionFromDescriptor = getAttentionFromDescriptor();
    setAttention(attentionFromDescriptor);
  });

  const [defaultQuery, setDefaultQuery] = createSignal("""");

  createEffect(() => {
    setDefaultQuery(extractQuery(requirements()));
  });

  const onAttentionChange = async (newAttention) => {
    if (await handleAttentionChange(newAttention)) {
      setAttention(newAttention);
    }
  };

  return (
    <div class=""w-full"">
      <MultiSelect 
        availableItems={fileList()} 
        selectedItemsSignal={[attention, onAttentionChange]} 
        compare={getComparison()} 
        itemCount={5} 
        defaultQuery={defaultQuery} 
      />
    </div>
  );
};

export default AttentionFileList;

```


# Task

Implement the following feature!

- Create a plan!
- Create new files when needed!

Requirements:

Show the number of selected items as ""N files in attention"" in the attention multiselect header, when any.  Create MultiSelectHeader.jsx and move the current empty message to it too.


## Project Specifics

- Every js file should *only export a single function or signal*!
- Use *ES6 imports*!
- Prefer *async/await* over promises!
- The frontend uses *Solidjs* and Tailwind, edit .jsx files accordingly!

# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, avoid using sed in favor of heredoc-ing full files.

OS: OSX

Installed tools: npm, jq


Do NOT write any text outside the script!

EXAMPLE START

```sh
#!/bin/sh
set -e
goal=[Task description, max 9 words]
echo ""Plan:""
echo ""1. [...]""
cat > x.js << 'EOF'
[...]
'EOF'
echo ""\033[32mDone: $goal\033[0m\n""
```

EXAMPLE END

Before starting, check if you need more files to solve the task.
Do not edit any file not provided in the working set!
If you need more files, do not try to solve the task, ask for the missing files instead!

EXAMPLE START

`filepath1` is needed to solve the task but is not in the working set.

EXAMPLE END

",60
"You are AI Junior, you code like Donald Knuth.
# Working set

src/frontend/components/MultiSelect/MultiSelect.jsx:
```
import { createSignal, createEffect } from 'solid-js';
import SearchBar from './SearchBar';
import ResultSet from './ResultSet';
import FilteredList from './FilteredList';
import computeFilteredList from './computeFilteredList';
import handleResultSetItemClick from './handleResultSetItem';

const MultiSelect = (props) => {
  const [searchValue, setSearchValue] = createSignal('');
  const [filteredList, setFilteredList] = createSignal([]);
  const [selectedItems, setSelectedItems] = createSignal([...props.selectedItems]);

  createEffect(() => {
    const currentQuery = searchValue() || props.defaultQuery();
    setFilteredList(computeFilteredList(currentQuery, props.availableItems, props.compare, props.itemCount, selectedItems(), props.defaultQuery()));
  });

  const handleKeyPress = (e) => {
    if (e.key === 'Enter') {
      const updatedItems = [filteredList()[0], ...selectedItems()];
      setSelectedItems(updatedItems);
    }
  };

  const handleFilterListItemClick = (item) => {
    const updatedItems = [item, ...selectedItems()];
    setSelectedItems(updatedItems);
  };

  const onResultSetItemClick = async (item, itemId) => {
    const updatedItems = await handleResultSetItemClick(item, itemId, selectedItems);
    setSelectedItems(updatedItems);
  };

  return (
    <div class=""w-full bg-emphasize text-emphasize p-2 rounded border border-border"">
      <ResultSet items={selectedItems()} onItemClick={onResultSetItemClick} emptyMessage=""Attention is empty."" />
      <SearchBar searchValue={searchValue} setSearchValue={setSearchValue} onKeyPress={handleKeyPress} />
      <FilteredList items={filteredList()} onItemClick={handleFilterListItemClick} />
    </div>
  );
};

export default MultiSelect;

```

src/frontend/components/MultiSelect/handleResultSetItem.js:
```
const handleResultSetItemClick = async (item, itemId, selectedItems) => {
    const element = document.getElementById(itemId);
    if (element) {
        element.style.transition = ""opacity 0.5s, transform 0.5s"";
        element.style.opacity = ""0"";
        element.style.transform = ""translateX(-100%)"";
        await new Promise(resolve => setTimeout(resolve, 500));
    }
    const updatedItems = selectedItems().filter(selectedItem => selectedItem !== item);
    return updatedItems;
};

export default handleResultSetItemClick;

```


# Task

Implement the following feature!

- Create a plan!
- Create new files when needed!

Requirements:

Rename the handler file to handleResultSetItemClick.js
Instead of translating, it should fade and shrink vertically, in 0.3 sec



## Project Specifics

- Every js file should *only export a single function or signal*!
- Use *ES6 imports*!
- Prefer *async/await* over promises!
- The frontend uses *Solidjs* and Tailwind, edit .jsx files accordingly!

# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, avoid using sed in favor of heredoc-ing full files using 'EOF' to prevent substitution.

OS: OSX

Installed tools: npm, jq


Do NOT write any text outside the script!

EXAMPLE START

```sh
#!/bin/sh
set -e
goal=[Task description, max 7 words]
echo ""Plan:""
echo ""1. [...]""
[Commands solving the task]
echo ""\033[32mDone: $goal\033[0m\n""
```

EXAMPLE END

Before starting, check if you need more files to solve the task.
Do not edit any file not provided in the working set!
If you need more files, do not try to solve the task, ask for the missing files instead!

EXAMPLE START

`filepath1` is needed to solve the task but is not in the working set.

EXAMPLE END

",83
"You are AI Junior, you code like Donald Knuth.
# Working set

src/frontend/components/MultiSelect/MultiSelect.jsx:
```
import { createSignal, createEffect } from 'solid-js';
import SearchBar from './SearchBar';
import ResultSet from './ResultSet';
import FilteredList from './FilteredList';
import computeFilteredList from './computeFilteredList';

const MultiSelect = (props) => {
  const [searchValue, setSearchValue] = createSignal('');
  const [filteredList, setFilteredList] = createSignal([]);
  const [selectedItems, setSelectedItems] = createSignal([...props.selectedItems]);

  createEffect(() => {
    const currentQuery = searchValue() || props.defaultQuery();
    setFilteredList(computeFilteredList(currentQuery, props.availableItems, props.compare, props.itemCount, selectedItems(), props.defaultQuery()));
  });

  const handleKeyPress = (e) => {
    if (e.key === 'Enter') {
      const updatedItems = [filteredList()[0], ...selectedItems()];
      setSelectedItems(updatedItems);
    }
  };

  const handleFilterListItemClick = (item) => {
    const updatedItems = [item, ...selectedItems()];
    setSelectedItems(updatedItems);
  };

  const handleResultSetItemClick = async (item, itemId) => {
    const element = document.getElementById(itemId);
    if (element) {
      element.style.transition = ""opacity 0.5s, transform 0.5s"";
      element.style.opacity = ""0"";
      element.style.transform = ""translateX(-100%)"";
      await new Promise(resolve => setTimeout(resolve, 500));
    }
    const updatedItems = selectedItems().filter(selectedItem => selectedItem !== item);
    setSelectedItems(updatedItems);
  };

  return (
    <div class=""w-full bg-emphasize text-emphasize p-2 rounded border border-border"">
      <ResultSet items={selectedItems()} onItemClick={handleResultSetItemClick} emptyMessage=""Attention is empty."" />
      <SearchBar searchValue={searchValue} setSearchValue={setSearchValue} onKeyPress={handleKeyPress} />
      <FilteredList items={filteredList()} onItemClick={handleFilterListItemClick} />
    </div>
  );
};

export default MultiSelect;

```


# Task

Refactor!

factor out handleResultSetItem to its own .js file


## Project Specifics

- Every js file should *only export a single function or signal*!
- Use *ES6 imports*!
- Prefer *async/await* over promises!
- The frontend uses *Solidjs* and Tailwind, edit .jsx files accordingly!

# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, avoid using sed in favor of heredoc-ing full files using 'EOF' to prevent substitution.

OS: OSX

Installed tools: npm, jq


Do NOT write any text outside the script!

EXAMPLE START

```sh
#!/bin/sh
set -e
goal=[Task description, max 7 words]
echo ""Plan:""
echo ""1. [...]""
[Commands solving the task]
echo ""\033[32mDone: $goal\033[0m\n""
```

EXAMPLE END

Before starting, check if you need more files to solve the task.
Do not edit any file not provided in the working set!
If you need more files, do not try to solve the task, ask for the missing files instead!

EXAMPLE START

`filepath1` is needed to solve the task but is not in the working set.

EXAMPLE END

",95
"You are AI Junior, you code like Donald Knuth.
# Working set

src/frontend/components/MultiSelect/FilteredListItem.jsx:
```
import { createEffect } from ""solid-js"";

const FilteredListItem = (props) => {
  let itemRef;

  const handleClick = () => {
    if (typeof props.onItemClick === 'function') {
      props.onItemClick(props.item);
    }
  };

  createEffect(() => {
    if (itemRef) {
      itemRef.scrollLeft = itemRef.scrollWidth;
    }
  });

  // Split the path into filename and directory
  const [filename, ...pathParts] = props.item.split('/').reverse();
  const directory = pathParts.reverse().join('/');

  return (
    <div onClick={handleClick} class=""flex justify-between items-center w-full font-mono cursor-pointer"">
      <span class=""border-r border-border pl-2 pr-2"">{props.idx}</span>
      <span ref={itemRef} class=""overflow-x-auto whitespace-no-wrap break-keep scrollbar-hidden ml-4 py-2 text-xl"">{filename}</span>
      <span class=""ml-2"">{directory}</span>
    </div>
  );
};

export default FilteredListItem;

```


# Task

Implement the following feature!

- Create a plan!
- Create new files when needed!

Requirements:

1. Remove the numbering.
2. When there is not enough horizontal space, shrink the path first, not the filename.
3. Allow scrolling the path and scroll that (instead of the filename) to the right at load.



## Project Specifics

- Every js file should *only export a single function or signal*!
- Use *ES6 imports*!
- Prefer *async/await* over promises!
- The frontend uses *Solidjs* and Tailwind, edit .jsx files accordingly!

# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, avoid using sed in favor of heredoc-ing full files using 'EOF' to prevent substitution.

OS: OSX

Installed tools: npm, jq


Do NOT write any text outside the script!

EXAMPLE START

```sh
#!/bin/sh
set -e
goal=[Task description, max 7 words]
echo ""Plan:""
echo ""1. [...]""
[Commands solving the task]
echo ""\033[32mDone: $goal\033[0m\n""
```

EXAMPLE END

Before starting, check if you need more files to solve the task.
Do not edit any file not provided in the working set!
If you need more files, do not try to solve the task, ask for the missing files instead!

EXAMPLE START

`filepath1` is needed to solve the task but is not in the working set.

EXAMPLE END

",50
"You are AI Junior, you code like Donald Knuth.
# Working set

src/frontend/components/MultiSelect/MultiSelect.jsx:
```
import { createSignal, createEffect } from 'solid-js';
import SearchBar from './SearchBar';
import ResultSet from './ResultSet';
import FilteredList from './FilteredList';
import computeFilteredList from './computeFilteredList';

const MultiSelect = (props) => {
  const [searchValue, setSearchValue] = createSignal('');
  const [filteredList, setFilteredList] = createSignal([]);
  const [selectedItems, setSelectedItems] = createSignal([...props.selectedItems]);

  createEffect(() => {
    const currentQuery = searchValue() || props.defaultQuery();
    setFilteredList(computeFilteredList(currentQuery, props.availableItems, props.compare, props.itemCount, selectedItems()));
  });

  const handleKeyPress = (e) => {
    if (e.key === 'Enter') {
      const updatedItems = [filteredList()[0], ...selectedItems()];
      setSelectedItems(updatedItems);
    }
  };

  return (
    <div class=""w-full bg-emphasize text-emphasize p-2 rounded border border-border"">
      <ResultSet items={selectedItems()} />
      <SearchBar searchValue={searchValue} setSearchValue={setSearchValue} onKeyPress={handleKeyPress} />
      <FilteredList items={filteredList()} />
    </div>
  );
};

export default MultiSelect;

```

src/frontend/components/MultiSelect/SearchBar.jsx:
```
const SearchBar = (props) => {
  const handleInputChange = (e) => {
    props.setSearchValue(e.target.value);
  };

  return (
    <input 
      type=""text""
      placeholder=""Enter space-separated search terms!""
      value={props.searchValue()}
      onInput={handleInputChange}
      onKeyPress={props.onKeyPress}
      class=""border border-gray-300 rounded p-2 w-full bg-emphasize text-emphasize my-2""
    />
  );
};

export default SearchBar;

```

src/frontend/components/MultiSelect/FilteredList.jsx:
```
import FilteredListItem from ""./FilteredListItem"";

const FilteredList = (props) => {
  return (
    <ul class=""list-inside"">
      {props.items.map((item, idx) => <FilteredListItem key={item} item={item} idx={idx + 1} />)}
    </ul>
  );
};

export default FilteredList;

```

src/frontend/components/MultiSelect/FilteredListItem.jsx:
```
import { createEffect } from ""solid-js"";

const FilteredListItem = (props) => {
  let itemRef;

  createEffect(() => {
    if (itemRef) {
      itemRef.scrollLeft = itemRef.scrollWidth;
    }
  });

  return (
    <div class=""flex justify-between items-center w-full font-mono"">
      <span ref={itemRef} class=""overflow-x-auto whitespace-no-wrap break-keep scrollbar-hidden mr-4 py-2"">{props.item}</span>
      <span class=""border-l border-border pl-2 pr-2"">{props.idx}</span>
    </div>
  );
};

export default FilteredListItem;

```


# Task

Implement the following feature!

- Create a plan!
- Create new files when needed!

Requirements:

- Set the placeholder to ""Suggestions below. Search here!""
- When clicking a filteredlistitem, add the corresponding value to the result set


## Project Specifics

- Every js file should *only export a single function or signal*!
- Use *ES6 imports*!
- Prefer *async/await* over promises!
- The frontend uses *Solidjs* and Tailwind, edit .jsx files accordingly!

# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, avoid using sed in favor of heredoc-ing full files using 'EOF' to prevent substitution.

OS: OSX

Installed tools: npm, jq


Do NOT write any text outside the script!

EXAMPLE START

```sh
#!/bin/sh
set -e
goal=[Task description, max 7 words]
echo ""Plan:""
echo ""1. [...]""
[Commands solving the task]
echo ""\033[32mDone: $goal\033[0m\n""
```

EXAMPLE END

Before starting, check if you need more files to solve the task.
Do not edit any file not provided in the working set!
If you need more files, do not try to solve the task, ask for the missing files instead!

EXAMPLE START

`filepath1` is needed to solve the task but is not in the working set.

EXAMPLE END

",85
"You are AI Junior, you code like Donald Knuth.
# Working set

src/frontend/components/AttentionFileList.jsx:
```
import { createEffect } from 'solid-js';
import { fileList, setFileList } from '../model/fileList';
import fetchFileList from '../service/fetchFileList';
import MultiSelect from './MultiSelect/MultiSelect';
import getComparison from '../service/helpers/getComparison';
import flattenPaths from '../service/helpers/flattenPaths';
import extractQuery from '../service/helpers/extractQuery';
import { requirements } from '../model/requirements';

const AttentionFileList = () => {
  createEffect(async () => {
    const data = await fetchFileList();
    const flattenedPaths = flattenPaths(data, '');
    setFileList(flattenedPaths);
  });

  let defaultQuery = """";

  createEffect(() => {
    defaultQuery = extractQuery(requirements());
  });

  return (
    <div class=""w-full"">
      <MultiSelect availableItems={fileList()} selectedItems={[]} compare={getComparison()} itemCount={5} defaultQuery={defaultQuery} />
    </div>
  );
};

export default AttentionFileList;

```

src/frontend/components/MultiSelect/MultiSelect.jsx:
```
import { createSignal, createEffect } from 'solid-js';
import SearchBar from './SearchBar';
import ResultSet from './ResultSet';
import FilteredList from './FilteredList';
import computeFilteredList from './computeFilteredList';

const MultiSelect = (props) => {
  const [searchValue, setSearchValue] = createSignal('');
  const [filteredList, setFilteredList] = createSignal([]);
  const [selectedItems, setSelectedItems] = createSignal([...props.selectedItems]);

  createEffect(() => {
    setFilteredList(computeFilteredList(searchValue(), props.availableItems, props.compare, props.itemCount, selectedItems()));
  });

  const addFirstFilteredItem = () => {
    const updatedItems = [filteredList()[0], ...selectedItems()];
    setSelectedItems(updatedItems);
  };

  return (
    <div class=""w-full bg-emphasize text-emphasize p-2 rounded border border-border"">
      <ResultSet items={selectedItems()} />
      <SearchBar searchValue={searchValue} setSearchValue={setSearchValue} addFirstFilteredItem={addFirstFilteredItem} />
      <FilteredList items={filteredList()} />
    </div>
  );
};

export default MultiSelect;

```


# Task

Implement the following feature!

- Create a plan!
- Create new files when needed!

Requirements:

In multiselect, handle defaultQuery and use it for filtering instead of searchvalue when searchvalue is empty.



## Project Specifics

- Every js file should *only export a single function or signal*!
- Use *ES6 imports*!
- Prefer *async/await* over promises!
- The frontend uses *Solidjs* and Tailwind, edit .jsx files accordingly!

# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, avoid using sed in favor of heredoc-ing full files using 'EOF' to prevent substitution.

OS: OSX

Installed tools: npm, jq


Do NOT write any text outside the script!

EXAMPLE START

```sh
#!/bin/sh
set -e
goal=[Task description, max 7 words]
echo ""Plan:""
echo ""1. [...]""
[Commands solving the task]
echo ""\033[32mDone: $goal\033[0m\n""
```

EXAMPLE END

Before starting, check if you need more files to solve the task.
Do not edit any file not provided in the working set!
If you need more files, do not try to solve the task, ask for the missing files instead!

EXAMPLE START

`filepath1` is needed to solve the task but is not in the working set.

EXAMPLE END

",82
"You are AI Junior, you code like Donald Knuth.
# Working set

src/frontend/components/AttentionFileList.jsx:
```
import { createEffect } from 'solid-js';
import { fileList, setFileList } from '../model/fileList';
import fetchFileList from '../service/fetchFileList';
import MultiSelect from './MultiSelect/MultiSelect';
import getComparison from '../service/helpers/getComparison';
import flattenPaths from '../service/helpers/flattenPaths';

const AttentionFileList = () => {
  createEffect(async () => {
    const data = await fetchFileList();
    const flattenedPaths = flattenPaths(data, '');
    setFileList(flattenedPaths);
  });

  return (
    <div class=""w-full"">
      <MultiSelect availableItems={fileList()} selectedItems={[]} compare={getComparison()} itemCount={5} />
    </div>
  );
};

export default AttentionFileList;

```

src/frontend/model/requirements.js:
```
import { createSignal } from 'solid-js';

export const [requirements, setRequirements] = createSignal('');

```


# Task

Implement the following feature!

- Create a plan!
- Create new files when needed!

Requirements:

In the attention file list:
When the requirements model changes, generate a query from it by passing
to extraxtQuery in service/helpers/extraxtQuery.js, which:
- Splits the requirements to words at any non-word char
- Drops words that are less than 3 chars in length or found in the ignore list (a constant array)
- joins them with space

Pass it to multiselect as a new prop: defaultQuery



## Project Specifics

- Every js file should *only export a single function or signal*!
- Use *ES6 imports*!
- Prefer *async/await* over promises!
- The frontend uses *Solidjs* and Tailwind, edit .jsx files accordingly!

# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, avoid using sed in favor of heredoc-ing full files using 'EOF' to prevent substitution.

OS: OSX

Installed tools: npm, jq


Do NOT write any text outside the script!

EXAMPLE START

```sh
#!/bin/sh
set -e
goal=[Task description, max 7 words]
echo ""Plan:""
echo ""1. [...]""
[Commands solving the task]
echo ""\033[32mDone: $goal\033[0m\n""
```

EXAMPLE END

Before starting, check if you need more files to solve the task.
Do not edit any file not provided in the working set!
If you need more files, do not try to solve the task, ask for the missing files instead!

EXAMPLE START

`filepath1` is needed to solve the task but is not in the working set.

EXAMPLE END

",80
"You are AI Junior, you code like Donald Knuth.
# Working set

src/frontend/components/MultiSelect/MultiSelect.jsx:
```
import { createSignal, createEffect } from 'solid-js';
import SearchBar from './SearchBar';
import ResultSet from './ResultSet';
import FilteredList from './FilteredList';
import computeFilteredList from './computeFilteredList';

const MultiSelect = (props) => {
  const [searchValue, setSearchValue] = createSignal('');
  const [filteredList, setFilteredList] = createSignal([]);
  const [selectedItems, setSelectedItems] = createSignal([...props.selectedItems]);

  createEffect(() => {
    setFilteredList(computeFilteredList(searchValue(), props.availableItems, props.compare, props.itemCount));
  });

  const addFirstFilteredItem = () => {
    const updatedItems = [filteredList()[0], ...selectedItems()];
    setSelectedItems(updatedItems);
  };

  return (
    <div class=""w-full bg-emphasize text-emphasize p-2 rounded border border-border"">
      <ResultSet items={selectedItems()} />
      <SearchBar searchValue={searchValue} setSearchValue={setSearchValue} addFirstFilteredItem={addFirstFilteredItem} />
      <FilteredList items={filteredList()} />
    </div>
  );
};

export default MultiSelect;

```

src/frontend/components/MultiSelect/ResultSet.jsx:
```
const ResultSet = (props) => {
  return (
    <ul class=""list-decimal pl-5 list-inside"">
      {props.items.map(item => <li key={item}>{item}</li>)}
    </ul>
  );
};

export default ResultSet;

```

src/frontend/components/MultiSelect/FilteredList.jsx:
```
import FilteredListItem from ""./FilteredListItem"";

const FilteredList = (props) => {
  return (
    <ul class=""list-decimal pl-5 list-inside"">
      {props.items.map((item, idx) => <FilteredListItem key={item} item={item} idx={idx + 1} />)}
    </ul>
  );
};

export default FilteredList;

```

src/frontend/components/MultiSelect/FilteredListItem.jsx:
```
import { createEffect } from ""solid-js"";

const FilteredListItem = (props) => {
  let itemRef;

  createEffect(() => {
    if (itemRef) {
      itemRef.scrollLeft = itemRef.scrollWidth;
    }
  });

  return (
    <div class=""flex justify-between items-center w-full font-mono"">
      <span ref={itemRef} class=""overflow-x-auto whitespace-no-wrap mr-4"">{props.item}</span>
      <span>{props.idx}</span>
    </div>
  );
};

export default FilteredListItem;

```


# Task

Implement the following feature!

- Create a plan!
- Create new files when needed!

Requirements:

- Remove padding from the left in the filtered list and result set.
- Add vertical margin to the filtered list item
- Also add a lightweight border between the two spans (in the middle) in the filtered list item



## Project Specifics

- Every js file should *only export a single function or signal*!
- Use *ES6 imports*!
- Prefer *async/await* over promises!
- The frontend uses *Solidjs* and Tailwind, edit .jsx files accordingly!

# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, avoid using sed in favor of heredoc-ing full files using 'EOF' to prevent substitution.

OS: OSX

Installed tools: npm, jq


Do NOT write any text outside the script!

EXAMPLE START

```sh
#!/bin/sh
set -e
goal=[Task description, max 7 words]
echo ""Plan:""
echo ""1. [...]""
[Commands solving the task]
echo ""\033[32mDone: $goal\033[0m\n""
```

EXAMPLE END

Before starting, check if you need more files to solve the task.
Do not edit any file not provided in the working set!
If you need more files, do not try to solve the task, ask for the missing files instead!

EXAMPLE START

`filepath1` is needed to solve the task but is not in the working set.

EXAMPLE END

",85
"You are AI Junior, you code like Donald Knuth.
# Working set

src/git/getRepoInfo.js:
```
import simpleGit from 'simple-git';
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const git = simpleGit();
const packagePath = path.resolve(__dirname, '../../package.json');

export default async function getRepoInfo() {
    const remote = await git.getRemotes(true);
    const currentBranch = await git.revparse(['--abbrev-ref', 'HEAD']);
    const packageJSON = JSON.parse(fs.readFileSync(packagePath, 'utf8'));

    return {
        url: remote[0]?.refs?.fetch || '',
        branch: currentBranch,
        name: packageJSON.name || '',
        description: packageJSON.description || ''
    };
}

```

src/frontend/components/RepoInfo.jsx:
```
import { createSignal, onCleanup } from 'solid-js';
import fetchRepoInfo from '../service/fetchers/fetchRepoInfo';

const RepoInfo = () => {
    const [repoInfo, setRepoInfo] = createSignal({});

    // Fetch the repo info on component mount and set it to state
    const fetchAndSetRepoInfo = async () => {
        const data = await fetchRepoInfo();
        setRepoInfo(data);
    }

    fetchAndSetRepoInfo();

    return (
        <span class=""text-sm font-mono bg-gray-200 dark:bg-gray-700 px-1 py-0.5 mt-2 rounded"">
            {repoInfo().name} {repoInfo().branch}
        </span>
    );
};

export default RepoInfo;

```


# Task

Implement the following feature!

- Create a plan!
- Create new files when needed!

Requirements:

1. getRepoInfo should also return the current working dir
2. When clicking the RepoInfo component, it should
grow and display the working dir in a new line and then
all the remaining info, one item per line with labels.
3. When clicking again, it should go back to its original state.



## Project Specifics

- Every js file should *only export a single function*!
- Use *ES6 imports*!
- Prefer *async/await* over promises!
- The frontend uses *Solidjs* and Tailwind, edit .jsx file accordingly!


# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, avoid using sed in favor of heredoc-ing full files using 'EOF' to prevent substitution.

OS: OSX

Installed tools: npm, jq


Do NOT write any text outside the script!

EXAMPLE START

```sh
#!/bin/sh
set -e
goal=[Task description, max 7 words]
echo ""Plan:""
echo ""1. [...]""
[Commands solving the task]
echo ""\033[32mDone: $goal\033[0m\n""
```

EXAMPLE END

Before starting, check if you need more files to solve the task.
Do not edit any file not provided in the working set!
If you need more files, do not try to solve the task, ask for the missing files instead!

EXAMPLE START

`filepath1` is needed to solve the task but is not in the working set.

EXAMPLE END

",40
"You are AI Junior, you code like Donald Knuth.
# Working set

src/frontend/components/RepoInfo.jsx:
```
import { createSignal } from 'solid-js';

const RepoInfo = () => {
  return (
    <span class=""text-sm font-mono bg-gray-200 dark:bg-gray-700 px-1 py-0.5 mt-2 rounded"">
      @aijunior/dev main
    </span>
  );
};

export default RepoInfo;

```

src/backend/handlers/git/gitStatusHandler.js:
```
import gitStatus from '../../../git/gitStatus.js';

export default async function gitStatusHandler(req, res) {
  try {
    const status = await gitStatus();
    res.status(200).send({ message: status });
  } catch (error) {
    let errorMessage = 'Error in getting Git status';
    if (error.stderr && error.stderr.includes('Not a git repository')) {
      errorMessage = 'Not a git repo. Run \'npx junior-init\' to initialize!';
    }
    res.status(500).send({ message: errorMessage, error });
  }
}

```

src/git/clearBranches.js:
```
import simpleGit from 'simple-git';

const git = simpleGit();

export default async function clearBranches(exceptions = []) {
  let deletedCount = 0;
  let skippedCount = 0;
  
  try {
    const currentBranch = await git.revparse(['--abbrev-ref', 'HEAD']);
    const allBranches = await git.branchLocal();

    const branchesToDelete = allBranches.all.filter(branch => {
      return branch !== currentBranch && !exceptions.includes(branch);
    });

    for (const branch of branchesToDelete) {
      try {
        const isMerged = await git.raw(['branch', '--merged', branch]);
        if (isMerged.includes(branch)) {
          await git.branch(['-d', branch]);
          deletedCount++;
        } else {
          console.log(`Branch ${branch} is not merged, skipping...`);
          skippedCount++;
        }
      } catch (err) {
        console.log(`Failed to delete branch ${branch}: ${err.message}. Skipping...`);
        skippedCount++;
      }
    }
  } catch (err) {
    console.error(`An error occurred: ${err}`);
  }

  console.log(`Deleted branches: ${deletedCount}`);
  console.log(`Skipped branches: ${skippedCount}`);
}

```

src/backend/routes/setupGitRoutes.js:
```
import gitStatusHandler from '../handlers/git/gitStatusHandler.js';
import commitGitHandler from '../handlers/git/commitGitHandler.js';
import resetGitHandler from '../handlers/git/resetGitHandler.js';

export function setupGitRoutes(app) {
  app.get('/git/status', gitStatusHandler);
  app.post('/git/reset', resetGitHandler);
  app.post('/git/commit', commitGitHandler);
}

```


# Task

Implement the following feature!

- Create a plan!
- Create new files when needed!

Requirements:

Create a new route ""/git/repoinfo"" which returns an object with fields:
  - url: The repository url
  - branch: Current branch
  - name: Project name read out of package.json
  - description: Description read out of package.json

Put the git and package.json logic to src/git/



## Project Specifics

- Every js file should *only export a single function*!
- Use *ES6 imports*!
- Prefer *async/await* over promises!
- The frontend uses *Solidjs* and Tailwind, edit .jsx file accordingly!


# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, avoid using sed in favor of heredoc-ing full files using 'EOF' to prevent substitution.

OS: OSX

Installed tools: npm, jq


Do NOT write any text outside the script!

EXAMPLE START

```sh
#!/bin/sh
set -e
goal=[Task description, max 7 words]
echo ""Plan:""
echo ""1. [...]""
[Commands solving the task]
echo ""\033[32mDone: $goal\033[0m\n""
```

EXAMPLE END

Before starting, check if you need more files to solve the task.
Do not edit any file not provided in the working set!
If you need more files, do not try to solve the task, ask for the missing files instead!

EXAMPLE START

`filepath1` is needed to solve the task but is not in the working set.

EXAMPLE END

",53
"You are AI Junior, you code like Donald Knuth.
# Working set

src/frontend/components/MultiSelect.jsx:
```
import { searchValue } from '../model/searchBarModel';
import SearchBar from './SearchBar';
import ResultSet from './ResultSet';
import FilteredList from './FilteredList';

const MultiSelect = (props) => {
  return (
    <div class=""w-full rounded border p-4"">
      <ResultSet items={props.selectedItems} />
      <SearchBar />
      <FilteredList items={props.availableItems} filter={searchValue()} itemCount={props.itemCount} />
    </div>
  );
};

export default MultiSelect;

```

src/frontend/components/AttentionFileList.jsx:
```
import { createEffect } from 'solid-js';
import { fileList, setFileList } from '../model/fileList';
import fetchFileList from '../service/fetchFileList';
import MultiSelect from './MultiSelect';

const AttentionFileList = () => {
  createEffect(async () => {
    const data = await fetchFileList();
    const flattenedPaths = flattenPaths(data, '');
    setFileList(flattenedPaths);
  });

  const flattenPaths = (node, path) => {
    if (node.type === 'file') {
      return [path + '/' + node.name];
    }
    if (!Array.isArray(node.children)) {
      return [];
    }
    return node.children.reduce((acc, child) => {
      return acc.concat(flattenPaths(child, path + '/' + node.name));
    }, []);
  };

  return (
    <div class=""w-full"">
      <MultiSelect availableItems={fileList()} selectedItems={[]} itemCount={5} />
    </div>
  );
};

export default AttentionFileList;

```

src/frontend/components/FilteredList.jsx:
```
const FilteredList = (props) => {
  return (
    <ul class=""w-full list-disc pl-5"">
      {props.items.filter(item => item.includes(props.filter)).slice(0, props.itemCount).map(item => <li key={item}>{item}</li>)}
    </ul>
  );
};

export default FilteredList;

```


# Task

Implement the following feature!

- Create a plan!
- Create new files when needed!

Requirements:

If the filtered list gets a function, treat it as a comparison function.
Create a new function in services/helpers/ (Create the dir)
that returns another which is then used to match.
Don't forget to update MultiSelect



## Project Specifics

- Every js file should *only export a single function or signal*!
- Use *ES6 imports*!
- Prefer *async/await* over promises!
- The frontend uses *Solidjs* and Tailwind, edit .jsx files accordingly!
- Remove _all existing comments_ from the code!
- Then, comment every change with a single line describing the GOAL OF THE CHANGE!


# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, avoid using sed in favor of heredoc-ing full files using 'EOF' to prevent substitution.

OS: OSX

Installed tools: npm, jq


Do NOT write any text outside the script!

EXAMPLE START

```sh
#!/bin/sh
set -e
goal=[Task description, max 7 words]
echo ""Plan:""
echo ""1. [...]""
[Commands solving the task]
echo ""\033[32mDone: $goal\033[0m\n""
```

EXAMPLE END

Before starting, check if you need more files to solve the task.
Do not edit any file not provided in the working set!
If you need more files, do not try to solve the task, ask for the missing files instead!

EXAMPLE START

`filepath1` is needed to solve the task but is not in the working set.

EXAMPLE END

",80
"You are AI Junior, you code like Donald Knuth.
# Working set

src/frontend/components/CommitButton.jsx:
```
import { postCommit } from '../service/postCommit';
import postDescriptor from '../service/postDescriptor';
import { commitMessage } from '../model/commitMessage';
import { fetchGitStatus } from '../service/fetchGitStatus';
import clearState from '../service/clearState';

const CommitButton = () => {
  const handleCommit = async () => {
    const response = await postCommit(commitMessage());
    console.log(response.message);
    
    await postDescriptor({ requirements: '', attention: '' });
    
    const status = await fetchGitStatus();
    console.log(status);
    clearState();
  };

  return (
    <button className=""w-full px-4 py-4 bg-green-700 text-lg text-bg font-semibold rounded"" onClick={handleCommit}>Commit</button>
  );
};

export default CommitButton;

```

src/frontend/components/RollbackButton.jsx:
```
import { createSignal } from ""solid-js"";
import { resetGit } from '../service/resetGit';
import RollbackConfirmationDialog from './RollbackConfirmationDialog';
import clearState from '../service/clearState';

const RollbackButton = () => {
  const [showConfirmation, setShowConfirmation] = createSignal(false);

  const handleReset = async () => {
    const response = await resetGit();
    console.log(response.message);
    clearState();
  };

  const handleConfirm = () => {
    setShowConfirmation(false);
    handleReset();
  };

  const handleRollbackClick = () => {
    const disableConfirmation = localStorage.getItem('Junior.disableRollbackConfirmation') === 'true';
    if (disableConfirmation) {
      handleReset();
    } else {
      setShowConfirmation(true);
    }
  };

  return (
    <>
      <button className=""w-full px-4 py-4 bg-red-700 text-lg text-bg font-semibold rounded"" onClick={handleRollbackClick}>Roll Back</button>
      <RollbackConfirmationDialog visible={showConfirmation()} onConfirm={handleConfirm} onCancel={() => setShowConfirmation(false)} />
    </>
  );
};

export default RollbackButton;

```


# Task

Implement the following feature!

- Create a plan!
- Create new files when needed!

Requirements:

Make the button colors lighter


## Project Specifics

- Every js file should *only export a single function or signal*!
- Use *ES6 imports*!
- Prefer *async/await* over promises!
- The frontend uses *Solidjs* and Tailwind, edit .jsx files accordingly!
- Remove _all existing comments_ from the code!
- Then, comment every change with a single line describing the GOAL OF THE CHANGE!


# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, avoid using sed in favor of heredoc-ing full files using 'EOF' to prevent substitution.

OS: OSX

Installed tools: npm, jq


Do NOT write any text outside the script!

EXAMPLE START

```sh
#!/bin/sh
set -e
goal=[Task description, max 7 words]
echo ""Plan:""
echo ""1. [...]""
[Commands solving the task]
echo ""\033[32mDone: $goal\033[0m\n""
```

EXAMPLE END

Before starting, check if you need more files to solve the task.
Do not edit any file not provided in the working set!
If you need more files, do not try to solve the task, ask for the missing files instead!

EXAMPLE START

`filepath1` is needed to solve the task but is not in the working set.

EXAMPLE END

",90
"You are AI Junior, you code like Donald Knuth.
# Working set

src/backend/fileutils/readFileList.js:
```
import fs from 'fs';
import path from 'path';
import getIgnoreList from './getIgnoreList.js';

async function readFileList(dir, relativePath = """") {
  const items = await fs.promises.readdir(dir);
  const ignoreList = getIgnoreList();

  const itemDetails = await Promise.all(
    items.map(async item => {
      if (ignoreList.includes(item)) return;
      const fullPath = path.join(dir, item);
      const stats = await fs.promises.stat(fullPath);
      if (stats.isDirectory()) {
        return {
          type: ""dir"",
          name: item,
          children: await readFileList(fullPath, path.join(relativePath, item))
        };
      } else {
        return {
          type: ""file"",
          name: item,
          path: path.join(relativePath, item)
        };
      }
    })
  );

  return itemDetails.filter(Boolean);
}

export default readFileList;

```


# Task

Fix the following issue!

This returns an array, but it should return an object, just like during recursion: Add a root dir object with name ""."" 



## Project Specifics

- Every js file should *only export a single function or signal*!
- Use *ES6 imports*!
- Prefer *async/await* over promises!
- The frontend uses *Solidjs* and Tailwind, edit .jsx files accordingly!
- Remove _all existing comments_ from the code!
- Then, comment every change with a single line describing the GOAL OF THE CHANGE!


# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, avoid using sed in favor of heredoc-ing full files using 'EOF' to prevent substitution.

OS: OSX

Installed tools: npm, jq


Do NOT write any text outside the script!

EXAMPLE START

```sh
#!/bin/sh
set -e
goal=[Task description, max 7 words]
echo ""Plan:""
echo ""1. [...]""
[Commands solving the task]
echo ""\033[32mDone: $goal\033[0m\n""
```

EXAMPLE END

Before starting, check if you need more files to solve the task.
Do not edit any file not provided in the working set!
If you need more files, do not try to solve the task, ask for the missing files instead!

EXAMPLE START

`filepath1` is needed to solve the task but is not in the working set.

EXAMPLE END

",80
"You are AI Junior, you code like Donald Knuth.
# Working set

src/frontend/components/PromptCreation.jsx:
```
import TasksList from './TasksList';
import PromptDescriptor from './PromptDescriptor';
import GenerateButton from './GenerateButton';
import PromptDisplay from './PromptDisplay';
import RequirementsEditor from './RequirementsEditor';

const PromptCreation = () => {
  return (
    <>
      <TasksList />
      <RequirementsEditor />
      <PromptDescriptor />
      <GenerateButton />
      <PromptDisplay />
    </>
  );
};

export default PromptCreation;

```

src/frontend/components/TasksList.jsx:
```
import { onMount, createEffect } from 'solid-js';
import { fetchTasks } from '../fetchTasks';
import { handleTaskChange } from '../service/handleTaskChange';
import { selectedTask, setSelectedTask } from '../model/selectedTask';
import { promptDescriptor } from '../model/promptDescriptor';
import { getYamlEntry } from '../service/getYamlEntry';

const TasksList = () => {
  const tasks = fetchTasks();

  createEffect(() => {
    const descriptor = promptDescriptor();
    if (descriptor !== '') {
      const taskWithPath = getYamlEntry(descriptor, 'task');
      // Remove 'prompt/task/' prefix here
      const task = taskWithPath.replace('prompt/task/', '');
      setSelectedTask(task);
    }
  });

  return (
    <div class=""w-full flex justify-start bg-emphasize text-emphasize p-2 rounded border border-border"">
      <label class=""text-lg mr-2"">Task:</label>
      <select class=""w-full bg-emphasize text-emphasize text-lg"" value={selectedTask()} onChange={e => handleTaskChange(e)}>
        {tasks().map(task => <option value={task}>{task}</option>)}
      </select>
    </div>
  );
};

export default TasksList;

```

src/frontend/components/NavBar.jsx:
```
import ThemeSwitcher from './ThemeSwitcher';
import SubTitle from './SubTitle';

const NavBar = () => {
  const title = 'Junior';

  return (
    <div class=""relative w-full"">
      <div class=""absolute top-0 right-0 m-4"">
        <ThemeSwitcher />
      </div>
      <div class=""flex flex-col items-center justify-center"">
        <a href=""https://github.com/tisztamo/Junior"" class=""text-center text-3xl mt-6 no-underline"">{title}</a>
        <SubTitle />
      </div>
    </div>
  );
};

export default NavBar;

```

src/frontend/components/RollbackButton.jsx:
```
import { createSignal } from ""solid-js"";
import { resetGit } from '../service/resetGit';
import RollbackConfirmationDialog from './RollbackConfirmationDialog';
import clearState from '../service/clearState';

const RollbackButton = () => {
  const [showConfirmation, setShowConfirmation] = createSignal(false);

  const handleReset = async () => {
    const response = await resetGit();
    console.log(response.message);
    clearState();
  };

  const handleConfirm = () => {
    setShowConfirmation(false);
    handleReset();
  };

  const handleRollbackClick = () => {
    const disableConfirmation = localStorage.getItem('Junior.disableRollbackConfirmation') === 'true';
    if (disableConfirmation) {
      handleReset();
    } else {
      setShowConfirmation(true);
    }
  };

  return (
    <>
      <button className=""w-full px-4 py-4 bg-red-700 text-lg text-bg font-semibold rounded"" onClick={handleRollbackClick}>Roll Back</button>
      <RollbackConfirmationDialog visible={showConfirmation()} onConfirm={handleConfirm} onCancel={() => setShowConfirmation(false)} />
    </>
  );
};

export default RollbackButton;

```

src/frontend/components/ChangeExecution.jsx:
```
import ExecuteButton from './ExecuteButton';
import ExecutionResultDisplay from './ExecutionResultDisplay';

const ChangeExecution = () => {
  return (
    <>
      <ExecuteButton />
      <ExecutionResultDisplay />
    </>
  );
};

export default ChangeExecution;

```

src/frontend/components/GitStatusDisplay.jsx:
```
import { onMount, createEffect } from 'solid-js';
import { gitStatus } from '../model/gitStatus';
import { fetchGitStatus } from '../service/fetchGitStatus';

const GitStatusDisplay = () => {
  let statusContainer;

  onMount(fetchGitStatus);

  createEffect(() => {
    const gitStatusValue = gitStatus();
    if (gitStatusValue) {
      if (gitStatusValue.error) {
        statusContainer.innerText = `${gitStatusValue.message}\n${gitStatusValue.error.stderr}`;
      } else if (gitStatusValue.message && gitStatusValue.message !== '') {
        statusContainer.innerText = gitStatusValue.message;
      }
    }
  });

  return (
    <pre
      ref={statusContainer}
      class={`rounded overflow-auto max-w-full ${gitStatus() && gitStatus().message && gitStatus().message !== '' ? 'block' : 'hidden'}`}
    />
  );
};

export default GitStatusDisplay;

```


# Task

Implement the following feature!

- Create a plan!
- Create new files when needed!

Requirements:

We need a Sample Component, which is short but shows
how we write our components.
We need to show: - How the model is used - How local state is managed - How services are called - etc.
Imagine a sample service and model, use it in the sample component, but do not write it.
Write a comprehensive and concise sample to src/frontend/components/SampleComponent.jsx


## Project Specifics

- Every js file should *only export a single function*!
- Use *ES6 imports*!
- Prefer *async/await* over promises!
- The frontend uses *Solidjs* and Tailwind, edit .jsx files accordingly!
- Remove _all existing comments_ from the code!
- Then, comment every change with a single line describing the GOAL OF THE CHANGE!


# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, avoid using sed in favor of heredoc-ing full files using 'EOF' to prevent substitution.

OS: OSX

Installed tools: npm, jq


Do NOT write any text outside the script!

EXAMPLE START

```sh
#!/bin/sh
set -e
goal=[Task description, max 7 words]
echo ""Plan:""
echo ""1. [...]""
[Commands solving the task]
echo ""\033[32mDone: $goal\033[0m\n""
```

EXAMPLE END

Before starting, check if you need more files to solve the task.
Do not edit any file not provided in the working set!
If you need more files, do not try to solve the task, ask for the missing files instead!

EXAMPLE START

`filepath1` is needed to solve the task but is not in the working set.

EXAMPLE END

",60
"You are AI Junior, you code like Donald Knuth.
# Working set

package.json:
```
{
  ""name"": ""@aijunior/dev"",
  ""version"": ""0.2.0"",
  ""description"": ""Your AI Contributor which codes itself"",
  ""type"": ""module"",
  ""main"": ""src/main.js"",
  ""bin"": {
    ""junior"": ""src/main.js"",
    ""junior-web"": ""src/web.js"",
    ""junior-init"": ""src/init.js""
  },
  ""scripts"": {
    ""cli"": ""node src/main.js"",
    ""start"": ""node src/web.js"",
    ""build:css"": ""postcss ./src/frontend/styles.css -o ./dist/styles.css"",
    ""update-logo"": ""node ./scripts/updateLogo.js"",
    ""clear-branches"": ""node ./scripts/clearBranchesCommand.js $@"",
    ""test"": ""cypress open"",
    ""rollback"": ""node ./scripts/rollbackCommand.js""
  },
  ""keywords"": [
    ""cli"",
    ""uppercase""
  ],
  ""author"": """",
  ""license"": ""BSL"",
  ""dependencies"": {
    ""@types/js-yaml"": ""^4.0.5"",
    ""autoprefixer"": ""^10.4.14"",
    ""chatgpt"": ""^5.2.4"",
    ""cors"": ""^2.8.5"",
    ""docsify-cli"": ""^4.4.4"",
    ""ejs"": ""^3.1.9"",
    ""express"": ""^4.18.2"",
    ""highlight.js"": ""^11.8.0"",
    ""js-yaml"": ""^4.1.0"",
    ""markdown-it"": ""^13.0.1"",
    ""marked"": ""^5.1.0"",
    ""postcss"": ""^8.4.26"",
    ""postcss-nested"": ""^6.0.1"",
    ""sharp"": ""^0.32.4"",
    ""simple-git"": ""^3.19.1"",
    ""solid-js"": ""^1.7.7"",
    ""tailwindcss"": ""^3.3.3"",
    ""vite"": ""^4.3.9"",
    ""vite-plugin-solid"": ""^2.7.0"",
    ""ws"": ""^8.13.0""
  },
  ""directories"": {
    ""doc"": ""docs""
  },
  ""repository"": {
    ""type"": ""git"",
    ""url"": ""git+https://github.com/tisztamo/Junior.git""
  },
  ""bugs"": {
    ""url"": ""https://github.com/tisztamo/Junior/issues""
  },
  ""homepage"": ""https://github.com/tisztamo/Junior#readme"",
  ""devDependencies"": {
    ""cypress"": ""^12.17.4""
  }
}

```

src/git/resetGit.js:
```
import { promisify } from 'util';
import { exec as execCb } from 'child_process';

const exec = promisify(execCb);

export default async function resetGit() {
  try {
    await executeCommand('git clean -f -d');
    await executeCommand('git reset --hard');
  } catch (err) {
    console.error(`An error occurred: ${err}`);
  }
}

async function executeCommand(command) {
  try {
    console.log(`Running command: ${command}`);
    const { stdout } = await exec(command);
    console.log(`stdout: ${stdout}`);
  } catch (err) {
    console.error(`An error occurred while executing the command: ${command}. Error: ${err}`);
  }
}

```

scripts/rollbackCommand.js:
```
import resetGit from '../src/git/resetGit.js';

async function executeRollback() {
  try {
    await resetGit();
  } catch (err) {
    console.error();
  }
}

executeRollback();

```


# Task

Implement the following feature!

- Create a plan!
- Create new files when needed!

Requirements:

""npx junior-rollback"" should also execute resetGit.



## Project Specifics

- Every js file should *only export a single function*!
- Use *ES6 imports*!
- Prefer *async/await* over promises!
- The frontend uses *Solidjs* and Tailwind, edit .jsx file accordingly!


# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, avoid using sed in favor of heredoc-ing full files using 'EOF' to prevent substitution.

OS: OSX

Installed tools: npm, jq


Do NOT write any text outside the script!

EXAMPLE START

```sh
#!/bin/sh
set -e
goal=[Task description, max 7 words]
echo ""Plan:""
echo ""1. [...]""
[Commands solving the task]
echo ""\033[32mDone: $goal\033[0m\n""
```

EXAMPLE END

Before starting, check if you need more files to solve the task.
Do not edit any file not provided in the working set!
If you need more files, do not try to solve the task, ask for the missing files instead!

EXAMPLE START

`filepath1` is needed to solve the task but is not in the working set.

EXAMPLE END

",65
"You are Junior, an AI system aiding developers.
You are working with a part of a large program called the ""Working Set.""
Before starting, check if you need more files to solve the task.
Do not edit files without knowing their contents!
Ask for them in normal conversational format instead.

# Working set

src/frontend/components/RequirementsEditor.jsx:
```
import { createSignal, createEffect } from 'solid-js';
import postDescriptor from '../service/postDescriptor';
import { promptDescriptor, setPromptDescriptor } from '../model/promptDescriptor'; 
import { requirements, setRequirements } from '../model/requirements';
import { getYamlEntry } from '../service/getYamlEntry';
import isBetaEnabled from '../service/config/isBetaEnabled'; 
import jsyaml from 'js-yaml'; 
import AutoGrowingTextarea from './AutoGrowingTextarea';

const RequirementsEditor = () => {
  const [isBeta, setIsBeta] = createSignal(false);

  const init = async () => {
    const betaStatus = await isBetaEnabled();
    setIsBeta(betaStatus);
  };

  createEffect(init);

  const handleInput = (e) => {
    const descriptor = promptDescriptor();
    const parsed = jsyaml.load(descriptor);
    parsed.requirements = e.target.value; 
    const updatedDescriptor = jsyaml.dump(parsed);
    setPromptDescriptor(updatedDescriptor);
  };

  const handleChange = async (e) => {
    handleInput(e);  // Added handleInput call here
    const currentRequirements = e.target.value;
    await postDescriptor({ requirements: currentRequirements });
  };

  createEffect(() => {
    const descriptor = promptDescriptor();
    const currentRequirements = getYamlEntry(descriptor, 'requirements') || '';
    if (currentRequirements !== requirements()) {
      setRequirements(currentRequirements);
    }
  });

  return (
    <div class=""w-full flex justify-start bg-emphasize text-emphasize p-1 rounded border border-border mt-2"">
      <AutoGrowingTextarea
        class=""w-full bg-emphasize text-emphasize text-lg""
        placeholder={isBeta() ? ""Enter your requirements..."" : ""This is disabled for now. Call with 'npx junior-web -- --beta' to enable.""}
        value={isBeta() ? requirements() : ''}
        onInput={e => handleInput(e)}
        onChange={e => handleChange(e)}
        disabled={!isBeta()}
      />
    </div>
  );
};

export default RequirementsEditor;

```

src/frontend/components/AutoGrowingTextarea.jsx:
```
import { onCleanup, onMount } from 'solid-js';

const AutoGrowingTextarea = (props) => {
  let textRef;

  const resize = () => {
    textRef.style.height = 'auto';
    textRef.style.height = textRef.scrollHeight + 'px';
  }

  // Use the onMount lifecycle hook to ensure the ref is available
  onMount(() => {
    textRef.addEventListener('input', resize, false);
    resize();  // To resize on initialization
  });

  // When the component unmounts, cleanup the event listener
  onCleanup(() => {
    textRef.removeEventListener('input', resize, false);
  });

  return (
    <textarea
      {...props}
      ref={textRef}
      onInput={resize} // Bind onInput event to the resize function
      rows=""1"" // Start with one row
      style=""overflow:hidden"" // Hide the scrollbar
    />
  );
};

export default AutoGrowingTextarea;

```


# Task

Fix the following issue!

In the AutoGrowingTextarea:
  - Remove onMount and onCleanup, no need for the code in them.
  - Add an effect which calls the valueSignal prop (its an optional function)
  - Pass the value of valueSignal to the textarea value attribute. If no valueSignal, pass props.value
In the req editor:
  Pass valueSignal instead of value. Don't call it, pass the function
Also remove comments


## Project Specifics

- Every js file should *only export a single function*!
- Use *ES6 imports*!
- Prefer *async/await* over promises!
- The frontend uses *Solidjs* and Tailwind, edit .jsx file accordingly!


# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, avoid using sed in favor of heredoc-ing full files using 'EOF' to prevent substitution.

OS: OSX

Installed tools: npm, jq


Do NOT write any text outside the script!

EXAMPLE START

```sh
#!/bin/sh
set -e
goal=[Task description, max 7 words]
echo ""Plan:""
echo ""1. [...]""
[Commands solving the task]
echo ""\033[32mDone: $goal\033[0m\n""
```

EXAMPLE END

",80
"You are Junior, an AI system aiding developers.
You are working with a part of a large program called the ""Working Set.""
Before starting, check if you need more files to solve the task.
Do not edit files without knowing their contents!
Ask for them in normal conversational format instead.

# Working set

docs/roadmap.md:
```
# Roadmap
## Usability & fixes
- ??? Done: Implement the four buttons
- ??? Done: Fix every major bug
- ??? Done: Write docs to allow using Junior for developing external projects

## Programming on mobile
- Develop a file browser to allow the user to select attention files from mobile
- Create an app by wrapping the frontend
- Test it by developing at the local Playground and while commuting

## Auto-attention
- Propose an attention based on the requirements and task the user selected
- Embed every file in the project
- Store the embeddings in an (embedded) vector database

## Prompt herds
- Scan and transform (refactor) the codebase gradually

```


# Task

Improve the documentation!

Incorporate version numbers:
  ""Usability & fixes"" is 0.2, released aug 2023
  ""Programming on mobile"" will be 0.3, q4 2023
    Add a new subitem as the second one: ""Allow secure hosting"" 
  Add a new item ""Plugin system"" 0.4 q4 2023
    Allow writing any of the current components as a plugin
  ""Auto-attention"" 0.5 q1 2024
    Remove ""(embedded)""
  ""Prompt herds"" 0.6 q2 2024


Do not create backup files.

# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, avoid using sed in favor of heredoc-ing full files using 'EOF' to prevent substitution.

OS: OSX

Installed tools: npm, jq


Do NOT write any text outside the script!

EXAMPLE START

```sh
#!/bin/sh
set -e
goal=[Task description, max 7 words]
echo ""Plan:""
echo ""1. [...]""
[Commands solving the task]
echo ""\033[32mDone: $goal\033[0m\n""
```

EXAMPLE END

",85
"You are Junior, an AI system aiding developers.
You are working with a part of a large program called the ""Working Set.""
Before starting, check if you need more files to solve the task.
Do not edit files without knowing their contents!
Ask for them in normal conversational format instead.

# Working set

src/frontend/components/PromptDescriptor.jsx:
```
import { onMount, onCleanup } from 'solid-js';
import { fetchDescriptor } from '../service/fetchDescriptor';
import { fetchGitStatus } from '../service/fetchGitStatus';
import { useWebsocket } from '../service/useWebsocket';
import { promptDescriptor, setPromptDescriptor } from '../model/promptDescriptor';

const PromptDescriptor = () => {

  onMount(async () => {
    const text = await fetchDescriptor();
    setPromptDescriptor(text);
  });

  useWebsocket(async (e) => {
    if (e.data === 'update') {
      const text = await fetchDescriptor();
      setPromptDescriptor(text);
      // Fetch git status when an update event is received
      fetchGitStatus();
    }
  });

  onCleanup(() => {
    setPromptDescriptor('');
  });

  return (
    <div class=""overflow-auto max-w-full"">
      <div class=""whitespace-pre-wrap overflow-x-scroll overflow-y-auto font-mono"">
        {promptDescriptor()}
      </div>
    </div>
  );
};

export default PromptDescriptor;

```

src/prompt/promptDescriptorConfig.js:
```
export const descriptorFileName = ""prompt.yaml"";

```

src/frontend/components/PromptDisplay.jsx:
```
import { createSignal, onMount, createEffect } from ""solid-js"";
import { prompt } from '../model/prompt';

const PromptDisplay = () => {
  let div;
  let summary;

  createEffect(() => {
    if (div) {
      div.innerHTML = prompt();
      summary.innerHTML = `prompt length: ${prompt().length} chars`;
    }
  });

  return (
    <details class=""w-full max-w-screen overflow-x-auto whitespace-normal markdown"" style={{ display: prompt().length > 0 ? 'block' : 'none' }}>
      <summary ref={summary}></summary>
      <div ref={div} class=""mt-4""></div>
    </details>
  );
};

export default PromptDisplay;

```


# Task

Implement the following feature!

- Create a plan!
- Create new files when needed!

Requirements:

Wrap the prompt descriptor in a html details tag. Its header is the descriptor filename with mono font. Otherwise style it like the one in PromptDisplay



## Project Specifics

- Every js file should *only export a single function*!
- Use *ES6 imports*!
- Prefer *async/await* over promises!
- The frontend uses *Solidjs* and Tailwind, edit .jsx file accordingly!


# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, avoid using sed in favor of heredoc-ing full files using 'EOF' to prevent substitution.

OS: OSX

Installed tools: npm, jq


Do NOT write any text outside the script!

EXAMPLE START

```sh
#!/bin/sh
set -e
goal=[Task description, max 7 words]
echo ""Plan:""
echo ""1. [...]""
[Commands solving the task]
echo ""\033[32mDone: $goal\033[0m\n""
```

EXAMPLE END

",70
"You are Junior, an AI system aiding developers.
You are working with a part of a large program called the ""Working Set.""
Before starting, check if you need more files to solve the task.
Do not edit files without knowing their contents!
Ask for them in normal conversational format instead.

# Working set

src/frontend/service/handleGeneratePrompt.js:
```
import { generatePrompt } from '../generatePrompt';
import { marked } from 'marked';
import { setPrompt } from '../model/prompt';

const handleGeneratePrompt = async () => {
  try {
    const response = await generatePrompt();

    navigator.clipboard.writeText(response.prompt)
      .then(() => {
        console.log('Prompt copied to clipboard!');
      })
      .catch(err => {
        console.error('Failed to copy prompt: ', err);
      });

    const htmlPrompt = marked(response.prompt);

    setPrompt(htmlPrompt);
  } catch (error) {
    alert(error.message);
  }
};

export default handleGeneratePrompt;

```

src/frontend/components/RequirementsEditor.jsx:
```
import { createEffect } from 'solid-js';
import postDescriptor from '../service/postDescriptor';
import { promptDescriptor, setPromptDescriptor } from '../model/promptDescriptor'; 
import { requirements, setRequirements } from '../model/requirements';
import { getYamlEntry } from '../service/getYamlEntry';
import jsyaml from 'js-yaml'; 

const RequirementsEditor = () => {
  const handleRequirementsChange = async (e) => {
    await postDescriptor({ requirements: e.target.value });
  };

  const handleInput = (e) => {
    const descriptor = promptDescriptor();
    const parsed = jsyaml.load(descriptor);
    parsed.requirements = e.target.value; 
    const updatedDescriptor = jsyaml.dump(parsed);  // Changed from jsyaml.safeDump
    setPromptDescriptor(updatedDescriptor);
  };

  createEffect(() => {
    const descriptor = promptDescriptor();
    const currentRequirements = getYamlEntry(descriptor, 'requirements') || '';
    if (currentRequirements !== requirements()) {
      setRequirements(currentRequirements);
    }
  });

  return (
    <div class=""w-full flex justify-start bg-emphasize text-emphasize p-2 rounded border border-border mt-4"">
      <textarea
        class=""w-full bg-emphasize text-emphasize text-lg""
        placeholder=""Enter your requirements...""
        value={requirements()}
        onInput={e => handleInput(e)}
        onChange={e => handleRequirementsChange(e)}
      />
    </div>
  );
};

export default RequirementsEditor;


```


# Task

Fix the following issue!

Before generating the prompt, await postDescriptor
with an object having requirements field filled correctly.



## Project Specifics

- Every js file should *only export a single function*!
- Use *ES6 imports*!
- Prefer *async/await* over promises!
- The frontend uses *Solidjs* and Tailwind, edit .jsx file accordingly!


# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, avoid using sed in favor of heredoc-ing full files using 'EOF' to prevent substitution.

OS: OSX

Installed tools: npm, jq


Do NOT write any text outside the script!

EXAMPLE START

```sh
#!/bin/sh
set -e
goal=[Task description, max 7 words]
echo ""Plan:""
echo ""1. [...]""
[Commands solving the task]
echo ""\033[32mDone: $goal\033[0m\n""
```

EXAMPLE END

",45
"You are Junior, an AI system aiding developers.
You are working with a part of a large program called the ""Working Set.""
Before starting, check if you need more files to solve the task.
Do not edit files without knowing their contents!
Ask for them in normal conversational format instead.

# Working set

src/frontend/components/RequirementsEditor.jsx:
```
import { createEffect } from 'solid-js';
import postDescriptor from '../service/postDescriptor';
import { promptDescriptor } from '../model/promptDescriptor';
import { requirements, setRequirements } from '../model/requirements';
import { getYamlEntry } from '../service/getYamlEntry';

const RequirementsEditor = () => {
  const handleRequirementsChange = async (e) => {
    setRequirements(e.target.value);
    await postDescriptor({ requirements: e.target.value });
  };

  createEffect(() => {
    const descriptor = promptDescriptor();
    const currentRequirements = getYamlEntry(descriptor, 'requirements') || '';
    if (currentRequirements !== requirements()) {
      setRequirements(currentRequirements);
    }
  });

  return (
    <div class=""w-full flex justify-start bg-emphasize text-emphasize p-2 rounded border border-border mt-4"">
      <textarea
        class=""w-full bg-emphasize text-emphasize text-lg""
        placeholder=""Enter your requirements...""
        value={requirements()}
        onInput={e => handleRequirementsChange(e)}
      />
    </div>
  );
};

export default RequirementsEditor;

```

src/frontend/model/selectedTask.js:
```
import { createSignal } from 'solid-js';

export const [selectedTask, setSelectedTask] = createSignal('');

```

src/frontend/service/getYamlEntry.js:
```
import YAML from 'yaml';

export const getYamlEntry = (yamlString, entry) => {
  const doc = YAML.parse(yamlString);
  return doc[entry];
};

```


# Task

Fix the following issue!

getYamlEntry.js:5 Uncaught TypeError: Cannot read properties of null (reading &#39;requirements&#39;)
  at getYamlEntry (getYamlEntry.js:5:13)



## Project Specifics

- Every js file should *only export a single function*!
- Use *ES6 imports*!
- Prefer *async/await* over promises!
- The frontend uses *Solidjs* and Tailwind, edit .jsx file accordingly!


# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, avoid using sed in favor of heredoc-ing full files using 'EOF' to prevent substitution.

OS: OSX

Installed tools: npm, jq


Do NOT write any text outside the script!

EXAMPLE START

```sh
#!/bin/sh
set -e
goal=[Task description, max 7 words]
echo ""Plan:""
echo ""1. [...]""
[Commands solving the task]
echo ""\033[32mDone: $goal\033[0m\n""
```

EXAMPLE END

",60
"You are Junior, an AI system aiding developers.
You are working with a part of a large program called the ""Working Set.""
Before starting, check if you need more files to solve the task.
Do not edit files without knowing their contents!
Ask for them in normal conversational format instead.

# Working set

src/frontend/components/TasksList.jsx:
```
import { onMount, createEffect } from 'solid-js';
import { fetchTasks } from '../fetchTasks';
import { handleTaskChange } from '../service/handleTaskChange';
import { selectedTask, setSelectedTask } from '../model/selectedTask';
import { promptDescriptor } from '../model/promptDescriptor';
import { getYamlEntry } from '../service/getYamlEntry';

const TasksList = () => {
  const tasks = fetchTasks();

  createEffect(() => {
    const descriptor = promptDescriptor();
    if (descriptor !== '') {
      const taskWithPath = getYamlEntry(descriptor, 'task');
      // Remove 'prompt/task/' prefix here
      const task = taskWithPath.replace('prompt/task/', '');
      setSelectedTask(task);
    }
  });

  return (
    <div class=""w-full flex justify-start bg-emphasize text-emphasize p-2 rounded border border-border"">
      <label class=""text-lg mr-2"">Task:</label>
      <select class=""w-full bg-emphasize text-emphasize text-lg"" value={selectedTask()} onChange={e => handleTaskChange(e)}>
        {tasks().map(task => <option value={task}>{task}</option>)}
      </select>
    </div>
  );
};

export default TasksList;

```

src/frontend/components/RequirementsEditor.jsx:
```
import { createEffect } from 'solid-js';
import postDescriptor from '../service/postDescriptor';
import { promptDescriptor } from '../model/promptDescriptor';

const RequirementsEditor = () => {
  let requirements = promptDescriptor().requirements || '';

  const handleRequirementsChange = async (e) => {
    requirements = e.target.value;
    await postDescriptor({ requirements: requirements });
  };

  createEffect(() => {
    requirements = promptDescriptor().requirements || '';
  });

  return (
    <div class=""w-full flex justify-start bg-emphasize text-emphasize p-2 rounded border border-border mt-4"">
      <textarea
        class=""w-full bg-emphasize text-emphasize text-lg""
        placeholder=""Enter your requirements...""
        value={requirements}
        onInput={e => handleRequirementsChange(e)}
      />
    </div>
  );
};

export default RequirementsEditor;

```

src/frontend/model/selectedTask.js:
```
import { createSignal } from 'solid-js';

export const [selectedTask, setSelectedTask] = createSignal('');

```


# Task

Fix the following issue!

Requirements are not populated when the descriptor changes. Fix reactivity by introducing a signal in the model! Check the task list for example!


## Project Specifics

- Every js file should *only export a single function*!
- Use *ES6 imports*!
- Prefer *async/await* over promises!
- The frontend uses *Solidjs* and Tailwind, edit .jsx file accordingly!


# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, avoid using sed in favor of heredoc-ing full files using 'EOF' to prevent substitution.

OS: OSX

Installed tools: npm, jq


Do NOT write any text outside the script!

EXAMPLE START

```sh
#!/bin/sh
set -e
goal=[Task description, max 7 words]
echo ""Plan:""
echo ""1. [...]""
[Commands solving the task]
echo ""\033[32mDone: $goal\033[0m\n""
```

EXAMPLE END

",60
"You are Junior, an AI system aiding developers.
You are working with a part of a large program called the ""Working Set.""
Before starting, check if you need more files to solve the task.
Do not edit files without knowing their contents!
Ask for them in normal conversational format instead.

# Working set

docs/descriptor.md:
```
# Prompt Descriptor

The prompt descriptor is a YAML file (prompt.yaml) that outlines the details necessary for generating a task prompt for the AI model. It is used to specify the task, attention, requirements, and other attributes.

## Example

```yaml
task: prompt/task/feature/implement.md
attention:
  - src/interactiveSession/startInteractiveSession.js
  - src/prompt/createPrompt.js
  - src/attention/readAttention.js
  - prompt.yaml
requirements: >
  Write a README.md for this _exploratory_ project!
```

## Attributes

- task: Describes the task type and scope.
- attention: Lists the files and directories most relevant to the task.
- requirements: Describes the actual task in a human-readable format.
- format: (Optional and half-working) Determines how the output will be formatted. It should be avoided for now.
- os: (Default: ""Debian"") Specifies the operating system.
- installedTools: By default, this includes ""npm, jq."" Allows the user to mention his tools, e.g. when drawing. The user can create prompt/installedTools.md to overwrite.

Additionally, users can overwrite attributes in prompt.yaml or create prompt/attributeName.md with the content for any attribute, including those not listed here.

## Attributes referencing .md files

When a yaml attribute refers to an existing file, its content will be used. For example, the line `task: prompt/task/feature/implement.md` in the example yaml refers to an existing markdown file and its content is injected into the task.

Here's the content of prompt/task/feature/implement.md as a supplement to the example:

```
Implement the following feature!

- Create a plan!
- Create new files when needed!

Requirements:

<%= requirements %>

<%= projectSpecifics %>
```

## Template Files

Prompt parts are markdown template files, and [ejs](https://ejs.co/) runs on them. Attributes from the yaml file are available in the template, e.g., `<%= requirements %>` injects the requirements.


```


# Task

Improve the documentation!

1. Create a new subsection for ""Additionally, users can.."". Mention that the yaml has preference over the file. Show a simple example with setting the default os in the file and overwriting it. 2. The last part, "", including those not listed here."" should be moved to an entirely new section with title ""Custom Attributes"". Note here that the custom attributes can be injected to prompts using ejs syntax. Give a simple example for setting ""documentationRequirements"" in a file and how to inject it to prompt template files

# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, avoid using sed in favor of heredoc-ing full files using 'EOF' to prevent substitution.

OS: Debian


Installed tools: npm, jq


Do NOT write any text outside the script!

EXAMPLE START

```sh
#!/bin/sh
set -e
goal=[Task description, max 7 words]
echo ""Plan:""
echo ""1. [...]""
[Commands solving the task]
echo ""\033[32mDone: $goal\033[0m\n""
```

EXAMPLE END

",60
"You are Junior, an AI system aiding developers.
You are working with a part of a large program called the ""Working Set.""
Before starting, check if you need more files to solve the task.
Do not edit files without knowing their contents!
Ask for them in normal conversational format instead.

# Working set

docs/README.md:
```
Warn: This README is AI generated, just like all the source files of this project.

# Junior - Your AI-first IDE 

[![Video: Junior codes itself](/assets/video_cover.jpg)](https://youtu.be/NL4uFJSvfW0)

*""Video: Junior codes itself""*

Junior is an **AI-first IDE** targeting craftsmen, professional programmers who enjoy customizing and fine-tuning their tools. Embracing a design philosophy of being simple, configurable, and auditable, Junior offers a unique space where developers can work hand-in-hand with AI throughout the development process.

With a structured task descriptor and by spotlighting relevant parts of your project, you can delegate tasks such as code implementation, documentation, testing, and more, to Junior.

## Getting Started

For guidance on using Junior, please refer to [usage.md](usage.md).

## Contributing and Support

Your contributions make a difference! At Junior, we value the collaboration of the community. Your role as a contributor is to monitor the development, provide detailed prompts, and thoroughly review the generated outcomes.

For questions or assistance, please raise an issue in our GitHub repository.

**Note:** We've tested Junior primarily with the GPT-4 model. However, you're welcome to experiment with similarly capable models and share your findings. It's not compatible with GPT-3.5.

```


# Task

Improve the documentation!

Set target group better: ""...targeting professional programmers who enjoy...""
Add a note that Junior is written without manual coding since the very beginnings, well before the four buttons were all implemented. ( Reword this note to be brave but not what Hungarians call p??ffeszked?? )


# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, avoid using sed in favor of heredoc-ing full files using 'EOF' to prevent substitution.

OS: Debian


Installed tools: npm, jq


Do NOT write any text outside the script!

EXAMPLE START

```sh
#!/bin/sh
set -e
goal=[Task description, max 7 words]
echo ""Plan:""
echo ""1. [...]""
[Commands solving the task]
echo ""\033[32mDone: $goal\033[0m\n""
```

EXAMPLE END

",70
"You are Junior, an AI system aiding developers.
You are working with a part of a large program called the ""Working Set.""
Before starting, check if you need more files to solve the task.
Do not edit files without knowing their contents!
Ask for them in normal conversational format instead.

# Working set

```
./
?????€??€ .git/...
?????€??€ .github/...
?????€??€ .gitignore
?????€??€ .vscode/...
?????€??€ LICENSE.txt
?????€??€ README.md
?????€??€ change.sh
?????€??€ docs/...
?????€??€ integrations/...
?????€??€ node_modules/...
?????€??€ package-lock.json
?????€??€ package.json
?????€??€ prompt/...
?????€??€ prompt.md
?????€??€ prompt.yaml
?????€??€ scripts/...
?????€??€ src/...

```
```
docs/
?????€??€ .nojekyll
?????€??€ README.md
?????€??€ README.md.backup
?????€??€ _sidebar.md
?????€??€ _sidebar_backup.md
?????€??€ assets/...
?????€??€ descriptor.md
?????€??€ docsifyConfig.js
?????€??€ index.html
?????€??€ roadmap.md
?????€??€ screenshot.png
?????€??€ usage.md
?????€??€ web.md

```
docs/index.html:
```
<!DOCTYPE html>
<html lang=""en"">
<head>
  <meta charset=""UTF-8"">
  <title>Document</title>
  <meta http-equiv=""X-UA-Compatible"" content=""IE=edge,chrome=1"" />
  <meta name=""description"" content=""Description"">
  <meta name=""viewport"" content=""width=device-width, initial-scale=1.0, minimum-scale=1.0"">
  <link rel=""icon"" href=""assets/favicon.ico"" type=""image/x-icon"">
  <link rel=""stylesheet"" href=""//cdn.jsdelivr.net/npm/docsify@4/lib/themes/vue.css"">
</head>
<body>
  <style>
    .app-name-link img {
      max-width: 70px;
    }
  </style>
  <div id=""app""></div>
  <script src=""docsifyConfig.js""></script>
  <!-- Docsify v4 -->
  <script src=""//cdn.jsdelivr.net/npm/docsify@4""></script>
  <script async src=""https://platform.twitter.com/widgets.js"" charset=""utf-8""></script>
</body>
</html>

```


# Task

Implement the following feature!

- Create a plan!
- Create new files when needed!

Requirements:

Add margin to iframes. 
Factor out the css to a file in assets.



## Project Specifics

- Every js file should *only export a single function*!
- Use *ES6 imports*!
- Prefer *async/await* over promises!
- The frontend uses *Solidjs* and Tailwind, edit .jsx file accordingly!


# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, avoid using sed in favor of heredoc-ing full files using 'EOF' to prevent substitution.

OS: Debian


Installed tools: npm, jq


Do NOT write any text outside the script!

EXAMPLE START

```sh
#!/bin/sh
set -e
goal=[Task description, max 7 words]
echo ""Plan:""
echo ""1. [...]""
[Commands solving the task]
echo ""\033[32mDone: $goal\033[0m\n""
```

EXAMPLE END

",92
"You are Junior, an AI system aiding developers.
You are working with a part of a large program called the ""Working Set.""
Before starting, check if you need more files to solve the task.
Do not edit files without knowing their contents!
Ask for them in normal conversational format instead.

# Working set

```
./
?????€??€ .git/...
?????€??€ .github/...
?????€??€ .gitignore
?????€??€ .vscode/...
?????€??€ LICENSE.txt
?????€??€ README.md
?????€??€ change.sh
?????€??€ docs/...
?????€??€ integrations/...
?????€??€ node_modules/...
?????€??€ package-lock.json
?????€??€ package.json
?????€??€ prompt/...
?????€??€ prompt.md
?????€??€ prompt.yaml
?????€??€ scripts/...
?????€??€ src/...

```
docs/_sidebar.md:
```
* [Junior Docs](./README.md)
* [Usage](./usage.md)
* [Web](./web.md)
* [Prompt Descriptor](./descriptor.md)
* [Roadmap](./roadmap.md)

```


# Task

Implement the following feature!

- Create a plan!
- Create new files when needed!

Requirements:

Include this in the sidebar as html if possible!
<blockquote class=""twitter-tweet""><p lang=""en"" dir=""ltr"">After 34 years of daily CODING, I STOPPED and now only write software in ENGLISH with the Junior AI IDE. So much powerful than naked ChatGPT. <a href=""https://t.co/MD1G1kIQte"">https://t.co/MD1G1kIQte</a> <a href=""https://twitter.com/hashtag/AI?src=hash&amp;ref_src=twsrc%5Etfw"">#AI</a> <a href=""https://twitter.com/hashtag/development?src=hash&amp;ref_src=twsrc%5Etfw"">#development</a> <a href=""https://twitter.com/hashtag/JuniorIDE?src=hash&amp;ref_src=twsrc%5Etfw"">#JuniorIDE</a> <a href=""https://twitter.com/hashtag/ChatGPT?src=hash&amp;ref_src=twsrc%5Etfw"">#ChatGPT</a></p>&mdash; Kriszti??n Sch??ffer (@tisztamo_x) <a href=""https://twitter.com/tisztamo_x/status/1693697665937166701?ref_src=twsrc%5Etfw"">August 21, 2023</a></blockquote> <script async src=""https://platform.twitter.com/widgets.js"" charset=""utf-8""></script>



## Project Specifics

- Every js file should *only export a single function*!
- Use *ES6 imports*!
- Prefer *async/await* over promises!
- The frontend uses *Solidjs* and Tailwind, edit .jsx file accordingly!


# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, avoid using sed in favor of heredoc-ing full files using 'EOF' to prevent substitution.

OS: Debian


Installed tools: npm, jq


Do NOT write any text outside the script!

EXAMPLE START

```sh
#!/bin/sh
set -e
goal=[Task description, max 7 words]
echo ""Plan:""
echo ""1. [...]""
[Commands solving the task]
echo ""\033[32mDone: $goal\033[0m\n""
```

EXAMPLE END

",25
"You are Junior, an AI system aiding developers.
You are working with a part of a large program called the ""Working Set.""
Before starting, check if you need more files to solve the task.
Do not edit files without knowing their contents!
Ask for them in normal conversational format instead.

# Working set

```
./
?????€??€ .git/...
?????€??€ .github/...
?????€??€ .gitignore
?????€??€ .vscode/...
?????€??€ LICENSE.txt
?????€??€ README.md
?????€??€ change.sh
?????€??€ docs/...
?????€??€ integrations/...
?????€??€ node_modules/...
?????€??€ package-lock.json
?????€??€ package.json
?????€??€ prompt/...
?????€??€ prompt.md
?????€??€ prompt.yaml
?????€??€ scripts/...
?????€??€ src/...

```
.gitignore:
```
secret.sh
node_modules/
tmp/
prompt.yaml
prompt.md
change.sh

```


# Task

Implement the following feature!

- Create a plan!
- Create new files when needed!

Requirements:

Gitignore only ./prompt.yaml ./prompt.md and ./change.sh not same-name files in subdirs.
Those files are already added to git. Delete them now so that if later modified, their modification will be ignored.



## Project Specifics

- Every js file should *only export a single function*!
- Use *ES6 imports*!
- Prefer *async/await* over promises!
- The frontend uses *Solidjs* and Tailwind, edit .jsx file accordingly!


# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, avoid using sed in favor of heredoc-ing full files using 'EOF' to prevent substitution.

OS: OSX

Installed tools: npm, jq


Do NOT write any text outside the script!

EXAMPLE START

```sh
#!/bin/sh
set -e
goal=[Task description, max 7 words]
echo ""Plan:""
echo ""1. [...]""
[Commands solving the task]
echo ""\033[32mDone: $goal\033[0m\n""
```

EXAMPLE END

",98
"You are Junior, an AI system aiding developers.
You are working with a part of a large program called the ""Working Set.""
Before starting, check if you need more files to solve the task.
Do not edit files without knowing their contents!
Ask for them in normal conversational format instead.

# Working set

```
./
?????€??€ .git/...
?????€??€ .github/...
?????€??€ .gitignore
?????€??€ .vscode/...
?????€??€ LICENSE.txt
?????€??€ README.md
?????€??€ change.sh
?????€??€ docs/...
?????€??€ integrations/...
?????€??€ node_modules/...
?????€??€ package-lock.json
?????€??€ package.json
?????€??€ prompt/...
?????€??€ prompt.md
?????€??€ prompt.yaml
?????€??€ scripts/...
?????€??€ src/...

```
```
prompt/
?????€??€ archive/...
?????€??€ defaults/...
?????€??€ format/...
?????€??€ format.md
?????€??€ installedTools.md
?????€??€ os.md
?????€??€ projectSpecifics.md
?????€??€ system.md
?????€??€ task/...

```
.gitignore:
```
secret.sh
node_modules/
tmp/


```

src/execute/executeAndForwardOutput.js:
```
import { writeFile } from 'fs/promises';
import { spawn } from 'child_process';
import { makeExecutable } from './makeExecutable.js';

async function executeAndForwardOutput(code, next) {
  try {
    if (code == null || !code.startsWith('#!')) {
      throw new Error('Code does not start with a shebang');
    }
    await writeFile('./change.sh', code);
    await makeExecutable('./change.sh');
    
    const child = spawn('./change.sh', [], { shell: true });
    let commandOutput = '';

    child.stdout.on('data', (data) => {
      console.log(`${data}`);
      commandOutput += data;
    });

    child.stderr.on('data', (data) => {
      console.error(`${data}`);
      commandOutput += data;
    });

    child.on('close', (code) => {
      if (next && typeof next === 'function') {
        next(code, commandOutput);
      }
    });
  } catch (err) {
    console.log(err);
  }
}

export { executeAndForwardOutput };

```


# Task

Implement the following feature!

- Create a plan!
- Create new files when needed!

Requirements:

gitignore prompt.yaml, prompt.md and change.sh Note that they are already added to git.
Before executing the change:
  - Create a new dir prompt/history/[year]/[month]/[day]/[time]_[goal]/
  - Use the current date and the goal variable set in the change script by a line goal=""[goal]""
  - Copy the newly gitignored files to the new dir and log ""Audit trail saved to [dir path]""



## Project Specifics

- Every js file should *only export a single function*!
- Use *ES6 imports*!
- Prefer *async/await* over promises!
- The frontend uses *Solidjs* and Tailwind, edit .jsx file accordingly!


# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, avoid using sed in favor of heredoc-ing full files using 'EOF' to prevent substitution.

OS: OSX

Installed tools: npm, jq


Do NOT write any text outside the script!

EXAMPLE START

```sh
#!/bin/sh
set -e
goal=[Task description, max 7 words]
echo ""Plan:""
echo ""1. [...]""
[Commands solving the task]
echo ""\033[32mDone: $goal\033[0m\n""
```

EXAMPLE END

",95
"You are Junior, an AI system aiding developers.
You are working with a part of a large program called the ""Working Set.""
Before starting, check if you need more files to solve the task.
Do not edit files without knowing their contents!
Ask for them in normal conversational format instead.

# Working set

integrations/vscode/src/writePromptFile.ts:
```
import * as vscode from 'vscode';
import * as yaml from 'js-yaml';

export const writePromptFile = async (filePath: string, data: any) => {
    let openedDocument = vscode.workspace.textDocuments.find(doc => doc.fileName === filePath);
    if (!openedDocument) {
        openedDocument = await vscode.workspace.openTextDocument(filePath);
    }
    
    const edit = new vscode.WorkspaceEdit();
    const range = new vscode.Range(new vscode.Position(0, 0), new vscode.Position(openedDocument.lineCount, 0));
    edit.replace(openedDocument.uri, range, yaml.dump(data));
    await vscode.workspace.applyEdit(edit);
    
    // Save the document unconditionally.
    openedDocument.save();
    
    // Make the prompt.yaml the active document.
    vscode.window.showTextDocument(openedDocument);
};

```

integrations/vscode/src/writeAttention.ts:
```
import * as vscode from 'vscode';
import * as yaml from 'js-yaml';
import { getRootWorkspace } from './getRootWorkspace';
import { getPromptFilePath } from './getPromptFilePath';
import { getCurrentOpenDocuments } from './getCurrentOpenDocuments';
import { readPromptFile } from './readPromptFile';
import { filterAttentionExcludes } from './filterAttentionExcludes';
import { writePromptFile } from './writePromptFile';
import { PromptFile } from './types';

export const writeAttention = async () => {
    const rootFolder = getRootWorkspace();
    if (!rootFolder) {
        return;
    }

    const promptFilePath = getPromptFilePath(rootFolder);
    const excludeList = vscode.workspace.getConfiguration('junior').get('attentionExcludeList', []);
    try {
        if (promptFilePath) {
            const currentWindows = getCurrentOpenDocuments(rootFolder);
            const attentionSection = filterAttentionExcludes(currentWindows, excludeList, rootFolder);
            const promptFile: PromptFile = await readPromptFile(promptFilePath);
            promptFile.attention = attentionSection;
            writePromptFile(promptFilePath, promptFile);
        } else {
            vscode.window.showErrorMessage('No prompt.yaml file found in the project root!');
        }
    } catch (error) {
        vscode.window.showErrorMessage('Error updating the prompt.yaml file!');
    }
};

```

integrations/vscode/src/types.ts:
```
export interface PromptFile {
    attention?: string[];
    [key: string]: any;  // Allow additional properties
}

```


# Task

Implement the following feature!

- Create a plan!
- Create new files when needed!

Requirements:

Directories are entries in the attention that end with /
When overwriting the attention, preserve the directory entries in it.



## Project Specifics

- Every js file should *only export a single function*!
- Use *ES6 imports*!
- Prefer *async/await* over promises!
- The frontend uses *Solidjs* and Tailwind, edit .jsx file accordingly!


# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, avoid using sed in favor of heredoc-ing full files using 'EOF' to prevent substitution.

OS: OSX

Installed tools: npm, jq


Do NOT write any text outside the script!

EXAMPLE START

```sh
#!/bin/sh
set -e
goal=[Task description, max 7 words]
echo ""Plan:""
echo ""1. [...]""
[Commands solving the task]
echo ""\033[32mDone: $goal\033[0m\n""
```

EXAMPLE END

",10
"You are Junior, an AI system aiding developers.
You are working with a part of a large program called the ""Working Set.""
Before starting, check if you need more files to solve the task.
Do not edit files without knowing their contents!
Ask for them in normal conversational format instead.

# Working set

integrations/vscode/src/writeAttention.ts:
```
import * as vscode from 'vscode';
import * as yaml from 'js-yaml';
import { getRootWorkspace } from './getRootWorkspace';
import { getPromptFilePath } from './getPromptFilePath';
import { getCurrentOpenDocuments } from './getCurrentOpenDocuments';
import { readPromptFile } from './readPromptFile';
import { writePromptFile } from './writePromptFile';
import { filterAttentionExcludes } from './filterAttentionExcludes';
import { updateEditorContents } from './updateEditorContents';
import { PromptFile } from './types';

export const writeAttention = async () => {
    const rootFolder = getRootWorkspace();
    if (!rootFolder) {
        return;
    }

    const promptFilePath = getPromptFilePath(rootFolder);
    const excludeList = vscode.workspace.getConfiguration('junior').get('attentionExcludeList', []);
    try {
        if (promptFilePath) {
            const currentWindows = getCurrentOpenDocuments(rootFolder);
            
            const attentionSection = filterAttentionExcludes(currentWindows, excludeList, rootFolder);
            
            const promptFile: PromptFile = await readPromptFile(promptFilePath);
            promptFile.attention = attentionSection;
            
            const newContents = yaml.dump(promptFile);
            await updateEditorContents(promptFilePath, newContents);
            
            writePromptFile(promptFilePath, promptFile);
            
            vscode.window.showInformationMessage('Prompt file updated successfully!');
        } else {
            vscode.window.showErrorMessage('No prompt.yaml file found in the project root!');
        }
    } catch (error) {
        vscode.window.showErrorMessage('Error updating the prompt.yaml file!');
    }
};

```

integrations/vscode/src/writePromptFile.ts:
```
import * as fs from 'fs';
import * as yaml from 'js-yaml';

export const writePromptFile = (filePath: string, data: any) => {
    fs.writeFileSync(filePath, yaml.dump(data), 'utf8');
};

```

integrations/vscode/src/readPromptFile.ts:
```
import * as fs from 'fs';
import * as vscode from 'vscode';
import * as yaml from 'js-yaml';
import { PromptFile } from './types';

export const readPromptFile = async (filePath: string): Promise<PromptFile> => {
    const openedDocument = vscode.workspace.textDocuments.find(doc => doc.fileName === filePath);
    if (openedDocument) {
        return yaml.load(openedDocument.getText()) as PromptFile;
    }
    return yaml.load(fs.readFileSync(filePath, 'utf8')) as PromptFile;
};

```

integrations/vscode/src/types.ts:
```
export interface PromptFile {
    attention?: string[];
    [key: string]: any;  // Allow additional properties
}

```


# Task

Fix the following issue!

If the prompt.yaml is opened in the editor, vscode shows it as changed after saving.
We need to fix this: As we write the contents both to the file and the editor buffer,
vscode should show it as unchanged.
Also remove the information message.



## Project Specifics

- Every js file should *only export a single function*!
- Use *ES6 imports*!
- Prefer *async/await* over promises!
- The frontend uses *Solidjs* and Tailwind, edit .jsx file accordingly!


# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, avoid using sed in favor of heredoc-ing full files using 'EOF' to prevent substitution.

OS: OSX

Installed tools: npm, jq


Do NOT write any text outside the script!

EXAMPLE START

```sh
#!/bin/sh
set -e
goal=[Task description, max 7 words]
echo ""Plan:""
echo ""1. [...]""
[Commands solving the task]
echo ""\033[32mDone: $goal\033[0m\n""
```

EXAMPLE END

",78
"You are Junior, an AI system aiding developers.
You are working with a part of a large program called the ""Working Set.""
Before starting, check if you need more files to solve the task.
Do not edit files without knowing their contents!
Ask for them in normal conversational format instead.

# Working set

integrations/vscode/src/writeAttention.ts:
```
import * as vscode from 'vscode';
import { getRootWorkspace } from './getRootWorkspace';
import { getPromptFilePath } from './getPromptFilePath';
import { getCurrentOpenDocuments } from './getCurrentOpenDocuments';
import { readPromptFile } from './readPromptFile';
import { writePromptFile } from './writePromptFile';
import { updateAttentionSection } from './updateAttentionSection';
import { PromptFile } from './types';

export const writeAttention = async () => {
    const rootFolder = getRootWorkspace();
    if (!rootFolder) {
        return;
    }

    const promptFilePath = getPromptFilePath(rootFolder);
    const excludeList = vscode.workspace.getConfiguration('junior').get('attentionExcludeList', []);
    try {
        if (promptFilePath) {
            const currentWindows = getCurrentOpenDocuments(rootFolder);
            const attentionSection = updateAttentionSection(currentWindows, excludeList, rootFolder);
            const promptFile: PromptFile = readPromptFile(promptFilePath);
            promptFile.attention = attentionSection;
            writePromptFile(promptFilePath, promptFile);
            vscode.window.showInformationMessage('Prompt file updated successfully!');
        } else {
            vscode.window.showErrorMessage('No prompt.yaml file found in the project root!');
        }
    } catch (error) {
        vscode.window.showErrorMessage('Error updating the prompt.yaml file!');
    }
};

```

integrations/vscode/src/types.ts:
```
export interface PromptFile {
    attention?: string[];
    [key: string]: any;  // Allow additional properties
}

```

integrations/vscode/src/updateAttentionSection.ts:
```
import { filterAttentionExcludes } from './filterAttentionExcludes';

export const updateAttentionSection = (currentWindows: string[], excludeList: string[], rootFolder: string) => {
    return filterAttentionExcludes(currentWindows, excludeList, rootFolder);
};

```

integrations/vscode/src/readPromptFile.ts:
```
import * as fs from 'fs';
import * as yaml from 'js-yaml';
import { PromptFile } from './types';

export const readPromptFile = (filePath: string): PromptFile => {
    return yaml.load(fs.readFileSync(filePath, 'utf8')) as PromptFile;
};

```

integrations/vscode/src/writePromptFile.ts:
```
import * as fs from 'fs';
import * as yaml from 'js-yaml';

export const writePromptFile = (filePath: string, data: any) => {
    fs.writeFileSync(filePath, yaml.dump(data), 'utf8');
};

```


# Task

Implement the following feature!

- Create a plan!
- Create new files when needed!

Requirements:

When prompt.yaml is opened in vscode, it should be updated in the editor before writing the underlying file.



## Project Specifics

- Every js file should *only export a single function*!
- Use *ES6 imports*!
- Prefer *async/await* over promises!
- The frontend uses *Solidjs* and Tailwind, edit .jsx file accordingly!


# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, avoid using sed in favor of heredoc-ing full files using 'EOF' to prevent substitution.

OS: OSX

Installed tools: npm, jq


Do NOT write any text outside the script!

EXAMPLE START

```sh
#!/bin/sh
set -e
goal=[Task description, max 7 words]
echo ""Plan:""
echo ""1. [...]""
[Commands solving the task]
echo ""\033[32mDone: $goal\033[0m\n""
```

EXAMPLE END

",70
"You are Junior, an AI system aiding developers.
You are working with a part of a large program called the ""Working Set.""
Before starting, check if you need more files to solve the task.
Do not edit files without knowing their contents!
Ask for them in normal conversational format instead.

# Working set

integrations/vscode/src/writeAttention.ts:
```
import * as vscode from 'vscode';
import * as fs from 'fs';
import * as path from 'path';
import * as yaml from 'js-yaml';
import { filterAttentionExcludes } from './filterAttentionExcludes';

export const writeAttention = async () => {
    const workspaceFolders = vscode.workspace.workspaceFolders;
    if (workspaceFolders === undefined) {
        return;
    }
    
    const rootFolder = workspaceFolders[0].uri.fsPath;
    const promptFilePath = path.join(rootFolder, 'prompt.yaml');
    const excludeList = vscode.workspace.getConfiguration('junior').get('attentionExcludeList', []);
    try {
        if (fs.existsSync(promptFilePath)) {
            const currentWindows = vscode.workspace.textDocuments.map(doc => path.relative(rootFolder, doc.fileName));
            const filteredWindows = filterAttentionExcludes(currentWindows, excludeList, rootFolder);
            const promptFile: any = yaml.load(fs.readFileSync(promptFilePath, 'utf8'));
            promptFile.attention = filteredWindows;
            fs.writeFileSync(promptFilePath, yaml.dump(promptFile), 'utf8');
            vscode.window.showInformationMessage('Prompt file updated successfully!');
        } else {
            vscode.window.showErrorMessage('No prompt.yaml file found in the project root!');
        }
    } catch (error) {
        vscode.window.showErrorMessage('Error updating the prompt.yaml file!');
    }
};

```


# Task

## Refactor by split

A file is too big. We need to split it into parts.
Identify the possible parts and refactor the code in separate files!

getRootWorkspace(): Returns the root of the current VSCode workspace.
getPromptFilePath(rootFolder: string): Takes the root folder and returns the path to the prompt.yaml file.
getCurrentOpenDocuments(rootFolder: string): Returns a list of currently open text documents relative to the root workspace.
readPromptFile(filePath: string): Reads and parses the prompt.yaml file, returning its content.
writePromptFile(filePath: string, data: any): Writes the updated data back to the prompt.yaml file.
updateAttentionSection(currentWindows: string[], excludeList: string[], rootFolder: string): Takes in the list of open documents, the exclusion list, and the root folder, then filters and returns the updated ""attention"" list.



# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, avoid using sed in favor of heredoc-ing full files using 'EOF' to prevent substitution.

OS: OSX

Installed tools: npm, jq


Do NOT write any text outside the script!

EXAMPLE START

```sh
#!/bin/sh
set -e
goal=[Task description, max 7 words]
echo ""Plan:""
echo ""1. [...]""
[Commands solving the task]
echo ""\033[32mDone: $goal\033[0m\n""
```

EXAMPLE END

",68
"You are Junior, an AI system aiding developers.
You are working with a part of a large program called the ""Working Set.""
Before starting, check if you need more files to solve the task.
Do not edit files without knowing their contents!
Ask for them in normal conversational format instead.

# Working set

docs/README.md:
```
Warn: This README is AI generated, just like all the source files of this project.

# Junior - Your AI-first IDE 

[![Video: Junior codes itself](/assets/video_cover.jpg)](https://youtu.be/NL4uFJSvfW0)

*""Video: Junior codes itself""*

Junior is an innovative **AI-first IDE** built to harness the full power of language models. With a setup reminiscent of how Linus Torvalds oversees the Linux Kernel development without writing the code himself, Junior offers a space for developers to communicate directly with AI and actively supervise the entire development process.

Guided by the spirit of craftsmanship, Junior is not only configurable and hackable but also simple and auditable. Our vision is to propel Junior into the same league as iconic tools such as git - another masterpiece by Linus, and the legendary LISP, a language revered by Paul Graham for its significance in enabling rapid development.

By offering specific task details through a prompt descriptor and spotlighting pertinent parts of your project, you can entrust tasks like code implementation, documentation, testing, and more, all to your AI Junior.

## Getting Started

For more insights on getting started, kindly refer to [usage.md](usage.md).

## Contributing and Support

Your contributions are invaluable! Bear in mind, we practice what we preach here. Junior is engineered to be self-reliant. As a contributor, your primary task will be to monitor the proceedings, provide comprehensive prompts, and rigorously review the outcomes.

For assistance, feel free to raise an issue in our GitHub repository.

**Note:** To experience the best results, it's advised to utilize the GPT-4 model or its latest successors.


```


# Task

Improve the documentation!

Make Getting Started and Contributing and Support a bit less hyping.
Change the note at the end to say we test with that model only, but you can try out similarly capable models and report your success. It will not work with 3.5 (reword if needed)


# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, avoid using sed in favor of heredoc-ing full files using 'EOF' to prevent substitution.

OS: OSX

Installed tools: npm, jq


Do NOT write any text outside the script!

EXAMPLE START

```sh
#!/bin/sh
set -e
goal=[Task description, max 7 words]
echo ""Plan:""
echo ""1. [...]""
[Commands solving the task]
echo ""\033[32mDone: $goal\033[0m\n""
```

EXAMPLE END

",15
"You are Junior, an AI system aiding developers.
You are working with a part of a large program called the ""Working Set.""
Before starting, check if you need more files to solve the task.
Do not edit files without knowing their contents!
Ask for them in normal conversational format instead.

# Working set

src/frontend/startVite.js:
```
import path from 'path';
import { fileURLToPath } from 'url';
import { createServer } from 'vite';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const projectRoot = path.resolve(__dirname, '../..');

export async function startVite() {
  const server = await createServer({
    root: projectRoot + '/src/frontend',
    server: {
      open: true,
    },
  });
  await server.listen();
  server.printUrls();
}

```


# Task

Implement the following feature!

- Create a plan!
- Create new files when needed!

Requirements:

Set the &#34;host&#34; boolean config based on the presence of the --host cli argument.



## Project Specifics

- Every js file should *only export a single function*!
- Use *ES6 imports*!
- Prefer *async/await* over promises!
- The frontend uses *Solidjs*, edit .jsx file accordingly


# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, avoid using sed in favor of heredoc-ing full files using 'EOF' to prevent substitution.

OS: OSX

Installed tools: npm, jq


Do NOT write any text outside the script!

EXAMPLE START

```sh
#!/bin/sh
set -e
goal=[Task description, max 7 words]
echo ""Plan:""
echo ""1. [...]""
[Commands solving the task]
echo ""\033[32mDone: $goal\033[0m\n""
```

EXAMPLE END

",80
"You are Junior, an AI system aiding developers.
You are working with a part of a large program called the ""Working Set.""
Before starting, check if you need more files to solve the task.
Do not edit files without knowing their contents!
Ask for them in normal conversational format instead.

# Working set

src/frontend/App.jsx:
```
import useKeyBindings from './service/useKeyBindings';
import keyBindings from './config/keyBindings';
import NavBar from './components/NavBar';
import PromptCreation from './components/PromptCreation';
import ChangeExecution from './components/ChangeExecution';
import ChangeInspection from './components/ChangeInspection';
import ChangeFinalization from './components/ChangeFinalization';

const App = () => {
  const bindings = keyBindings();
  useKeyBindings(bindings);

  return (
    <div>
      <div class=""bg-main max-w-desktop lg:max-w-desktop md:max-w-full sm:max-w-full xs:max-w-full mx-auto flex flex-col items-center space-y-8 px-2 sm:px-4 xs:px-4"">
        <NavBar />
        <PromptCreation />
        <ChangeExecution />
        <ChangeInspection />
        <ChangeFinalization />
      </div>
    </div>
  );
};

export default App;

```


# Task

Implement the following feature!

- Create a plan!
- Create new files when needed!

Requirements:

We need a padding at the bottom.
Additionally, always make the content full-height.



## Project Specifics

- Every js file should *only export a single function*!
- Use *ES6 imports*!
- Prefer *async/await* over promises!
- The frontend uses *Solidjs*, edit .jsx file accordingly


# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, avoid using sed in favor of heredoc-ing full files using 'EOF' to prevent substitution.

OS: OSX

Installed tools: npm, jq


Do NOT write any text outside the script!

EXAMPLE START

```sh
#!/bin/sh
set -e
goal=[Task description, max 7 words]
echo ""Plan:""
echo ""1. [...]""
[Commands solving the task]
echo ""\033[32mDone: $goal\033[0m\n""
```

EXAMPLE END

",75
"You are Junior, an AI system aiding developers.
You are working with a part of a large program called the ""Working Set.""
Before starting, check if you need more files to solve the task.
Do not edit files without knowing their contents!
Ask for them in normal conversational format instead.

# Working set

src/frontend/App.jsx:
```
import useKeyBindings from './service/useKeyBindings';
import keyBindings from './config/keyBindings';
import NavBar from './components/NavBar';
import PromptCreation from './components/PromptCreation';
import ChangeExecution from './components/ChangeExecution';
import ChangeInspection from './components/ChangeInspection';
import ChangeFinalization from './components/ChangeFinalization';

const App = () => {
  const bindings = keyBindings();
  useKeyBindings(bindings);

  return (
    <div class=""p-2 sm:p-4 xs:p-4"">
      <div class=""bg-main max-w-desktop lg:max-w-desktop md:max-w-full sm:max-w-full xs:max-w-full mx-auto flex flex-col items-center space-y-8 sm:p-0"">
        <NavBar />
        <PromptCreation />
        <ChangeExecution />
        <ChangeInspection />
        <ChangeFinalization />
      </div>
    </div>
  );
};

export default App;

```

src/frontend/index.html:
```
<!DOCTYPE html>
<html lang=""en"">
<head>
  <meta charset=""UTF-8"">
  <meta name=""viewport"" content=""width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"">
  <link rel=""icon"" href=""/assets/favicon.ico"" type=""image/x-icon"">
  <title>Junior</title>
</head>
<body>
  <div id=""app"" class=""bg-emphasize""></div>
  <script type=""module"" src=""/index.jsx""></script>
</body>
</html>

```


# Task

Implement the following feature!

- Create a plan!
- Create new files when needed!

Requirements:

There is a margin around the content which should be removed.
A horizontal padding should be added instead.



## Project Specifics

- Every js file should *only export a single function*!
- Use *ES6 imports*!
- Prefer *async/await* over promises!
- The frontend uses *Solidjs*, edit .jsx file accordingly


# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, avoid using sed in favor of heredoc-ing full files using 'EOF' to prevent substitution.

OS: OSX

Installed tools: npm, jq


Do NOT write any text outside the script!

EXAMPLE START

```sh
#!/bin/sh
set -e
goal=[Task description, max 7 words]
echo ""Plan:""
echo ""1. [...]""
[Commands solving the task]
echo ""\033[32mDone: $goal\033[0m\n""
```

EXAMPLE END

",75
"You are Junior, an AI system aiding developers.
You are working with a part of a large program called the ""Working Set.""
Before starting, check if you need more files to solve the task.
Do not edit files without knowing their contents!
Ask for them in normal conversational format instead.

# Working set

src/frontend/components/TasksList.jsx:
```
import { onMount, createEffect } from 'solid-js';
import { fetchTasks } from '../fetchTasks';
import { handleTaskChange } from '../service/handleTaskChange';
import { selectedTask, setSelectedTask } from '../model/selectedTask';
import { promptDescriptor } from '../model/promptDescriptor';
import { parseYamlAndGetTask } from '../service/parseYamlAndGetTask';

const TasksList = () => {
  const tasks = fetchTasks();

  createEffect(() => {
    const descriptor = promptDescriptor();
    if (descriptor !== '') {
      const task = parseYamlAndGetTask(descriptor);
      setSelectedTask(task);
    }
  });

  return (
    <div class=""w-full flex justify-start bg-emphasize text-emphasize p-2 rounded border border-gray-300"">
      <label class=""text-lg mr-2"">Task:</label>
      <select class=""w-full bg-emphasize text-emphasize text-lg"" value={selectedTask()} onChange={e => handleTaskChange(e)}>
        {tasks().map(task => <option value={task}>{task}</option>)}
      </select>
    </div>
  );
};

export default TasksList;

```

src/frontend/tailwind.config.cjs:
```
module.exports = {
  darkMode: 'class',
  content: [__dirname + '/**/*.html', __dirname + '/**/*.jsx'],
  theme: {
    screens: {
      'xs': '320px',
      'sm': '640px',
      'md': '768px',
      'lg': '1024px',
    },
    extend: {
      spacing: {
        '72': '18rem',
        '84': '21rem',
        '96': '24rem',
        '128': '32rem',
      },
      fontSize: {
        'btn': '1.5rem',
        'lg': '1.125rem',
      },
      padding: {
        'btn': '1.5rem',
      },
      maxWidth: {
        'desktop': '640px',
      },
      colors: {
        text: ""var(--text-color)"",
        emphasize: ""var(--emphasize-color)"",
        bg: ""var(--background-color)"",
      },
      backgroundColor: {
        main: ""var(--background-color)"",
        emphasize: ""var(--background-emphasize-color)"",
      },
    },
  },
  variants: {
    extend: {},
  },
  plugins: [],
}

```

src/frontend/styles/colors.css:
```
:root {
  --text-color: #1a202c;
  --background-color: #f7fafc;
  --emphasize-color: #16181f;
  --background-emphasize-color: #f2f4f6;
}

.dark {
  --text-color: #f7fafc;
  --background-color: #1a202c;
  --emphasize-color: #f2f4f6;
  --background-emphasize-color: #141618;
}

```


# Task

Implement the following feature!

- Create a plan!
- Create new files when needed!

Requirements:

Introduce a new color for borders and use it!
The current bg-gray-300 is good for the light them but we need another one with less contrast for the dark.



## Project Specifics

- Every js file should *only export a single function*!
- Use *ES6 imports*!
- Prefer *async/await* over promises!
- The frontend uses *Solidjs*, edit .jsx file accordingly


# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, avoid using sed in favor of heredoc-ing full files using 'EOF' to prevent substitution.

OS: OSX

Installed tools: npm, jq


Do NOT write any text outside the script!

EXAMPLE START

```sh
#!/bin/sh
set -e
goal=[Task description, max 7 words]
echo ""Plan:""
echo ""1. [...]""
[Commands solving the task]
echo ""\033[32mDone: $goal\033[0m\n""
```

EXAMPLE END

",95
"You are AI Junior, you code like Donald Knuth.

# Working set

./docs/web.md:
```
# Web Interface

Junior's web interface was designed for use with ChatGPT Pro and doesn't require an API key.

## Architecture

The web interface is composed of two different servers: a frontend and a backend. The frontend server runs on port 5864, and the backend server runs on port 10101.

## Starting the Web Interface

Run the application with `junior-web` from your project. A web browser window will automatically open at `http://localhost:5864`, which is where you can access the web interface.

For configuration options and details, refer to the [Configuration](./config/env_or_cli.md) documentation.

## Workflow

The typical workflow begins with editing the `prompt.yaml` file in your code editor of choice (we recommend Visual Studio Code with the Junior plugin for an optimal experience). Once you're satisfied with your task setup, you proceed to the web interface for execution and monitoring.

## Usage

The web interface has a few interactive components:

![Web Interface](./screenshot.png)

- **Generate & Copy Prompt button (Blue)**: Click this to generate a task prompt based on your `prompt.yaml` file and copy it to your clipboard. The copied prompt should be pasted to ChatGPT 4 or similar for execution.

- **Paste & Execute Change button (Orange)**: Paste the response from the AI model (a shell script) into the input field and click this button to execute the changes.

- **Roll Back to Last Commit button (Red)**: If you made a mistake or aren't happy with the changes, click this button to revert to the last commit. Please note, the rollback operation preserves the `prompt.yaml` file, but drops every change since the last commit, including new files created in the meantime, even if they were not created by Junior.

- **Commit Changes button (Green)**: After you're satisfied with your changes, click this button to commit your modifications to git.

- **Terminal**: Displays the output of your command execution. It's a simple console that shows the progress of the task.

For a more detailed guide on using the web interface, refer to our video tutorial [here](https://youtu.be/W_iwry8uT7E).

Remember, you can always refer to your `prompt.yaml` file to modify the task details or attention mechanism.

Happy developing with your AI contributor!

```

# Task

Improve the documentation!

- Fix the naming of ChatGPT Plus (not Pro)
- Remove the architecture section
- Rewrite the workflow section: Editing prompt.yaml directly is not needed anymore, remove. The current workflow is: Starting junior-web from the project dir, entering the requirements, selecting the attention files, generating the prompt, executing it with ChatGPT and pasting back the output for execution.

Do NOT create backup files.

# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, avoid using sed in favor of heredoc-ing full files.

OS: OSX

Installed tools: npm, jq


Before your solution, write a short, very concise readme about the working set, your task, and most importantly its challanges, if any.


EXAMPLE START
```sh
#!/bin/sh
set -e
goal=[Task description, max 9 words]
echo ""Plan:""
echo ""1. [...]""
cat > x.js << 'EOF'
[...]
'EOF'
echo ""\033[32mDone: $goal\033[0m\n""
```
EXAMPLE END

Before starting, check if you need more files or info to solve the task.

If the task is not clear:

EXAMPLE START
I need more information to solve the task. [Description of the missing info]
EXAMPLE END

Do not edit files not provided in the working set!
If you need more files:

EXAMPLE START
`filepath1` is needed to solve the task but is not in the working set.
EXAMPLE END

",86
"You are Junior, an AI system aiding developers. You are working with a part of a large program called the ""Working Set."" Ask for contents of subdirectories if needed. Some files are printed in the working set. Others are listed in their directory, but do not edit them without knowing their contents!

# Working set

package.json:
```
{
  ""name"": ""@aijunior/dev"",
  ""version"": ""0.1.3"",
  ""description"": ""Your AI Contributor which codes itself"",
  ""type"": ""module"",
  ""main"": ""src/main.js"",
  ""bin"": {
    ""junior"": ""src/main.js"",
    ""junior-web"": ""src/web.js"",
    ""junior-init"": ""src/init.js""
  },
  ""scripts"": {
    ""cli"": ""node src/main.js"",
    ""start"": ""node src/web.js"",
    ""build:css"": ""postcss ./src/frontend/styles.css -o ./dist/styles.css"",
    ""update-logo"": ""node ./scripts/updateLogo.js"",
    ""delete-branches"": ""node ./scripts/clearBranchesCommand.js""
  },
  ""keywords"": [
    ""cli"",
    ""uppercase""
  ],
  ""author"": """",
  ""license"": ""GPL"",
  ""dependencies"": {
    ""@types/js-yaml"": ""^4.0.5"",
    ""autoprefixer"": ""^10.4.14"",
    ""chatgpt"": ""^5.2.4"",
    ""cors"": ""^2.8.5"",
    ""docsify-cli"": ""^4.4.4"",
    ""ejs"": ""^3.1.9"",
    ""express"": ""^4.18.2"",
    ""highlight.js"": ""^11.8.0"",
    ""js-yaml"": ""^4.1.0"",
    ""markdown-it"": ""^13.0.1"",
    ""marked"": ""^5.1.0"",
    ""postcss"": ""^8.4.26"",
    ""postcss-nested"": ""^6.0.1"",
    ""sharp"": ""^0.32.4"",
    ""simple-git"": ""^3.19.1"",
    ""solid-js"": ""^1.7.7"",
    ""tailwindcss"": ""^3.3.3"",
    ""vite"": ""^4.3.9"",
    ""vite-plugin-solid"": ""^2.7.0"",
    ""ws"": ""^8.13.0""
  },
  ""directories"": {
    ""doc"": ""docs""
  },
  ""repository"": {
    ""type"": ""git"",
    ""url"": ""git+https://github.com/tisztamo/Junior.git""
  },
  ""bugs"": {
    ""url"": ""https://github.com/tisztamo/Junior/issues""
  },
  ""homepage"": ""https://github.com/tisztamo/Junior#readme""
}

```

src/git/clearBranches.js:
```
import { promisify } from 'util';
import { exec as execCb } from 'child_process';

const exec = promisify(execCb);

export default async function deleteBranches(exceptions = []) {
  try {
    const { stdout: currentBranch } = await exec('git rev-parse --abbrev-ref HEAD');
    const { stdout: allBranches } = await exec('git for-each-ref --format=""%(refname:short)"" refs/heads');

    const branches = allBranches.split('\n').filter(branch => branch !== currentBranch.trim() && !exceptions.includes(branch));

    for (const branch of branches) {
      await executeCommand(`git branch -d ${branch}`);
    }
  } catch (err) {
    console.error(`An error occurred: ${err}`);
  }
}

async function executeCommand(command) {
  try {
    console.log(`Running command: ${command}`);
    const { stdout } = await exec(command);
    console.log(`stdout: ${stdout}`);
  } catch (err) {
    throw err;
  }
}

```


# Task

Move the following files to the specified target dirs!

Find out the best target dir if it is not specified!

You need to follow dependencies to maintain coherence.

Before executing, write a concise plan! The plan should show:
 - How do you avoid breaking other parts of the code.
 - If you had to choose, your way of thinking.

rename delete-branches to clear-branches
rename deleteBranches to clearBranches


# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, avoid using sed in favor of heredoc-ing full files using 'EOF' to prevent substitution.

OS: OSX

Installed tools: npm, jq


Do NOT write any text outside the script!

EXAMPLE START

```sh
#!/bin/sh
set -e
goal=[Task description, max 7 words]
echo ""Plan:""
echo ""1. [...]""
[Commands solving the task]
echo ""\033[32mDone: $goal\033[0m\n""
```

EXAMPLE END

",95
"You are Junior, an AI system aiding developers. You are working with a part of a large program called the ""Working Set."" Ask for contents of subdirectories if needed. Some files are printed in the working set. Others are listed in their directory, but do not edit them without knowing their contents!

# Working set

src/execute/extractCode.js:
```
function extractCode(res) {
  const match = res.match(/```(sh|bash)([\s\S]*?)```/);
  return match ? match[2].trim() : null;
}

export { extractCode };

```

src/backend/handlers/executeHandler.js:
```
import { executeAndForwardOutput } from '../../execute/executeAndForwardOutput.js';

function executeHandler(req, res) {
  executeAndForwardOutput(req.body.change, (result, output) => {
    res.json({ result, output });
  });
}

export { executeHandler };

```


# Task

Implement the following feature!

- Create a plan!
- Create new files when needed!

Requirements:

Extract the code from the change before executing!



## Project Specifics

- Every js file should *only export a single function*!
- Use *ES6 imports*!
- Prefer *async/await* over promises!
- The frontend uses *Solidjs*, edit .jsx file accordingly


# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, avoid using sed in favor of heredoc-ing full files using 'EOF' to prevent substitution.

OS: OSX

Installed tools: npm, jq


Do NOT write any text outside the script!

EXAMPLE START

```sh
#!/bin/sh
set -e
goal=[Task description, max 7 words]
echo ""Plan:""
echo ""1. [...]""
[Commands solving the task]
echo ""\033[32mDone: $goal\033[0m\n""
```

EXAMPLE END

",45
"# Working set

docs/README.md:
```
Warn: This README is AI generated, just like all the source files of this project.

# Junior - Your AI contributor which codes itself.

[![Video: Junior codes itself](/assets/video_cover.jpg)](https://www.youtube.com/watch?v=W_iwry8uT7E)

*""Video: Junior codes itself""*
## Description

Junior is an exploratory project aimed at revolutionizing the way programmers interact with the development process. Just like how Linus Torvalds oversees the Linux Kernel development without coding himself, this project allows developers to communicate with the AI and supervise the development process.

Isn't that already possible with ChatGPT? No, LLMs have very limited ""working memory"", so it is not possible to directly work with them on large codebases.

By providing specific task details in a prompt descriptor and highlighting the relevant parts of your project, you can delegate code implementation, documentation, testing, and more to your AI Junior.

## Getting Started

### Installation

To install, clone the repository and run `npm install` in the root directory. Additionally, you can install the ""Junior"" vscode extension from the vscode extension marketplace.

### Usage

#### Web Interface

Run the application with `npm start` to start a local server, where you can generate a prompt and automatically copy it to paste into ChatGPT. The web interface is designed for use with ChatGPT Pro and doesn't require an API key. For more information about the web interface, please refer to [doc/web.md](doc/web.md).

#### Command-line interface (CLI)

To start the CLI, use `npm run cli`. This mode uses the ChatGPT API, and you'll need an API key stored in the `OPENAI_API_KEY` environment variable.

### The Prompt Descriptor

The prompt descriptor is a YAML file that outlines the details necessary for generating a task prompt for the AI model. For more details, refer to [descriptor.md](descriptor.md).

### Attention Mechanism

The attention mechanism guides the AI model by providing it with a working set. It helps overcome the limited working memory of large language models.

The working set is a subset of the entire project that's currently in focus. It includes both files and directories. For files, the content is directly provided to the AI. For directories, a brief list of files and subdirectories within them is presented.

## Contributing and Support

Contributions are welcome! Remember, we eat our own dog food in this project. Junior is designed to write itself. Your main role will be to oversee the work, provide detailed prompts, and review the outcomes.

For support, please create an issue in the GitHub repository.

**Note:** For meaningful results, it's recommended to use the GPT-4 model or a more recent version.


```


# Task

Implement the following feature!

- Create a plan!
- Create new files when needed!

Requirements:

- Remove every detail and subsection from &#34;## Getting Started&#34; - Instead add a link to usage.md &#34;usage&#34;, in short call-to-action sentence. The file already exists, do not edit.



## Project Specifics

- Every js file should *only export a single function*!
- Use *ES6 imports*!
- Prefer *async/await* over promises!
- The frontend uses *Solidjs*, edit .jsx file accordingly


# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, avoid using sed in favor of heredoc-ing full files using 'EOF' to prevent substitution.

OS: OSX

Installed tools: npm, jq


Do NOT write any text outside the script!

EXAMPLE START

```sh
#!/bin/sh
set -e
goal=[Task description, max 7 words]
echo ""Plan:""
echo ""1. [...]""
[Commands solving the task]
echo ""\033[32mDone: $goal\033[0m\n""
```

EXAMPLE END

",61
"You are AI Junior, you code like Donald Knuth.

# Working set

./src/frontend/components/terminal/TerminalSummary.jsx:
```
import { createEffect, createSignal } from 'solid-js';
import { prependAndExtractLastLine } from './prependAndExtractLastLine';

export function TerminalSummary(props) {
  const [lastLineSignal, setLastLineSignal] = createSignal("""");
  let localLastLine = """";

  createEffect(() => {
    localLastLine = prependAndExtractLastLine(localLastLine, props.lastWritten);
    if (localLastLine !== """") {
      setLastLineSignal(localLastLine);
    }
  });

  return <span>{lastLineSignal()}</span>;
}

```
./src/frontend/components/terminal/TerminalComponent.jsx:
```
import { onCleanup, onMount, createSignal } from 'solid-js';
import 'xterm/css/xterm.css';
import terminalConnection from '../../service/terminal/terminalConnection';
import { setupXTerm } from '../../service/terminal/setupXTerm';
import { sendTerminalResizeNotification } from '../../service/terminal/sendTerminalResizeNotification';
import DetailsComponent from '../DetailsComponent';
import VirtualKey from './VirtualKey';
import terminalVirtualKeyBindings from '../../config/terminalVirtualKeyBindings';
import { TerminalSummary } from './TerminalSummary';

const TerminalComponent = () => {
  let container;
  const [lastWritten, setLastWritten] = createSignal('');
  const { term, fitAddon } = setupXTerm();

  const sendVirtualKey = (key) => {
    terminalConnection.sendDataToTerminal(JSON.stringify({ type: 'input', data: key }));
    term.focus();
  };

  onMount(() => {
    term.open(container);
    fitAddon.fit();

    const { rows, cols } = term;
    sendTerminalResizeNotification(rows, cols);

    terminalConnection.setOnDataReceived((data) => {
      term.write(data);
      setLastWritten(data); // Update the lastWritten signal on data receive
    });

    term.onData((data) => {
      terminalConnection.sendDataToTerminal(JSON.stringify({ type: 'input', data }));
    });

    term.onResize(({ newRows, newCols }) => {
      sendTerminalResizeNotification(newRows, newCols);
    });
  });
  
  onCleanup(() => {
    term.dispose();
    terminalConnection.closeConnection();
  });

  return (
    <DetailsComponent 
      defaultState=""closed""
      localStorageKey=""terminalState""
      generateHeader={() => <>Terminal <TerminalSummary lastWritten={lastWritten()} /></>}  // Use TerminalSummary here
      classes=""rounded border p-2 w-full border-border bg-emphasize""
    >
      <div ref={container}></div>
      <div class=""flex overflow-x-auto whitespace-nowrap"">
        {terminalVirtualKeyBindings().map(({ label, action }) => (
          <VirtualKey label={label} action={() => sendVirtualKey(action)} />
        ))}
      </div>
    </DetailsComponent>
  );
};

export default TerminalComponent;

```

# Task

Implement the following feature!

- Create a plan!
- Create new files when needed!

Requirements:

When the user presses enter, also write it to the summary as local echo.


## Project Specifics

- Every js file should *only export a single function or signal*! eg.: in createGitRepo.js: export function createGitRepo ( ....
- Use *ES6 imports*!
- Prefer *async/await* over promises!
- The frontend uses *Solidjs* and Tailwind, edit .jsx files accordingly!

Write concise, self-documenting and idiomatic ES6 code!

# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, avoid using sed in favor of heredoc-ing full files.

OS: OSX

Installed tools: npm, jq


Before your solution, write a short, very concise readme about the working set, your task, and most importantly its challanges, if any.


EXAMPLE START
```sh
#!/bin/sh
set -e
goal=[Task description, max 9 words]
echo ""Plan:""
echo ""1. [...]""
cat > x.js << 'EOF'
[...]
'EOF'
echo ""\033[32mDone: $goal\033[0m\n""
```
EXAMPLE END

Before starting, check if you need more files or info to solve the task.

If the task is not clear:

EXAMPLE START
I need more information to solve the task. [Description of the missing info]
EXAMPLE END

Do not edit files not provided in the working set!
If you need more files:

EXAMPLE START
`filepath1` is needed to solve the task but is not in the working set.
EXAMPLE END

",95
"# Working set

```
src/frontend/
?????€??€ App.jsx
?????€??€ assets/...
?????€??€ components/...
?????€??€ fetchTasks.js
?????€??€ generatePrompt.js
?????€??€ getBaseUrl.js
?????€??€ index.html
?????€??€ index.jsx
?????€??€ postcss.config.cjs
?????€??€ service/...
?????€??€ startVite.js
?????€??€ stores/...
?????€??€ styles/...
?????€??€ tailwind.config.cjs
?????€??€ vite.config.js

```
```
src/frontend/stores/
?????€??€ change.js
?????€??€ commitMessage.js
?????€??€ executionResult.js
?????€??€ gitStatus.js
?????€??€ monitorChange.js
?????€??€ prompt.js
?????€??€ promptDescriptor.js
?????€??€ selectedTask.js

```

# Task

Move the following files to the specified target dirs!

Find out the best target dir if it is not specified!

You need to follow dependencies to maintain coherence.

Before executing, write a concise plan! The plan should show:
 - How do you avoid breaking other parts of the code.
 - If you had to choose, your way of thinking.

Rename src/frontend/stores to src/frontend/model


# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, prefer heredoc-ing full files using 'EOF' to prevent substitution.

OS: OSX

Installed tools: npm, jq


Do NOT write any text outside the script!

EXAMPLE START

```sh
#!/bin/sh
set -e
goal=[Task description, max 7 words]
echo ""Plan:""
echo ""1. [...]""
[Commands solving the task]
echo ""\033[32mDone: $goal\033[0m\n""
```

EXAMPLE END

",85
"# Working set

src/frontend/components/CommitMessageInput.jsx:
```
import { commitMessage, setCommitMessage } from '../stores/commitMessage';

const CommitMessageInput = (props) => {
  const handleChange = (e) => {
    setCommitMessage(e.target.value);
  };

  return (
    <input type=""text"" className=""w-64 px-4 py-2 border rounded"" placeholder=""Commit message..."" onInput={handleChange} />
  );
};

export default CommitMessageInput;

```

src/frontend/stores/commitMessage.js:
```
import { createSignal } from 'solid-js';

const [commitMessage, setCommitMessage] = createSignal('');

export { commitMessage, setCommitMessage };

```


# Task

Implement the following feature!

- Create a plan!
- Create new files when needed!

Requirements:

When I set the commit message, the input should be updated.



## Project Specifics

- Every js file should *only export a single function*!
- Use *ES6 imports*!
- Prefer *async/await* over promises!
- The frontend uses *Solidjs*, edit .jsx file accordingly


# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, prefer heredoc-ing full files using 'EOF' to prevent substitution.

OS: OSX

Installed tools: npm, jq


Do NOT write any text outside the script!

EXAMPLE START

```sh
#!/bin/sh
set -e
goal=[Task description, max 7 words]
echo ""Plan:""
echo ""1. [...]""
[Commands solving the task]
echo ""\033[32mDone: $goal\033[0m\n""
```

EXAMPLE END

",85
"You are AI Junior, you code like Donald Knuth.

# Working set

./docs/config/env_or_cli.md:
```
# Junior Configuration

The Junior process can be started using the following commands:
- `npx junior-web [args]`
- `npx junior-cli [args]`
- For self-development from the git repo: `npm start -- [args]`.

## Configurations

- **--ignore, JUNIOR_IGNORE**
  - List of items to ignore.
  - Example: `--ignore=./pathToIgnore`

- **--server-port, JUNIOR_SERVER_PORT**
  - The port for the server.
  - Default: 10101
  - Example: `--server-port=8080`

- **--host**
  - Host configuration. If provided without a value, it enables the host. Otherwise, specify an IP.
  - Example: `--host` or `--host=192.168.1.2`

- **-d, --dry-run**
  - Runs the application in dry run mode.

- **--model**
  - Specifies the model to be used.
  - Default: gpt-4
  - Example: `--model=gpt-5`

- **--noaudit**
  - Disables the audit trail.

- **--frontend-port, JUNIOR_FRONTEND_PORT**
  - The port for the frontend.
  - Default: 5864
  - Example: `--frontend-port=8081`

- **--system-prompt, -s**
  - Forces the system prompt.

- **--prompt**
  - Flag related to the prompt configuration.

## Examples

### Hosting on a VPN IP
```
npx junior-web --host=192.168.1.2
```

### Ignoring a Directory from Attention Scan
```
npx junior-cli --ignore=./myDirectory
```

```
./src/backend/fileutils/getIgnoreList.js:
```
function getIgnoreList() {
  const DEFAULT_IGNORE = [
    '.git',
    'node_modules',
    './prompt',
    'dist',
    'build',
    'tmp',
    'temp',
    '.vscode',
    '.idea',
    'coverage',
    '.env',
    '.DS_Store',
    'logs',
    'package-lock.json',
    'yarn.lock',
    '*.pyc',
    '__pycache__',
    '.venv',
    'venv',
    'target',
    '*.class',
    '*.exe',
    '*.test',
    'vendor/',
    '*.gem',
    '.bundle',
    'Gemfile.lock',
    'Cargo.lock',
    'bin/',
    'obj/',
    '*.suo',
    '*.user',
    '*.xcodeproj',
    '*.xcworkspace',
    'Pods/',
    'pubspec.lock',
    '.dart_tool/',
    'out/',
    '*.tsbuildinfo',
    '*.Rproj.user',
    '*.Rhistory',
    '*.pl~',
    'cpanfile.snapshot',
    'project/',
    'dist/',
    '*.hi',
    '_build/',
    'deps/',
    '*.log',
    '*.asv'
  ];

  const cliArgs = process.argv.slice(2);
  const cliIgnore = cliArgs
    .filter(arg => arg.startsWith('--ignore='))
    .map(arg => arg.replace('--ignore=', '').split(','))
    .flat();

  const envIgnore = process.env.JUNIOR_IGNORE ? process.env.JUNIOR_IGNORE.split(',') : [];

  const totalIgnore = [...DEFAULT_IGNORE, ...cliIgnore, ...envIgnore];

  const nameIgnore = totalIgnore.filter(item => !item.startsWith('./'));
  const pathIgnore = totalIgnore.filter(item => item.startsWith('./')).map(item => item.slice(2));

  return { nameIgnore, pathIgnore };
}

export default getIgnoreList;

```
./src/prompt/getPromptFlag.js:
```
function getPromptFlag() {
  const promptFlag = process.argv.find(arg => arg.startsWith(""--prompt=""));
  if (promptFlag) {
    return promptFlag.split(""="")[1];
  }
}

export { getPromptFlag };

```

# Task

Improve the documentation!

Add more info:

1. --ignore accepts a comma-separated list of paths to be ignored from the attention scan. List the defaults and describe how the different sources are merged.

2. the --prompt flag is not used, remove from the docs and delete getPromptFlag.js

3. -s and -d and their long variants are only used in the cli. Spearate them and add a note that the cli is not fully functional at the time.

Do NOT create backup files.

# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, avoid using sed in favor of heredoc-ing full files.

OS: OSX

Installed tools: npm, jq


Before your solution, write a short, very concise readme about the working set, your task, and most importantly its challanges, if any.


EXAMPLE START
```sh
#!/bin/sh
set -e
goal=[Task description, max 9 words]
echo ""Plan:""
echo ""1. [...]""
cat > x.js << 'EOF'
[...]
'EOF'
echo ""\033[32mDone: $goal\033[0m\n""
```
EXAMPLE END

Before starting, check if you need more files or info to solve the task.

If the task is not clear:

EXAMPLE START
I need more information to solve the task. [Description of the missing info]
EXAMPLE END

Do not edit files not provided in the working set!
If you need more files:

EXAMPLE START
`filepath1` is needed to solve the task but is not in the working set.
EXAMPLE END

",92
"You are AI Junior, you code like Donald Knuth.

# Working set

./docs/_coverpage.md:
```
# <span class=""cover-color-blue"">**You are the Pro,**</span> <span class=""cover-color-orange"">**Junior&nbsp;codes**</span>

Kraft code with the **Junior AI IDE**

<span class=""cover-color-red"">Works on large codebases,</span> <span class=""cover-color-green"">soon on your mobile phone.</span>

![](assets/logo.svg)

```

# Task

Improve the documentation!

Add a new line at the end of the cover page, in black:

Scroll

Add unicode upwards icons before and after the text

Do NOT create backup files.

# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, avoid using sed in favor of heredoc-ing full files.

OS: OSX

Installed tools: npm, jq


Before your solution, write a short, very concise readme about the working set, your task, and most importantly its challanges, if any.


EXAMPLE START
```sh
#!/bin/sh
set -e
goal=[Task description, max 9 words]
echo ""Plan:""
echo ""1. [...]""
cat > x.js << 'EOF'
[...]
'EOF'
echo ""\033[32mDone: $goal\033[0m\n""
```
EXAMPLE END

Before starting, check if you need more files or info to solve the task.

If the task is not clear:

EXAMPLE START
I need more information to solve the task. [Description of the missing info]
EXAMPLE END

Do not edit files not provided in the working set!
If you need more files:

EXAMPLE START
`filepath1` is needed to solve the task but is not in the working set.
EXAMPLE END

",90
"You are AI Junior, you code like Donald Knuth.

# Working set

./src/frontend/components/getStyleForFileStatus.jsx:
```
export default function getStyleForFileStatus(working_dir, path) {
  if (working_dir === 'M') {
    return { color: 'rgb(34, 197, 94)' };
  } else if (working_dir === 'A' && !path.includes('prompt/history')) {
    return { color: 'rgb(253, 186, 116)' };
  }
  return {}; // Default no text color style
}

```
./src/frontend/styles/colors.css:
```
:root {
  --text-color: #1a202c;
  --background-color: #f7fafc;
  --emphasize-color: #16181f;
  --background-emphasize-color: #f2f4f6;
  --border-color: #d1d5db;
}

.dark {
  --text-color: #f7fafc;
  --background-color: #1a202c;
  --emphasize-color: #f2f4f6;
  --background-emphasize-color: #141618;
  --border-color: #4a5568;
}

```
./docs/assets/styles.css:
```
.app-name-link img {
  max-width: 70px;
}

iframe {
  margin: 16px;
}

/* Adding logo colors to cover page */
.cover-color-blue {
  color: rgb(59, 130, 246) !important;
}

.cover-color-orange {
  color: rgb(253, 186, 116) !important;
}

.cover-color-red {
  color: rgb(185, 28, 28) !important;
}
.cover-color-green {
  color: rgb(21, 128, 61) !important;
}

```

# Task

Implement the following feature!

- Create a plan!
- Create new files when needed!

Requirements:

1. Create variables color-blue, color-orange. color-red, color-green in colors.css based on the colors in the docs styles
2. Use the variables in the styles returned for file status



## Project Specifics

- Every js file should *only export a single function or signal*! eg.: in createGitRepo.js: export function createGitRepo ( ....
- Use *ES6 imports*!
- Prefer *async/await* over promises!
- The frontend uses *Solidjs* and Tailwind, edit .jsx files accordingly!

# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, avoid using sed in favor of heredoc-ing full files.

OS: OSX

Installed tools: npm, jq


Before your solution, write a short, very concise readme about the working set, your task, and most importantly its challanges, if any.


EXAMPLE START
```sh
#!/bin/sh
set -e
goal=[Task description, max 9 words]
echo ""Plan:""
echo ""1. [...]""
cat > x.js << 'EOF'
[...]
'EOF'
echo ""\033[32mDone: $goal\033[0m\n""
```
EXAMPLE END

Before starting, check if you need more files or info to solve the task.

If the task is not clear:

EXAMPLE START
I need more information to solve the task. [Description of the missing info]
EXAMPLE END

Do not edit files not provided in the working set!
If you need more files:

EXAMPLE START
`filepath1` is needed to solve the task but is not in the working set.
EXAMPLE END

",53
"You are AI Junior, you code like Donald Knuth.

# Working set

./src/frontend/components/files/FileViewer.jsx:
```
import SourceFileDisplay from '../files/SourceFileDisplay';

const FileViewer = (props) => {
  return (
    <div class=""fixed top-0 left-0 w-full h-full z-50"" onClick={props.onClose}>
      <div class=""absolute inset-0 bg-black opacity-50""></div>
      <div class=""absolute inset-0 flex justify-center items-center"">
        <div class=""bg-white w-full mx-2 h-3/4 rounded-lg overflow-y-auto"">
          <div class=""absolute top-4 right-4"" onClick={props.onClose}></div>
          <SourceFileDisplay path={props.path} />
        </div>
      </div>
    </div>
  );
};

export default FileViewer;

```
./src/frontend/components/GitStatusDisplay.jsx:
```
import { onCleanup, onMount, createEffect, createSignal } from 'solid-js';
import GitStatusRow from './GitStatusRow';
import { gitStatus } from '../model/gitStatus';
import { fetchGitStatus } from '../service/fetchGitStatus';

const GitStatusDisplay = () => {
  let [statusMessage, setStatusMessage] = createSignal("""");
  let [fileList, setFileList] = createSignal([]);

  onMount(async () => {
    try {
      await fetchGitStatus();
    } catch (error) {
      setStatusMessage(""Error fetching git status."");
    }
  });

  createEffect(() => {
    const gitStatusValue = gitStatus();
    if (gitStatusValue.error) {
      setStatusMessage(`${gitStatusValue.message}\n${gitStatusValue.error.stderr}`);
    } else if (gitStatusValue.data && gitStatusValue.data.files) {
      setFileList(gitStatusValue.data.files);
    }
  });

  onCleanup(() => {
    // Clean up any listeners or resources tied to this component.
  });

  return (
    <pre class=""rounded overflow-auto max-w-full"">
      {statusMessage()}
      {fileList().map(entry => <GitStatusRow key={entry.path} entry={entry} />)}
    </pre>
  );
};

export default GitStatusDisplay;

```
./src/frontend/components/GitStatusRow.jsx:
```
import { createEffect } from ""solid-js"";
import getBackgroundColorForFile from './getBackgroundColorForFile';

const GitStatusRow = (props) => {
  const { index, path, working_dir } = props.entry;

  // Split the path to get filename and base directory
  const splitPath = path.split('/');
  const fileName = splitPath.pop();
  const baseDir = splitPath.join('/');

  const bgColor = getBackgroundColorForFile(index, path);

  let pathRef; // For scrolling logic

  createEffect(() => { // Incorporate scrolling logic
    if (pathRef) {
      pathRef.scrollLeft = pathRef.scrollWidth;
    }
  });

  // Adjusting styles and incorporating scrolling logic as per ListItem.jsx
  return (
    <div class={`flex ${bgColor ? 'bg-' + bgColor : ''}`}>
      <span class=""w-50px overflow-x-auto p-1"">{index + ' ' + working_dir}</span>
      <span class=""text-base bg-main rounded p-1"">{fileName}</span>
      <span ref={pathRef} class=""overflow-x-auto whitespace-no-wrap break-keep scrollbar-hidden ml-4 py-2 text-sm"">{baseDir}</span>
    </div>
  );
};

export default GitStatusRow;

```

# Task

Implement the following feature!

- Create a plan!
- Create new files when needed!

Requirements:

Click on git status items should open the file viewer with the file.


## Project Specifics

- Every js file should *only export a single function or signal*! eg.: in createGitRepo.js: export function createGitRepo ( ....
- Use *ES6 imports*!
- Prefer *async/await* over promises!
- The frontend uses *Solidjs* and Tailwind, edit .jsx files accordingly!

# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, avoid using sed in favor of heredoc-ing full files.

OS: OSX

Installed tools: npm, jq


Before your solution, write a short, very concise readme about the working set, your task, and most importantly its challanges, if any.


EXAMPLE START
```sh
#!/bin/sh
set -e
goal=[Task description, max 9 words]
echo ""Plan:""
echo ""1. [...]""
cat > x.js << 'EOF'
[...]
'EOF'
echo ""\033[32mDone: $goal\033[0m\n""
```
EXAMPLE END

Before starting, check if you need more files or info to solve the task.

If the task is not clear:

EXAMPLE START
I need more information to solve the task. [Description of the missing info]
EXAMPLE END

Do not edit files not provided in the working set!
If you need more files:

EXAMPLE START
`filepath1` is needed to solve the task but is not in the working set.
EXAMPLE END

",85
"You are AI Junior, you code like Donald Knuth.

# Working set

./src/frontend/components/terminal/TerminalComponent.jsx:
```
import { onCleanup, onMount } from 'solid-js';
import 'xterm/css/xterm.css';
import terminalConnection from '../../service/terminal/terminalConnection';
import { setupXTerm } from '../../service/terminal/setupXTerm';
import { sendTerminalResizeNotification } from '../../service/terminal/sendTerminalResizeNotification';
import DetailsComponent from '../DetailsComponent';
import VirtualButton from './VirtualButton';

const TerminalComponent = () => {
  let container;
  const { term, fitAddon } = setupXTerm();
  
  const sendVirtualKey = (key) => {
    term.write(key);
  };

  onMount(() => {
    term.open(container);
    fitAddon.fit();

    const { rows, cols } = term;
    sendTerminalResizeNotification(rows, cols);

    terminalConnection.setOnDataReceived((data) => {
      term.write(data);
    });

    term.onData((data) => {
      terminalConnection.sendDataToTerminal(JSON.stringify({ type: 'input', data }));
    });

    term.onResize(({ newRows, newCols }) => {
      sendTerminalResizeNotification(newRows, newCols);
    });
  });
  
  onCleanup(() => {
    term.dispose();
    terminalConnection.closeConnection();
  });

  return (
    <DetailsComponent 
      defaultState=""closed""
      localStorageKey=""terminalState""
      generateHeader={() => ""Terminal""}
      classes=""rounded border p-2 w-full border-border bg-emphasize""
    >
      <div class=""flex overflow-x-auto whitespace-nowrap"">
        <VirtualButton label=""Esc"" action={() => sendVirtualKey('\x1B')} />
        <VirtualButton label=""-"" action={() => sendVirtualKey('-')} />
        <VirtualButton label="":"" action={() => sendVirtualKey(':')} />
        <VirtualButton label=""Ctrl-Z"" action={() => sendVirtualKey('\x1A')} />
        <VirtualButton label=""Ctrl-Y"" action={() => sendVirtualKey('\x19')} />
        <VirtualButton label=""Ctrl-X"" action={() => sendVirtualKey('\x18')} />
        <VirtualButton label=""Ctrl-V"" action={() => sendVirtualKey('\x16')} />
        <VirtualButton label=""F1"" action={() => sendVirtualKey('\x1BOP')} />
        <VirtualButton label=""F5"" action={() => sendVirtualKey('\x1B[15~')} />
        <VirtualButton label=""F6"" action={() => sendVirtualKey('\x1B[17~')} />
        <VirtualButton label=""F7"" action={() => sendVirtualKey('\x1B[18~')} />
      </div>
      <div ref={container}>
        {/* The terminal will be rendered inside this div */}
      </div>
    </DetailsComponent>
  );
};

export default TerminalComponent;

```
./src/frontend/components/terminal/VirtualButton.jsx:
```
import { createSignal } from 'solid-js';

const VirtualButton = (props) => {
  const sendKey = () => {
    if (props.action) {
      props.action();
    }
  };

  return (
    <button
      className=""m-1 bg-main hover:bg-blue-700 text-white font-bold py-1 px-2 rounded""
      onClick={sendKey}
    >
      {props.label}
    </button>
  );
};

export default VirtualButton;

```

# Task

Implement the following feature!

- Create a plan!
- Create new files when needed!

Requirements:

1. The terminal component should send virtual key  codes to the terminal connection, not to xterm.js.
2. Add text-text class to the virtual buttons


## Project Specifics

- Every js file should *only export a single function or signal*! eg.: in createGitRepo.js: export function createGitRepo ( ....
- Use *ES6 imports*!
- Prefer *async/await* over promises!
- The frontend uses *Solidjs* and Tailwind, edit .jsx files accordingly!

# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, avoid using sed in favor of heredoc-ing full files.

OS: OSX

Installed tools: npm, jq


Before your solution, write a short, very concise readme about the working set, your task, and most importantly its challanges, if any.


EXAMPLE START
```sh
#!/bin/sh
set -e
goal=[Task description, max 9 words]
echo ""Plan:""
echo ""1. [...]""
cat > x.js << 'EOF'
[...]
'EOF'
echo ""\033[32mDone: $goal\033[0m\n""
```
EXAMPLE END

Before starting, check if you need more files or info to solve the task.

If the task is not clear:

EXAMPLE START
I need more information to solve the task. [Description of the missing info]
EXAMPLE END

Do not edit files not provided in the working set!
If you need more files:

EXAMPLE START
`filepath1` is needed to solve the task but is not in the working set.
EXAMPLE END

",80
"# Working set

src/init.js:
```
#!/usr/bin/env node
import { execSync } from 'child_process';
import { join } from 'path';
import { createPromptYaml } from './prompt/createPromptYaml.js';
import { createProjectSpecifics } from './prompt/createProjectSpecifics.js';
import { createGitignore } from './git/createGitignore.js';

async function juniorInit() {
  execSync('git init', { stdio: 'inherit' });

  createGitignore();

  execSync('git add .gitignore', { stdio: 'inherit' });
  execSync('git commit -m ""Junior init""', { stdio: 'inherit' });

  createPromptYaml();
  createProjectSpecifics();

  console.log('\x1b[32mRepo initialized for Junior development\x1b[0m');
}

juniorInit();

```

src/prompt/createProjectSpecifics.js:
```
import { writeFileSync } from 'fs';

export function createProjectSpecifics() {
  const markdownContent = `## Project Specifics\n`;

  writeFileSync('./prompt/projectSpecifics.md', markdownContent);
}

```


# Task

Implement the following feature!

- Create a plan!
- Create new files when needed!

Requirements:

Create the prompt dir if it doesn&#39;t exist. Also commit it.


## Project Specifics

- Every js file should *only export a single function*!
- Use *ES6 imports*!
- Prefer *async/await* over promises!
- The frontend uses *Solidjs*, edit .jsx file accordingly


# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, prefer heredoc-ing full files using 'EOF' to prevent substitution.

OS: OSX

Installed tools: npm, jq


Do NOT write any text outside the script!

EXAMPLE START

```sh
#!/bin/sh
set -e
goal=[Task description, max 7 words]
echo ""Plan:""
echo ""1. [...]""
[Commands solving the task]
echo ""\033[32mDone: $goal\033[0m\n""
```

EXAMPLE END

",58
"# Working set

src/frontend/components/GitStatusDisplay.jsx:
```
import { onMount, createEffect } from 'solid-js';
import { gitStatus } from '../stores/gitStatus';
import { fetchGitStatus } from '../service/fetchGitStatus';

const GitStatusDisplay = () => {
  let statusContainer;

  onMount(fetchGitStatus);

  createEffect(() => {
    const gitStatusValue = gitStatus();
    if (gitStatusValue) {
      if (gitStatusValue.error && gitStatusValue.error.stderr.includes('Not a git repository')) {
        statusContainer.innerText = 'Not a git repo. Run \'npx junior-init\' to initialize!';
      } else if (gitStatusValue.message && gitStatusValue.message !== '') {
        statusContainer.innerText = gitStatusValue.message;
      }
    }
  });

  return (
    <pre
      ref={statusContainer}
      class={`rounded overflow-auto max-w-full ${gitStatus() && gitStatus().message && gitStatus().message !== '' ? 'block' : 'hidden'}`}
    />
  );
};

export default GitStatusDisplay;

```

src/backend/handlers/gitStatusHandler.js:
```
import gitStatus from '../../git/gitStatus.js';

export default async function gitStatusHandler(req, res) {
  try {
    const status = await gitStatus();
    res.status(200).send({ status });
  } catch (error) {
    res.status(500).send({ message: 'Error in getting Git status', error });
  }
}

```


# Task

Fix the following issue!

1. Move the git status result from the status field of the response to the message field.
2. When the endpoint reports an error in the error field similar to this (check stderr for &#34;Not a git repository&#34;):
{
  &#34;message&#34;: &#34;Error in getting Git status&#34;,
  &#34;error&#34;: {
    &#34;code&#34;: 128,
    &#34;killed&#34;: false,
    &#34;signal&#34;: null,
    &#34;cmd&#34;: &#34;git status --porcelain=v1&#34;,
    &#34;stdout&#34;: &#34;&#34;,
    &#34;stderr&#34;: &#34;fatal: Not a git repository (or any of the parent directories): .git\n&#34;
  }
}
then display &#34;Not a git repo. Run &#39;npx junior-init&#39; to initialize!&#34;.


# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, prefer heredoc-ing full files using 'EOF' to prevent substitution.

OS: OSX

Installed tools: npm, jq


Do NOT write any text outside the script!

EXAMPLE START

```sh
#!/bin/sh
set -e
goal=[Task description, max 7 words]
echo ""Plan:""
echo ""1. [...]""
[Commands solving the task]
echo ""\033[32mDone: $goal\033[0m\n""
```

EXAMPLE END

",75
"You are AI Junior, you code like Donald Knuth.

# Working set

./docs/index.html:
```
<!DOCTYPE html>
<html lang=""en"">
<head>
  <meta charset=""UTF-8"">
  <title>Document</title>
  <meta http-equiv=""X-UA-Compatible"" content=""IE=edge,chrome=1"" />
  <meta name=""description"" content=""Description"">
  <meta name=""viewport"" content=""width=device-width, initial-scale=1.0, minimum-scale=1.0"">
  <link rel=""icon"" href=""assets/favicon.ico"" type=""image/x-icon"">
  <link rel=""stylesheet"" href=""//cdn.jsdelivr.net/npm/docsify@4/lib/themes/vue.css"">
  <link rel=""stylesheet"" href=""assets/styles.css"">
</head>
<body>
  <div id=""app""></div>
  <script src=""docsifyConfig.js""></script>
  <!-- Docsify v4 -->
  <script src=""//cdn.jsdelivr.net/npm/docsify@4""></script>
</body>
</html>

```
./docs/README.md:
```
# Junior - Your AI-first IDE 

[![Video: Junior codes itself](/assets/video_cover.jpg)](https://youtu.be/NL4uFJSvfW0)

*""Video: Junior codes itself""*

Junior is an **AI-first IDE** designed specifically for professional programmers who have a preference for customizing and fine-tuning their tools. 

With Junior, developers get a unique space where they can work hand-in-hand with AI throughout the development process. By using structured task descriptors and spotlighting relevant parts of a project, tasks like code implementation, documentation, and testing can be seamlessly delegated to Junior.

At its core, Junior embraces a design philosophy that prioritizes simplicity, configurability, and auditability. This ensures that the platform remains both accessible to its users and adaptable to a variety of use-cases.

Junior has been crafted exclusively with AI-powered coding right from its early days, way before its core functionalities were in place. This demonstrates Junior's pioneering approach to harnessing the potential of artificial intelligence in software development.

## Getting Started

For guidance on using Junior, please refer to [usage.md](usage.md).

## Contributing and Support

Your contributions make a difference! At Junior, we value the collaboration of the community. Your role as a contributor is to monitor the development, provide detailed prompts, and thoroughly review the generated outcomes.

For questions or assistance, please raise an issue in our GitHub repository.

**Note:** We've tested Junior primarily with the GPT-4 model. However, you're welcome to experiment with similarly capable models and share your findings. It's not compatible with GPT-3.5.

```
./docs/_coverpage.md:
```
# <span class=""cover-color-blue"">**You are the Pro,**</span> <span class=""cover-color-orange"">**Junior&nbsp;codes**</span>

Kraft code with the **Junior AI IDE**

<span class=""cover-color-red"">Works on large codebases,</span> <span class=""cover-color-green"">soon on your mobile phone.</span>

![](assets/logo.svg)

```
./docs/_sidebar.md:
```
* [Junior Docs](./README.md)
* [Usage](./usage.md)
* [Web](./web.md)
* [Prompt Descriptor](./descriptor.md)
* [Roadmap](./roadmap.md)
* [Open Jobs](./open_jobs.md)

```

# Task

Implement the following feature!

- Create a plan!
- Create new files when needed!

Requirements:

Meta/og for docs site


## Project Specifics

- Every js file should *only export a single function or signal*! eg.: in createGitRepo.js: export function createGitRepo ( ....
- Use *ES6 imports*!
- Prefer *async/await* over promises!
- The frontend uses *Solidjs* and Tailwind, edit .jsx files accordingly!

# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, avoid using sed in favor of heredoc-ing full files.

OS: Debian


Installed tools: npm, jq


Before your solution, write a short, very concise readme about the working set, your task, and most importantly its challanges, if any.


EXAMPLE START
```sh
#!/bin/sh
set -e
goal=[Task description, max 9 words]
echo ""Plan:""
echo ""1. [...]""
cat > x.js << 'EOF'
[...]
'EOF'
echo ""\033[32mDone: $goal\033[0m\n""
```
EXAMPLE END

Before starting, check if you need more files or info to solve the task.

If the task is not clear:

EXAMPLE START
I need more information to solve the task. [Description of the missing info]
EXAMPLE END

Do not edit files not provided in the working set!
If you need more files:

EXAMPLE START
`filepath1` is needed to solve the task but is not in the working set.
EXAMPLE END

",80
create me an ansible role which starts caffeine automatic on boot,82
"# Working set

src/backend/setupRoutes.js:
```
import { generateHandler } from './handlers/generateHandler.js';
import { servePromptDescriptor } from './handlers/servePromptDescriptor.js';
import { updateTaskHandler } from './handlers/updateTaskHandler.js';
import { listTasks } from './handlers/listTasks.js';
import { executeHandler } from './handlers/executeHandler.js';
import resetGitHandler from './handlers/resetGitHandler.js';

export function setupRoutes(app) {
  app.get('/descriptor', servePromptDescriptor);
  app.get('/tasks', (req, res) => res.json({ tasks: listTasks() }));

  app.post('/generate', generateHandler);
  app.post('/updatetask', updateTaskHandler);
  app.post('/execute', executeHandler);
  app.post('/reset', resetGitHandler);
}

```

src/backend/handlers/resetGitHandler.js:
```
import resetGit from '../../git/resetGit.js';

export default async function resetGitHandler(req, res) {
  try {
    await resetGit();
    res.status(200).send({ message: 'Git successfully reset' });
  } catch (error) {
    res.status(500).send({ message: 'Error in resetting Git', error });
  }
}

```

src/git/resetGit.js:
```
import { exec } from 'child_process';

export default function resetGit() {
  // Stash all changes including untracked files
  exec('git stash -u', (err, stdout, stderr) => {
    if (err) {
      console.error(`exec error: ${err}`);
      return;
    }
    console.log(`stdout: ${stdout}`);

    // Clean the repository and reset to the latest commit
    exec('git clean -f -d && git reset --hard', (err, stdout, stderr) => {
      if (err) {
        console.error(`exec error: ${err}`);
        return;
      }
      console.log(`stdout: ${stdout}`);

      // Checkout prompt.yaml from stash
      exec('git checkout stash@{0} -- prompt.yaml', (err, stdout, stderr) => {
        if (err) {
          console.error(`exec error: ${err}`);
          return;
        }
        console.log(`stdout: ${stdout}`);

        // Drop the stash
        exec('git stash drop', (err, stdout, stderr) => {
          if (err) {
            console.error(`exec error: ${err}`);
            return;
          }
          console.log(`stdout: ${stdout}`);
        });
      });
    });
  });
}

```


# Task

Implement the following feature!

- Create a plan!
- Create new files when needed!

Requirements:

Create an endpoint &#34;/status&#34; which runs git status



## Project Specifics

- Every js file should *only export a single function*!
- Use *ES6 imports*!
- The frontend uses *Solidjs*, edit .jsx file accordingly


# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, prefer heredoc-ing full files using 'EOF' to prevent substitution.

OS: OSX

Installed tools: npm, jq


Do NOT write any text outside the script!

EXAMPLE START

```sh
#!/bin/sh
set -e
goal=[Task description, max 7 words]
echo ""Plan:""
echo ""1. [...]""
[Commands solving the task]
echo ""\033[32mDone: $goal\033[0m\n""
```

EXAMPLE END

",80
"# Working set

src/prompt/createPrompt.js:
```
import { readAttention } from ""../attention/readAttention.js""
import yaml from 'js-yaml';
import { getSystemPromptIfNeeded } from './getSystemPromptIfNeeded.js';
import { resolveTemplateVariables } from './resolveTemplateVariables.js';
import { extractTemplateVars } from './extractTemplateVars.js';
import { loadPromptDescriptor } from './loadPromptDescriptor.js';
import { loadTaskTemplate } from './loadTaskTemplate.js';
import { loadFormatTemplate } from './loadFormatTemplate.js';
import promptDescriptorDefaults from './promptDescriptorDefaults.js';

const createPrompt = async (userInput) => {
  let promptDescriptorDefaultsData = await promptDescriptorDefaults();
  let promptDescriptor = yaml.load(await loadPromptDescriptor());

  // Fill in the defaults from promptDescriptorDefaults.js
  promptDescriptor = { ...promptDescriptorDefaultsData, ...promptDescriptor };

  let templateVars = extractTemplateVars(promptDescriptor);
  templateVars = await resolveTemplateVariables(templateVars);

  const attention = await readAttention(promptDescriptor.attention);
  const task = await loadTaskTemplate(promptDescriptor.task, templateVars);

  const format = await loadFormatTemplate(promptDescriptor.format, templateVars);
  const system = await getSystemPromptIfNeeded();
  const saveto = promptDescriptor.saveto;
  return {
    prompt: `${system}# Working set\n\n${attention.join(""\n"")}\n\n# Task\n\n${task}\n\n# Output Format\n\n${format}\n\n${userInput ? userInput : """"}`,
    saveto
  };
}

export { createPrompt };

```


# Task

Implement the following feature!

- Create a plan!
- Create new files when needed!

Requirements:

Switch order of loading the descriptor yaml and the defaults



## Project Specifics

- Every js file should *only export a single function*!
- Use *ES6 imports*!
- The frontend uses *Solidjs*, edit .jsx file accordingly


# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, prefer heredoc-ing full files using 'EOF' to prevent substitution.

OS: OSX

Installed tools: npm, jq


Do NOT write any text outside the script!

EXAMPLE START

```sh
#!/bin/sh
set -e
goal=[Task description, max 7 words]
echo ""Plan:""
echo ""1. [...]""
[Commands solving the task]
echo ""\033[32mDone: $goal\033[0m\n""
```

EXAMPLE END

",92
"# Working set

```
./
?????€??€ .DS_Store
?????€??€ .git/...
?????€??€ .github/...
?????€??€ .gitignore
?????€??€ .vscode/...
?????€??€ README.md
?????€??€ babel.config.js
?????€??€ change.sh
?????€??€ doc/...
?????€??€ integrations/...
?????€??€ node_modules/...
?????€??€ package-lock.json
?????€??€ package.json
?????€??€ prompt/...
?????€??€ prompt.md
?????€??€ prompt.yaml
?????€??€ src/...
?????€??€ tailwind.config.js

```
```
src/
?????€??€ .DS_Store
?????€??€ attention/...
?????€??€ backend/...
?????€??€ config.js
?????€??€ doc/...
?????€??€ execute/...
?????€??€ frontend/...
?????€??€ git/...
?????€??€ index.html
?????€??€ interactiveSession/...
?????€??€ llm/...
?????€??€ main.js
?????€??€ prompt/...
?????€??€ startVite.js
?????€??€ vite.config.js
?????€??€ web.js

```
```
src/frontend/
?????€??€ App.jsx
?????€??€ components/...
?????€??€ fetchTasks.js
?????€??€ generatePrompt.js
?????€??€ getBaseUrl.js
?????€??€ index.jsx
?????€??€ postcss.config.cjs
?????€??€ service/...
?????€??€ stores/...
?????€??€ styles/...

```
src/frontend/postcss.config.cjs:
```
const tailwindcss = require('tailwindcss');
const autoprefixer = require('autoprefixer');
const postcssImport = require('postcss-import');
const postcssNested = require('postcss-nested');

module.exports = {
  plugins: {
    'postcss-import': {},
    'tailwindcss/nesting': postcssNested,
    tailwindcss: tailwindcss,
    autoprefixer: autoprefixer,
  },
};

```

src/vite.config.js:
```
import { defineConfig } from 'vite'
import solidPlugin from 'vite-plugin-solid'

export default defineConfig({
  plugins: [solidPlugin()],
  css: {
    postcss: './src/frontend/postcss.config.cjs'
  },
  build: {
    target: 'esnext',
  },
})

```

tailwind.config.js:
```
module.exports = {
  content: ['./src/**/*.html', './src/**/*.js', './src/**/*.jsx', './src/**/*.tsx', './src/**/*.ts'],
  theme: {
    screens: {
      'xs': '320px',
      'sm': '640px',
      'md': '768px',
      'lg': '1024px',
      'xl': '1280px',
      '2xl': '1536px',
    },
    extend: {
      // Extend the spacing for larger gaps
      spacing: {
        '72': '18rem',
        '84': '21rem',
        '96': '24rem',
        '128': '32rem',
      },
      // Extend the button styles for larger buttons
      fontSize: {
        'btn': '1.5rem',
      },
      padding: {
        'btn': '1.5rem',
      },
      // Extend the maxWidth for desktop container
      maxWidth: {
        'desktop': '640px',
      },
    },
  },
  variants: {
    extend: {},
  },
  plugins: [],
}

```


# Task

Move the following files to the specified target dirs!

Find out the best target dir if it is not specified!

You need to follow dependencies to maintain coherence.

Before executing, write a concise plan! The plan should show:
 - How do you avoid breaking other parts of the code.
 - If you had to choose, your way of thinking.

Move the tailwind config to src/frontend/, convert it to .cjs (no es6 imports) and configure the project to use it.
FYI the tailwind docs says:
If you?€?re using Tailwind as a PostCSS plugin, you will need to specify your custom configuration path in your PostCSS configuration:
postcss.config.js: module.exports = {
  plugins: {
    tailwindcss: { config: &#39;./tailwindcss-config.js&#39; },
  },
}


# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, prefer heredoc-ing full files using 'EOF' to prevent substitution.
OS: OSX
Installed tools: npm, jq
Do NOT write any text outside the script!

EXAMPLE START

```sh
#!/bin/sh
set -e
goal=[Task description, max 7 words]
echo ""Plan:""
echo ""1. [...]""
[Commands solving the task]
echo ""\033[32mDone: $goal\033[0m\n""
```

EXAMPLE END

",62
"You are AI Junior, you code like Donald Knuth.
# Working set

./src/frontend/components/terminal/TerminalComponent.jsx:
```
import { onCleanup, onMount } from 'solid-js';
import { Terminal } from 'xterm';
import 'xterm/css/xterm.css';
import terminalConnection from '../../service/terminal/terminalConnection';

const TerminalComponent = () => {
  let container;
  const term = new Terminal();
  
  onMount(() => {
    term.open(container);

    terminalConnection.setOnDataReceived((data) => {
      term.write(data);
    });

    term.onData((data) => {
      terminalConnection.sendDataToTerminal(data);
    });
  });
  
  // Ensure terminal instance gets destroyed and WebSocket connection gets closed on component cleanup
  onCleanup(() => {
    term.dispose();
    terminalConnection.closeConnection();
  });

  return (
    <div class=""rounded border p-4 w-full"" ref={container}>
      {/* The terminal will be rendered inside this div */}
    </div>
  );
};

export default TerminalComponent;

```


# Task

Implement the following feature!

- Create a plan!
- Create new files when needed!

Requirements:

- Factor out xterm.js initialization to setupXTerm.js
- Install and use xterm-addon-fit

docs for your reference:

Addons / fit
The fit addon provides the fit method that lets you adjust the size and geometry (columns ???? rows) of the terminal to fit the size of the parent element.

import { Terminal } from 'xterm';
import { FitAddon } from 'xterm-addon-fit';

const term = new Terminal();
const fitAddon = new FitAddon();
term.loadAddon(fitAddon);

// Open the terminal in #terminal-container
term.open(document.getElementById('terminal-container'));

// Make the terminal's size and geometry fit the size of #terminal-container
fitAddon.fit();



## Project Specifics

- Every js file should *only export a single function or signal*! eg.: in createGitRepo.js: export function createGitRepo ( ....
- Use *ES6 imports*!
- Prefer *async/await* over promises!
- The frontend uses *Solidjs* and Tailwind, edit .jsx files accordingly!

# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, avoid using sed in favor of heredoc-ing full files.

OS: OSX

Installed tools: npm, jq


Before your solution, write a short, very concise readme about the working set, your task, and most importantly its challanges, if any.


EXAMPLE START
```sh
#!/bin/sh
set -e
goal=[Task description, max 9 words]
echo ""Plan:""
echo ""1. [...]""
cat > x.js << 'EOF'
[...]
'EOF'
echo ""\033[32mDone: $goal\033[0m\n""
```
EXAMPLE END

Before starting, check if you need more files or info to solve the task.

If the task is not clear:

EXAMPLE START
I need more information to solve the task. [Description of the missing info]
EXAMPLE END

Do not edit files not provided in the working set!
If you need more files:

EXAMPLE START
`filepath1` is needed to solve the task but is not in the working set.
EXAMPLE END


",75
"# Working set

src/execute/executeAndForwardOutput.js:
```
import { spawn } from 'child_process';
import { rl } from '../config.js';

function executeAndForwardOutput(code, next) {
  const child = spawn(code, { shell: true });
  let last_command_result = '';

  child.stdout.on('data', (data) => {
    console.log(`${data}`);
    last_command_result += data;
  });

  child.stderr.on('data', (data) => {
    console.error(`${data}`);
    last_command_result += data;
  });

  child.on('close', (code) => {
    if (code !== 0) {
      console.log(`child process exited with code ${code}`);
      last_command_result = ""Command failed. Output:\n"" + last_command_result;
    } else {
      last_command_result = ""Command executed. Output:\n"" + last_command_result;
    }
    next();
  });
}

export { executeAndForwardOutput };

```

src/frontend/service/executeChange.js:
```
import { getBaseUrl } from '../getBaseUrl';

const executeChange = async (change) => {
  const baseUrl = getBaseUrl();
  const response = await fetch(`${baseUrl}/execute`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ change })
  });

  const data = await response.json();

  return data;
};

export { executeChange };

```

src/backend/setupRoutes.js:
```
import { generateHandler } from './handlers/generateHandler.js';
import { servePromptDescriptor } from './handlers/servePromptDescriptor.js';
import { updateTaskHandler } from './handlers/updateTaskHandler.js';
import { listTasks } from './handlers/listTasks.js';

export function setupRoutes(app) {
  app.get('/descriptor', servePromptDescriptor);
  app.get('/tasks', (req, res) => res.json({ tasks: listTasks() }));

  app.post('/generate', generateHandler);
  app.post('/updatetask', updateTaskHandler);
}

```


# Task

Implement the following feature!

- Create a plan!
- Create new files when needed!
- Every js file should only export a single function!
- Use ES6 imports!

Requirements:

Create new backend endpoint &#34;execute&#34; that will call executeAndForwardOutput on the posted data.



# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, prefer heredoc-ing full files without substitution.
Assume OSX.
npm and jq are installed.
Do NOT write any text outside the script (the plan goes into it)!


EXAMPLE START

```sh
#!/bin/sh
# Goal: [Task description, max 7 words]
# Plan:
# 1. [...]

[Commands solving the task]
```

EXAMPLE END

",78
"# Working set

src/frontend/App.jsx:
```
import NotesInput from './components/NotesInput';
import StartButton from './components/StartButton';
import PromptDisplay from './components/PromptDisplay';
import TasksList from './components/TasksList';
import PromptDescriptor from './components/PromptDescriptor';
import NavBar from './components/NavBar';
import { notes, setNotes } from './stores/notes';
import { setPrompt } from './stores/prompt';

const App = () => {
  return (
    <div class=""max-w-desktop lg:max-w-desktop md:max-w-full sm:max-w-full xs:max-w-full mx-auto flex flex-col items-center space-y-8 sm:p-0"">
      <NavBar />
      <TasksList />
      <PromptDescriptor />
      <NotesInput notes={notes} setNotes={setNotes} />
      <StartButton notes={notes} setPrompt={setPrompt} />
      <PromptDisplay />
    </div>
  );
};

export default App;

```

src/frontend/components/PromptDescriptor.jsx:
```
import { onMount, onCleanup } from 'solid-js';
import { fetchDescriptor } from '../service/fetchDescriptor';
import { useWebsocket } from '../service/useWebsocket';
import { promptDescriptor, setPromptDescriptor } from '../stores/promptDescriptor';

const PromptDescriptor = () => {

  onMount(async () => {
    const text = await fetchDescriptor();
    setPromptDescriptor(text);
  });

  useWebsocket(async (e) => {
    if (e.data === 'update') {
      const text = await fetchDescriptor();
      setPromptDescriptor(text);
    }
  });

  onCleanup(() => {
    setPromptDescriptor('');
  });

  return (
    <div class=""overflow-auto max-w-full"">
      <pre>{promptDescriptor()}</pre>
    </div>
  );
};

export default PromptDescriptor;

```


# Task

Implement the following feature!

- Create a plan!
- Create new files when needed!
- Every js file should only export a single function!
- Use ES6 imports!

Requirements:

The pre should not be wider than the screen.
Allow wrapping of the text!
add an extra div if needed.
Use tailwind utility classes.



# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, prefer heredoc-ing full files without substitution.
Assume OSX.
npm and jq are installed.
Do NOT write any text outside the script (the plan goes into it)!


EXAMPLE START

```sh
#!/bin/sh
# Goal: [Task description, max 7 words]
# Plan:
# 1. [...]

[Commands solving the task]
```

EXAMPLE END

",75
"# Working set

integrations/vscode/src/writeAttention.ts:
```
import * as vscode from 'vscode';
import * as fs from 'fs';
import * as path from 'path';
import * as yaml from 'js-yaml';

export const writeAttention = async () => {
    const workspaceFolders = vscode.workspace.workspaceFolders;
    if (workspaceFolders === undefined) {
        return;
    }
    
    const rootFolder = workspaceFolders[0].uri.fsPath;
    const promptFilePath = path.join(rootFolder, 'prompt.yaml');
    try {
        if (fs.existsSync(promptFilePath)) {
            const currentWindows = vscode.workspace.textDocuments.map(doc => path.relative(rootFolder, doc.fileName));
            const filteredWindows = currentWindows.filter(windowPath => !windowPath.endsWith('.git'));
            const promptFile = yaml.load(fs.readFileSync(promptFilePath, 'utf8'));
            promptFile.attention = filteredWindows;
            fs.writeFileSync(promptFilePath, yaml.dump(promptFile), 'utf8');
            vscode.window.showInformationMessage('Prompt file updated successfully!');
        } else {
            vscode.window.showErrorMessage('No prompt.yaml file found in the project root!');
        }
    } catch (error) {
        vscode.window.showErrorMessage('Error updating the prompt.yaml file!');
    }
};

```

integrations/vscode/src/extension.ts:
```
import * as vscode from 'vscode';
import { writeAttention } from './writeAttention';

export function activate(context: vscode.ExtensionContext) {
	console.log('Junior extension is now active!');

	let helloWorldDisposable = vscode.commands.registerCommand('junior.helloWorld', () => {
		vscode.window.showInformationMessage('Hello World from Junior!');
	});

	let writeAttentionDisposable = vscode.commands.registerCommand('junior.writeAttention', writeAttention);

	context.subscriptions.push(helloWorldDisposable);
	context.subscriptions.push(writeAttentionDisposable);
}

export function deactivate() {}

```

integrations/vscode/package.json:
```
{
  ""name"": ""junior"",
  ""displayName"": ""Junior"",
  ""description"": ""Your AI contributor"",
  ""version"": ""0.0.1"",
  ""engines"": {
    ""vscode"": ""^1.80.0""
  },
  ""categories"": [
    ""Other""
  ],
  ""activationEvents"": [],
  ""main"": ""./out/extension.js"",
  ""contributes"": {
    ""commands"": [
      {
        ""command"": ""junior.helloWorld"",
        ""title"": ""Hello World""
      },
      {
        ""command"": ""junior.writeAttention"",
        ""title"": ""Write Attention""
      }
    ]
  },
  ""scripts"": {
    ""vscode:prepublish"": ""npm run compile"",
    ""compile"": ""tsc -p ./"",
    ""watch"": ""tsc -watch -p ./"",
    ""pretest"": ""npm run compile && npm run lint"",
    ""lint"": ""eslint src --ext ts"",
    ""test"": ""node ./out/test/runTest.js""
  },
  ""devDependencies"": {
    ""@types/glob"": ""^8.1.0"",
    ""@types/mocha"": ""^10.0.1"",
    ""@types/node"": ""20.2.5"",
    ""@types/vscode"": ""^1.80.0"",
    ""@typescript-eslint/eslint-plugin"": ""^5.59.8"",
    ""@typescript-eslint/parser"": ""^5.59.8"",
    ""@vscode/test-electron"": ""^2.3.2"",
    ""eslint"": ""^8.41.0"",
    ""glob"": ""^8.1.0"",
    ""mocha"": ""^10.2.0"",
    ""typescript"": ""^5.1.3""
  },
  ""dependencies"": {
    ""js-yaml"": ""^4.1.0""
  }
}

```


# Task

Implement the following feature!

- Create a plan!
- Create new files when needed!
- Every js file should only export a single function!
- Use ES6 imports!

Requirements:

- Instead of excluding .git - ending elements, only include existing files in the attention. - Also exclude prompt.yaml and prompt.md - Plus allow an attention exclude list (list of globs) as a configuration - Remove the helloworld command



# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, prefer heredoc-ing full files without substitution.
Assume OSX.
npm and jq are installed.
Do NOT write any text outside the script (the plan goes into it)!


EXAMPLE START

```sh
#!/bin/sh
# Goal: [Task description, max 7 words]
# Plan:
# 1. [...]

[Commands solving the task]
```

EXAMPLE END

",71
"# Working set

src/index.html:
```
<!DOCTYPE html>
<html lang=""en"">
<head>
  <meta charset=""UTF-8"">
  <title>Contributor</title>
</head>
<body>
  <div id=""app""></div>
  <script type=""module"" src=""/frontend/index.jsx""></script>
</body>
</html>

```

src/main.js:
```
#!/usr/bin/env node

import { startInteractiveSession } from './interactiveSession/startInteractiveSession.js';
import { api, get_model, rl } from './config.js';

console.log(""Welcome to Contributor. Model: "" + get_model() + ""\n"");

startInteractiveSession(rl, api);

export { startInteractiveSession };

```

prompt/system.md:
```
You're the 'Contributor', an AI system aiding authors.

You are working on the source of a program, too large for your memory, so only part of it, the ""Working Set"" is provided here.

You will see a partial directory structure. Ask for the contents of subdirs marked with /... if needed.

Some files are printed in the working set.

Other files are only listed in their dir, so you know they exists. Do not edit files without knowing their current content, ask for their contents instead!

```


# Task

Fix the following issue!

The project was renamed to Junior.


# Output Format

Encode and enclose your results as ./change.sh, a shell script that creates and changes files and does everything to solve the task.
Files are small, prefer heredoc-ing full files without substitution.
Assume OSX.
npm and jq are installed.
Do NOT write any text outside the script (the plan goes into it)!


EXAMPLE START

```sh
#!/bin/sh
# Goal: [Task description, max 7 words]
# Plan:
# 1. [...]

[Commands solving the task]
```

EXAMPLE END

",80
